using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace RemiChemieConsole
{
    internal class GausInter
    {

        internal GausInter()
        {
        }
        internal void CnvMoltCom(in byte b)
        {
            ConsoleKeyInfo cki;
            string s;
            GInWriter gi;
            do
            {
                Console.WriteLine("molファイルを幾つ変換しますか？\r\nキーを押してください。\r\n[H]一つ\r\n[F]複数\r\n[M]止める");
                cki = Console.ReadKey();
                if (cki.Key == ConsoleKey.H)
                {
                    FileInfo fi;
                    while (true)
                    {
                        Console.WriteLine("ファイルパスを入力してください。\r\n或いは空文字列を入力して止める。");
                        s = Console.ReadLine();
                        if (s == "") break;
                        if (File.Exists(s))
                        {
                            fi = new FileInfo(s);
                            gi = new GInWriter(in fi, b);
                        }
                        else Console.WriteLine("ファイルは存在しません。");
                    }
                }
                else if (cki.Key == ConsoleKey.F)
                {
                    DirectoryInfo di;
                    while (true)
                    {
                        Console.WriteLine("フォルダーパスを入力してください。\r\n或いは空文字列を入力して止める。");
                        s = Console.ReadLine();
                        if (s == "") break;
                        if (Directory.Exists(s))
                        {
                            di = new DirectoryInfo(s);
                            gi = new GInWriter(in di, b);
                        }
                        else Console.WriteLine("フォルダーは存在しません。");
                    }
                }
                if (cki.Key == ConsoleKey.M) return;
            } while (true);
        }
        internal void CnvLogtDes()
        {
            DirectoryInfo di;
            while (true)
            {
                Console.WriteLine("フォルダーパスを入力してください。\r\n或いは空文字列を入力して止める。");
                string s = Console.ReadLine();
                if (s == "") break;
                if (Directory.Exists(s))
                {
                    di = new DirectoryInfo(s);
                    GauDesc.GauDSRs(in di);
                }
                else Console.WriteLine("フォルダーは存在しません。");
            }
        }
    }

    internal class MolReader : IDisposable
    {
        private readonly string fpth;
        private bool Ic;//「沃素があるか」フラグ
        private bool Gec;//「ゲルマニウムがあるか」フラグ
        private bool Asc;//「砒素があるか」フラグ
        private bool Sec;//「セレンがあるか」フラグ
        private bool Snc;//「錫があるか」フラグ
        private bool Sbc;//「アンチモンがあるか」フラグ
        private bool Tec;//「テルルがあるか」フラグ
        private List<string> lsmolh;//ヘッダ
        private List<string> lsmolg;//原子
        private List<string> lsmolk;//結合
        private molfsc fsrc = 0;//molファイル由来
        private double[,] acs;//原子座標
        private byte[] als;//原子ラベル
        private short[,] bns;//結合情報(ラベル)
        private byte[] bos;//結合情報(結合次数)
        private short an;//原子数
        private short bn;//結合数
        private short bsum;//総結合数
        private double bavg;//平均結合次数
        private double unsat;//不飽和度=π結合数/原子数
        private readonly static Regex r1 = new Regex(@"^([\d\s]{3}){11}[\d\s\w]+$");//Molファイルのdescriptorフォーマット
        private readonly static Regex r2 = new Regex(@"^([\s\d-.]{10}){3}\s(\w[\w\s])[\s\w\d-]{36}$");//Molファイルの原子座標フォーマット
        private readonly static Regex r3 = new Regex(@"^([\s\d]{3}){3}(?:[\s\d]{3}){3}(?:[\s\d]{3})?$");//Molファイルの結合情報フォーマット
        internal bool MRIc
        {
            get
            {
                return Ic;
            }
        }
        internal bool MRGec
        {
            get
            {
                return Gec;
            }
        }
        internal bool MRAsc
        {
            get
            {
                return Asc;
            }
        }
        internal bool MRSec
        {
            get
            {
                return Sec;
            }
        }
        internal bool MRSnc
        {
            get
            {
                return Snc;
            }
        }
        internal bool MRSbc
        {
            get
            {
                return Sbc;
            }
        }
        internal bool MRTec
        {
            get
            {
                return Tec;
            }
        }
        internal double[,] MRacs
        {
            get
            {
                return acs;
            }
        }
        internal byte[] MRals
        {
            get
            {
                return als;
            }
        }
        internal short[,] MRbns
        {
            get
            {
                return bns;
            }
        }
        internal byte[] MRbos
        {
            get
            {
                return bos;
            }
        }
        internal short MRan
        {
            get
            {
                return an;
            }
        }
        internal short MRbn
        {
            get
            {
                return bn;
            }
        }
        internal short MRbsum
        {
            get
            {
                return bsum;
            }
        }
        internal double MRbavg
        {
            get
            {
                return bavg;
            }
        }
        internal double MRunsat
        {
            get
            {
                return unsat;
            }
        }
        internal MolReader(in string pth)
        {
            fpth = pth;
            if (!ReadProc()) throw new Exception("Can not create MolReader.");
            MolDsrClc();
        }
        private void Molread()
        {
            if (!File.Exists(fpth)) throw new FileNotFoundException("File doesn't exists", fpth);
            FileInfo fi = new FileInfo(fpth);
            if (fi.Extension != ".mol") throw new FileNotFoundException("File is not a .mol file", fpth);
            fi = null;
            using (FileStream fs = new FileStream(fpth, FileMode.Open, FileAccess.Read, FileShare.None))
            {
                using (StreamReader sr = new StreamReader(fs, Encoding.UTF8, false, -1, false))//Molは全部UTF8?
                {
                    string rs = sr.ReadLine();
                    if (rs == null) throw new ArgumentNullException("rs", "Mol file is empty");//molファイルは空
                    bool fg = false;//「descriptor読み取った」フラグ
                    lsmolh = new List<string>();
                    Match m1;
                    Group gp;
                    CaptureCollection cc;
                    while (rs != null)//descriptorが見つかるまで読み取る
                    {
                        m1 = r1.Match(rs);
                        if (!fg)
                        {
                            if (!m1.Success) lsmolh.Add(rs);
                            else
                            {
                                gp = m1.Groups[1];
                                if (!gp.Success) throw new ArgumentException("Molread(matching) : Can not match any", "gc");//不明エラー
                                cc = gp.Captures;
                                if (cc.Count != 11) throw new ArgumentException("Molread(descriptor) : Group length is not 11", "cc");//不明エラー
                                bool p = false;
                                p = short.TryParse(cc[0].Value, out an);
                                if (!p) throw new ArgumentException("Molread(descriptor(atom number)) : Atom number can not be parsed to short.", "p");//原子数エラー
                                p = false;
                                p = short.TryParse(cc[1].Value, out bn);
                                if (!p) throw new ArgumentException("Molread(descriptor(bond number)) : Bond number can not be parsed to short.", "p");//結合数エラー
                                //Console.WriteLine("KO : an={0}\tbn={1}", an, bn);//debug用
                                fg = true;
                            }
                        }
                        if (fg) break;
                        rs = sr.ReadLine();
                    }
                    if (!fg) throw new FormatException("Molread(descriptor) : Can not find descriptor.");//descriptor無し
                    int cnt = 0;
                    if (an <= 0 || an > 999) throw new ArgumentOutOfRangeException("an", "Molread(an) : Atom number is less than 1 or larger than 999.");//原子数は1-999
                    if (bn < 0) throw new ArgumentOutOfRangeException("bn", "Molread(bn) : Bond number is less than 0.");//結合数は自然数
                    lsmolg = new List<string>();
                    for (; cnt < an; cnt++)
                    {
                        rs = sr.ReadLine();
                        if (rs == null) throw new ArgumentNullException("rs", "No enough info in mol file");
                        lsmolg.Add(rs);
                    }
                    cnt = 0;
                    lsmolk = new List<string>();
                    for (; cnt < bn; cnt++)
                    {
                        rs = sr.ReadLine();
                        if (rs == null) throw new ArgumentNullException("rs", "No enough info in mol file");
                        lsmolk.Add(rs);
                    }
                }
            }
        }
        private void Molreadh()
        {
            ParallelOptions po = new ParallelOptions();
            CancellationTokenSource cts = new CancellationTokenSource();
            CancellationToken ct = cts.Token;
            po.CancellationToken = ct;
            po.MaxDegreeOfParallelism = CommonParam.thdn;
            po.TaskScheduler = TaskScheduler.Default;
            object lo = new object();//ロック
            bool flg = false;//「見つかった」フラグ
            try
            {
                Parallel.ForEach(lsmolh, po, (s) =>
                {
                    if (ct.IsCancellationRequested) { Console.WriteLine("cancelled"); return; }
                    //Console.WriteLine(A : s);//debug用
                    if (s.Contains("RemiChemie", StringComparison.CurrentCultureIgnoreCase))
                    {
                        lock (lo)
                        {
                            if (!flg)
                            {
                                //Console.WriteLine("SU : RemiChemie");//debug用
                                fsrc = molfsc.RemiChemie;
                                flg = true;
                                return;
                            }
                            else if (fsrc == molfsc.RemiChemie) return;
                            else if (fsrc == molfsc.Chem3D || fsrc == molfsc.GaussView)
                            {
                                //Console.WriteLine("E : dup");//debug用
                                fsrc = molfsc.Unknown;
                                cts.Cancel();
                                return;
                            }
                        }
                    }
                    if (s.Contains("Chem3D", StringComparison.CurrentCultureIgnoreCase))
                    {
                        lock (lo)
                        {
                            if (!flg)
                            {
                                //Console.WriteLine("A : found 3D");//debug用
                                fsrc = molfsc.Chem3D;
                                flg = true;
                                return;
                            }
                            else if (fsrc == molfsc.Chem3D) return;
                            else if (fsrc == molfsc.GaussView || fsrc == molfsc.RemiChemie)
                            {
                                //Console.WriteLine("SU : dup");//debug用
                                fsrc = molfsc.Unknown;
                                cts.Cancel();
                                return;
                            }
                        }
                    }
                    if (s.Contains("GaussView", StringComparison.CurrentCultureIgnoreCase))
                    {
                        lock (lo)
                        {
                            if (!flg)
                            {
                                //Console.WriteLine("KO : GaussView");//debug用
                                fsrc = molfsc.GaussView;
                                flg = true;
                                return;
                            }
                            else if (fsrc == molfsc.GaussView) return;
                            else if (fsrc == molfsc.Chem3D || fsrc == molfsc.RemiChemie)
                            {
                                //Console.WriteLine("E : dup");//debug用
                                fsrc = molfsc.Unknown;
                                cts.Cancel();
                                return;
                            }
                        }
                    }
                });
            }
            catch (Exception e)
            {
                Console.WriteLine("{0} => {1}\r\nSource : {2}", e.GetType(), e.Message, e.Source);
            }
            finally
            {
                //Console.WriteLine("KI : {0}",fsrc.ToString());//Debug用
                cts.Dispose();
            }
            lsmolh = null;
        }
        private void Molreadg()
        {
            if (lsmolg.Count != an) throw new ArgumentException("Molreadg : atom info changed.", "lsmolg");
            acs = new double[an, 3];
            als = new byte[an];
            Match m;
            GroupCollection gc;
            CaptureCollection cc;
            double d1, d2, d3;//xyz座標
            string al;//原子名
            NatAtoms na;
            byte? alb;//原子番号
            for (int cnt = 0; cnt < an; cnt++)
            {
                m = r2.Match(lsmolg[cnt]);
                if (!m.Success) throw new FormatException("Molreadg : String matching failed.");//マッチング出来ない
                gc = m.Groups;
                if (gc.Count != 3) throw new FormatException("Molreadg : Matching group number is not 3.");//3グループはず
                cc = gc[1].Captures;
                if (!double.TryParse(cc[0].Value, out d1)) throw new ArgumentException(string.Format("Molreadg (cnt={0}): x cannot be parsed to double", cnt), "d1");//x座標
                if (!double.TryParse(cc[1].Value, out d2)) throw new ArgumentException(string.Format("Molreadg (cnt={0}): y cannot be parsed to double", cnt), "d2");//y座標
                if (!double.TryParse(cc[2].Value, out d3)) throw new ArgumentException(string.Format("Molreadg (cnt={0}): z cannot be parsed to double", cnt), "d3");//z座標
                //Console.WriteLine("SU : d1={0} , d2={1} , d3={2}", d1, d2, d3);//debug用
                al = gc[2].Value.TrimEnd();
                na = new NatAtoms();
                alb = na.fthPfL(al);
                if (alb == null) throw new ArgumentNullException("alb", "Molreadg : Cannot get atom number");
                //Console.WriteLine("I : alb={0}", alb);//debug用
                acs[cnt, 0] = d1;
                acs[cnt, 1] = d2;
                acs[cnt, 2] = d3;
                als[cnt] = (byte)alb;
                if (!Ic && al == "I") Ic = true;
                if (!Gec && al == "Ge") Gec = true;
                if (!Asc && al == "As") Ic = true;
                if (!Sec && al == "Se") Sec = true;
                if (!Snc && al == "Sn") Snc = true;
                if (!Sbc && al == "Sb") Sbc = true;
                if (!Tec && al == "Te") Tec = true;
            }
            lsmolg = null;
        }
        private void Molreadk()
        {
            if (lsmolk.Count != bn) throw new ArgumentException("Molreadk : bond info changed.", "lsmolk");
            bns = new short[bn, 2];
            bos = new byte[bn];
            Match m;
            GroupCollection gc;
            CaptureCollection cc;
            short s1, s2;
            byte b;
            for (int cnt = 0; cnt < bn; cnt++)
            {
                m = r3.Match(lsmolk[cnt]);
                if (!m.Success) throw new FormatException("Molreadk : String matching failed.");//マッチング出来ない
                gc = m.Groups;
                if (gc.Count != 2) throw new FormatException("Molreadk : Matching group number is not 2.");//2グループはず
                cc = gc[1].Captures;
                if (!short.TryParse(cc[0].Value, out s1)) throw new ArgumentException(string.Format("Molreadg (cnt={0}): Lable1 cannot be parsed to short", cnt), "s1");//原子ラベル1
                if (!short.TryParse(cc[1].Value, out s2)) throw new ArgumentException(string.Format("Molreadg (cnt={0}): Lable2 cannot be parsed to short", cnt), "s2");//原子ラベル2
                if (!byte.TryParse(cc[2].Value, out b)) throw new ArgumentException(string.Format("Molreadg (cnt={0}): Bond order cannot be parsed to byte", cnt), "b");//結合次数
                //Console.WriteLine("KI : s1={0} , s2={1}", s1, s2);//debug用
                //Console.WriteLine("KO : b={0}", b);//debug用
                if (s1 < s2)
                {
                    bns[cnt, 0] = s1;
                    bns[cnt, 1] = s2;
                }
                else
                {
                    bns[cnt, 1] = s1;
                    bns[cnt, 0] = s2;
                }
                bos[cnt] = b;
            }
            lsmolk = null;
        }
        private bool ReadProc()
        {
            try
            {
                Molread();
            }
            catch (FileNotFoundException fnfe)
            {
                Console.WriteLine("ReadProc : FileNotFoundException ({0}) => {1}\r\nSource : {2}", fnfe.FileName, fnfe.Message, fnfe.Source);
                return false;
            }
            catch (ArgumentException ae)
            {
                Console.WriteLine("{0} ({1}) => {2}\r\nSource : {3}", ae.GetType(), ae.ParamName, ae.Message, ae.Source);
                return false;
            }
            try
            {
                Molreadh();
            }
            catch (Exception e)
            {
                Console.WriteLine("{0} => {1}\r\nSource : {2}", e.GetType(), e.Message, e.Source);
                return false;
            }
            Ic = false;
            try
            {
                Molreadg();
            }
            catch (ArgumentException ae)
            {
                Console.WriteLine("{0} ({1}) => {2}\r\nSource : {3}", ae.GetType(), ae.ParamName, ae.Message, ae.Source);
                return false;
            }
            catch (FormatException fe)
            {
                Console.WriteLine("FormatException => {0}\r\nSource : {1}", fe.Message, fe.Source);
                return false;
            }
            try
            {
                Molreadk();
            }
            catch (ArgumentException ae)
            {
                Console.WriteLine("{0} ({1}) => {2}\r\nSource : {3}", ae.GetType(), ae.ParamName, ae.Message, ae.Source);
                return false;
            }
            catch (FormatException fe)
            {
                Console.WriteLine("FormatException => {0}\r\nSource : {1}", fe.Message, fe.Source);
                return false;
            }
            return true;
        }
        private void MolDsrClc()
        {
            bsum = 0;
            double buns = 0;//π結合数
            foreach (byte b in bos)
            {
                bsum += b;
                if (b >= 2) buns += b;
            }
            bavg = (double)bsum / bn;
            unsat = buns / an;
        }
        private enum molfsc : byte//molファイル由来enum
        {
            Unknown = 0,//由来不明
            Chem3D = 1,
            GaussView = 2,
            RemiChemie = 3
        }
        public void Dispose()
        {
            acs = null;
            als = null;
            bns = null;
            bos = null;
        }
    }
    internal class GInWriter
    {
        gauj gjt;
        internal GInWriter(in FileInfo fi, byte gjta)
        {
            gjt = (gauj)gjta;
            string opth = fi.FullName;//元ファイルのフルパス
            string ext = fi.Extension;//元ファイルの拡張子
            string dir = fi.DirectoryName;//元ファイルのパス
            string n = fi.Name.TrimEnd(ext.ToCharArray());//元ファイル名
            StringBuilder sb = new StringBuilder();
            string ndir;
            try
            {
                ndir = NDirC(ref sb, in dir);
            }
            catch (Exception e)
            {
                Console.WriteLine("{0} => {1}\r\nSource : {2}", e.GetType(), e.Message, e.Source);
                throw new Exception("GInWriter : Cannot create directory.");
            }
            if (ext == ".mol")//.mol -> .com
            {
                sb.Append(string.Format("\\{0}.com", n));
                string pth = sb.ToString();//変換後ファイル名 
                if (!MtGInS(in n, in pth, in opth))
                {
                    Directory.Delete(ndir);
                    throw new Exception("GInWriter : Cannot convert file.");
                }
            }
        }
        internal GInWriter(in FileInfo[] fis, byte gjta)
        {

        }
        internal GInWriter(in DirectoryInfo di, byte gjta)
        {
            gjt = (gauj)gjta;
            string dir = di.FullName;//元フォルダーのパス
            FileInfo[] fis = di.GetFiles();
            StringBuilder sb = new StringBuilder();
            string ndir, s;
            bool flg = false;
            try
            {
                ndir = NDirC(ref sb, in dir);
            }
            catch (Exception e)
            {
                Console.WriteLine("{0} => {1}\r\nSource : {2}", e.GetType(), e.Message, e.Source);
                throw new Exception("GInWriter : Cannot create directory.");
            }
            s = sb.ToString();//変化先パス
            ParallelOptions po = new ParallelOptions();
            po.MaxDegreeOfParallelism = CommonParam.thdn;
            CancellationTokenSource cts = new CancellationTokenSource(TimeSpan.FromMinutes(1));
            CancellationToken ct = cts.Token;
            po.CancellationToken = ct;
            po.TaskScheduler = TaskScheduler.Default;
            try
            {
                Parallel.ForEach(fis, po, (fi) =>
                  {
                      string ext = fi.Extension;//元ファイルの拡張子
                      if (ext == ".mol")//.mol -> .com
                      {
                          string opth = fi.FullName;//元ファイルのフルパス
                          string n = fi.Name.TrimEnd(ext.ToCharArray());//元ファイル名
                          //Console.WriteLine("SU : name={0}", n);//debug用
                          StringBuilder sb2 = new StringBuilder(s);
                          sb2.Append(string.Format("\\{0}.com", n));
                          string pth = sb2.ToString();//変換後ファイル名 
                          if (!MtGInS(in n, in pth, in opth))
                          {
                              throw new Exception(string.Format("GInWriter : Cannot convert file : {0}.", fi.FullName));
                          }
                          flg = true;
                      }
                      else return;
                  });
            }
            catch (Exception e)
            {
                Console.WriteLine("{0} => {1}\r\nSource : {2}", e.GetType(), e.Message, e.Source);
            }
            if (!flg) Directory.Delete(ndir);//転換できるファイルが存在しない
        }
        private string NDirC(ref StringBuilder sb, in string dir)//新しい変換先を作る
        {
            string ndir;
            sb.Append(dir);
            sb.Append(string.Format("\\GIn{0}", gjt.ToString()));
            ndir = sb.ToString();
            if (!Directory.Exists(ndir))
            {
                Directory.CreateDirectory(ndir);
            }
            else
            {
                DateTime dt = DateTime.Now;
                //Console.WriteLine("E : {0:F}", dt);//debug用
                string apd = dt.ToString("yyMMdd", CultureInfo.GetCultureInfo("ja-JP"));
                sb.Append(apd);
                ndir = sb.ToString();
                if (!Directory.Exists(ndir))
                {
                    Directory.CreateDirectory(ndir);
                }
                else
                {
                    apd = dt.ToString("HHmmss", CultureInfo.GetCultureInfo("ja-JP"));
                    sb.Append("_");
                    sb.Append(apd);
                    ndir = sb.ToString();
                    if (!Directory.Exists(ndir))
                    {
                        Directory.CreateDirectory(ndir);
                    }
                    else throw new Exception("Please remove old folders in file directory.");//「\GIn{ジョブ名}yyMMdd_HHmmss」フォルダーが存在する。あり得へん！
                }
            }
            return ndir;
        }
        private bool MtGInS(in string n, in string pth, in string opth)// )
        {
            MolReader mr;
            try
            {
                mr = new MolReader(in opth);
            }
            catch (Exception e)
            {
                Console.WriteLine("{0} => {1}\r\nSource : {2}", e.GetType(), e.Message, e.Source);
                return false;
            }
            using (FileStream fs = new FileStream(pth, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None))
            {
                StringBuilder sb = new StringBuilder();
                int cnt = 0, cnt2 = 0;
                NatAtoms na = new NatAtoms();
                sb.AppendLine("%nprocshared=40");
                sb.AppendLine("%mem=10000MW");
                sb.Append("%chk=");
                sb.Append(n);
                sb.AppendLine(".chk");
                switch (gjt)
                {
                    case gauj.Unknown:
                        {
                            sb.AppendLine("");
                            break;
                        }
                    case gauj.DFT:
                        {
                            if (!(mr.MRIc || mr.MRGec || mr.MRAsc || mr.MRSec || mr.MRSnc || mr.MRSbc || mr.MRTec)) sb.AppendLine("# opt freq=vcd b3lyp/def2svp pop=(mk,full,hirshfeld,nbo)");
                            else sb.AppendLine("# opt freq=vcd b3lyp/def2svp pop=(mk,readradii,full,hirshfeld,nbo)");
                            sb.AppendLine("geom=connectivity polar=optrot");
                            break;
                        }
                    case gauj.TD:
                        {
                            sb.AppendLine("# td=(nstates=20) b3lyp/def2svp geom=connectivity");
                            break;
                        }
                    default:
                        {
                            sb.AppendLine("");
                            break;
                        }
                }
                sb.AppendLine("");
                sb.AppendLine(n);
                sb.AppendLine("");
                sb.AppendLine("0 1");
                for (; cnt < mr.MRan; cnt++)
                {
                    sb.Append(" ");
                    sb.Append(string.Format("{0,-15}", na.fthLfP(mr.MRals[cnt])));
                    sb.Append(string.Format("{0,14}", mr.MRacs[cnt, 0].ToString("N8", CultureInfo.InvariantCulture)));
                    sb.Append(string.Format("{0,14}", mr.MRacs[cnt, 1].ToString("N8", CultureInfo.InvariantCulture)));
                    sb.Append(string.Format("{0,14}", mr.MRacs[cnt, 2].ToString("N8", CultureInfo.InvariantCulture)));
                    sb.AppendLine("");
                }
                sb.AppendLine("");
                cnt = 1;
                for (; cnt <= mr.MRan; cnt++)
                {
                    sb.Append(" ");
                    sb.Append(cnt);
                    while (cnt2 < mr.MRbn && mr.MRbns[cnt2, 0] == cnt)
                    {
                        sb.Append(" ");
                        sb.Append(mr.MRbns[cnt2, 1].ToString());
                        sb.Append(" ");
                        sb.Append(mr.MRbos[cnt2].ToString());
                        sb.Append(".0");
                        cnt2++;
                    }
                    sb.AppendLine("");
                }
                if (mr.MRIc || mr.MRGec || mr.MRAsc || mr.MRSec || mr.MRSnc || mr.MRSbc || mr.MRTec)
                {
                    StringBuilder sb2 = new StringBuilder();
                    bool sbf = true;
                    if (mr.MRIc)
                    {
                        sb2.Append("I 2.30");
                        sbf = false;
                    }
                    if (mr.MRGec)
                    {
                        sb2.Append("Ge 2.45");
                        sbf = false;
                    }
                    if (mr.MRAsc)
                    {
                        sb2.Append("As 2.40");
                        sbf = false;
                    }
                    if (mr.MRSec)
                    {
                        sb2.Append("Se 2.35");
                        sbf = false;
                    }
                    if (mr.MRSnc)
                    {
                        if (sbf == false) sb2.Append("\r\n");
                        sb2.Append("Sn 2.45");
                        sbf = false;
                    }
                    if (mr.MRSbc)
                    {
                        sb2.Append("Sb 2.40");
                        sbf = false;
                    }
                    if (mr.MRTec)
                    {
                        if (sbf == false) sb2.Append("\r\n");
                        sb2.Append("Te 2.35");
                    }
                    string sttemp = sb2.ToString();
                    sb.AppendLine(string.Format("\r\n{0}\r\n\r\n{0}\r\n\r\n{0}", sttemp));
                }
                sb.AppendLine("");
                using (StreamWriter sw = new StreamWriter(fs, Encoding.UTF8, -1, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            mr.Dispose();
            return true;
        }
        private void MtGInM()
        {

        }
        private void MtGInD()
        {

        }
        protected enum gauj : byte//DFT種類
        {
            Unknown = 0,//不明
            DFT = 1,
            TD = 2,//UV-visの為のTD-DFT
        }
    }
    internal class GLogReader : IDisposable
    {
        private readonly string fpth;
        private int an;//原子数
        private short rn;//結合数
        private short agn;//結合角数
        private short dn;//結合二面角数
        private byte[] als;//原子ラベル
        private double[,] acs;//原子座標
        private int[,] rdl;//結合ラベル
        private double[] rdd;//結合長
        private int[,] agl;//結合角ラベル
        private double[] agd;//結合角角度
        private int[,] dhl;//結合二面角ラベル
        private double[] dhd;//結合二面角角度
        private int dof;//自由度
        private int toco;//総座標数
        private double[,] soco;//標準配向座標
        private double[] rc;//回転定数
        private short bfn;//基底関数個数 = 原子軌道数
        private double[] mlkc;//Mulliken電荷
        private short han;//重原子数
        private double[] mhsc;//重原子Mulliken電荷
        private double ese;//ESE
        private double[] dipmm;//双極子モーメントベクトル
        private double dipm;//双極子モーメント
        private double[,] qdpmt;//四極子モーメント行列
        private double[,] tlqmt;//トレスレス四極子モーメント行列
        private double[,,] ocpmt;//八極子モーメントテンソル
        private double[,,,] hdpmt;//十六極子モーメント4テンソル
        private short occmo;//占有軌道数
        private short vrtmo;//空軌道数
        private double s2lme;//第三空軌道エネルギー
        private int s2lmei;//第三空軌道エネルギーインデックス
        private double s2lmke;//第三空軌道運動エネルギー
        private double slme;//第二空軌道エネルギー
        private int slmei;//第二空軌道エネルギーインデックス
        private double slmke;//第二空軌道運動エネルギー
        private double lme;//最低空軌道エネルギー
        private int lmei;//最低空軌道エネルギーインデックス
        private double lmke;//最低空軌道運動エネルギー
        private double hme;//最高被占軌道エネルギー
        private int hmei;//最高被占軌道エネルギーインデックス
        private double hmke;//最高被占軌道運動エネルギー
        private double shme;//第二被占軌道エネルギー
        private int shmei;//第二被占軌道エネルギーインデックス
        private double shmke;//第二被占軌道運動エネルギー
        private double s2hme;//第三被占軌道エネルギー
        private int s2hmei;//第三被占軌道エネルギーインデックス
        private double s2hmke;//第三被占軌道運動エネルギー
        private double[] moev;//分子軌道エネルギーベクトル
        private bool moevo;//分子軌道エネルギーベクトル順番occ->virt?
        private double[,] mocm;//分子軌道係数行列(行 = 原子軌道   ,   列 = 分子軌道)
        private int[] aobl;//原子軌道境界線
        private string[] aol;//原子軌道ラベル
        private double[,] dnsm;//密度行列
        private double[,] mpam;//Mulliken電子解析行列
        private double[] gop;//総軌道電子
        private double[,] cdnsm;//縮約密度行列
        private double nnrepe;//反発エネルギー
        private double enatre;//吸引エネルギー
        private double keknte;//運動エネルギー
        private double eisd;//EISum from density
        private double eisad;//EISum from atomic densities
        private double[] HCAB;//Hirshfeld CA/CB
        private double[,] HDXYZ;//Hirshfeld DipX/DipY/DipZ
        private double HCABt;//total Hirshfeld CA/CB
        private double[] HDXYZt;//total Hirshfeld DipX/DipY/DipZ
        private double[] HDipc;//Hirshfeld Dip from chg
        private double[] HDipt;//Hirshfeld total Dip
        private double[] Hachg;//Hirshfeld原子電荷
        private double[] Hacm5chg;//Hirshfeld原子CM5電荷
        private double[] Hhachg;//Hirshfeld重原子電荷
        private double[] Hhacm5chg;//Hirshfeld重原子CM5電荷
        private double Hchgt;//Hirshfeld total 電荷
        private double EDD;//EDD、なにこれ
        private double[] oke;//軌道運動エネルギー
        private double toke;//総軌道運動エネルギー
        private double[] ESPc;//ESP電荷
        private double[] ESPch;//ESP重原子電荷
        private double[] ESPdip;//ESP双極子モーメントベクトル
        private double ESPdipt;//ESP双極子モーメント
        private double[] aep;//原子電位
        private double[] naooc;//自然原子軌道占有電子数
        private double[] naoen;//自然原子軌道エネルギー
        private bool?[] naot;//自然原子軌道タイプ、true=core、false=valence、null=Rydberg
        private double[] nch;//自然電荷
        private double[] npc;//自然核電子
        private double[] npv;//自然価電子
        private double[] npr;//自然リュードベリ電子
        private double[] npt;//自然全電子
        private double npcr;//自然核電子率
        private double npvr;//自然価電子率
        private double nmbr;//自然最小基底率
        private double nrbr;//自然リュードベリ基底率
        private double[] nec2s;//2s軌道自然電子配置
        private double[] nec2p;//2p軌道自然電子配置
        private double[] necns;//3/4/5/6s軌道自然電子配置
        private double[] necnp;//3/4/5/6p軌道自然電子配置
        private double nbvl;//価層ルイス電子
        private double nbtl;//全ルイス電子
        private double nbvnl;//価層非ルイス電子
        private double nbrnl;//リュードベリ非ルイス電子
        private double nbtnl;//全非ルイス電子
        private int nbo1n;//一中心NBO個数
        private int nbo2n;//二中心NBO個数
        private short[] nboi1;//一中心NBOインデックス
        private short[] nboi2;//二中心NBOインデックス
        private double[] nboo1;//一中心NBO占有数
        private double[] nboo2;//二中心NBO占有数
        private string[] nbot1;//一中心NBOタイプ
        private string[] nbot2;//二中心NBOタイプ
        private byte[] nbok1;//一中心NBO数え
        private byte[] nbok2;//二中心NBO数え
        private int[] nbon1;//一中心NBO原子インデックス
        private int[] nbon21;//二中心NBO原子インデックス1
        private int[] nbon22;//二中心NBO原子インデックス2
        private double[] nbos1;//一中心NBOs軌道混合率
        private double[] nbop1;//一中心NBOp軌道混合率
        private double[] nbod1;//一中心NBOd軌道混合率
        private double[] nbos21;//二中心NBOs軌道混合率1
        private double[] nbos22;//二中心NBOs軌道混合率2
        private double[] nbop21;//二中心NBOp軌道混合率1
        private double[] nbop22;//二中心NBOp軌道混合率2
        private double[] nbod21;//二中心NBOd軌道混合率1
        private double[] nbod22;//二中心NBOd軌道混合率2
        private double[] nbor21;//二中心NBO原子混合率1
        private double[] nbor22;//二中心NBO原子混合率2
        private short[] nhon;//NHO番号
        private double[] nhod1;//NHO結合曲がり1
        private double[] nhod2;//NHO結合曲がり2
        private short[] sopd;//二次摂動理論分析ドナーインデックス
        private short[] sopa;//二次摂動理論分析アクセプターインデックス
        private double[] sope;//二次摂動理論分析安定化エネルギー
        private double[] nboe1;//一中心NBOエネルギー
        private double[] nboe2;//二中心NBOエネルギー
        private double nre;//核反発エネルギー
        private double scfe;//自己無撞着場エネルギー
        private double[] gmsi;//GIAO等方磁気遮蔽
        private double[] gmsa;//GIAO異方磁気遮蔽
        private double[,,] gmst;//GIAO磁気遮蔽テンソル
        private double[,] gmse;//GIAO磁気遮蔽固有値
        private double ispo;//等方性分極率
        private double[,] dmdp;//磁気双極子分極率
        private double[,] dqct;//DQテンソル
        private double[,] orgt;//旋光Gテンソル
        private double[] orge;//旋光G固有値
        private double orgi;//iso旋光G
        private double[,] orgev;//旋光G固有ベクトル
        private double Mmass;//分子量
        private double AlphaD;//alpha D
        private double[] APTc;//APT電荷
        private double[] APThc;//重原子APT電荷
        private double[,] Epol;//精確分極率
        private double[,] Apol;//近似分極率
        private double[] mwfc;//弾力定数行列低値
        private double[] dvp;//対角振動分極率
        private double[,,] noco;//正規座標
        private double[] ncfrq;//正規座標周波数
        private double[] ncrm;//正規座標換算質量
        private double[] ncfc;//正規座標力定数
        private double[] ncii;//正規座標赤外線強度
        private double[] ncds;//正規座標双極子強度
        private double[] ncrs;//正規座標回転強度
        private double[] ncema;//正規座標E-M遷移双極子モーメント夾角
        private double[,] pax;//慣性主軸
        private double[] rott;//回転温度
        private double zpve;//零点エネルギー
        private double tce;//内部エネルギー修正値
        private double tcet;//エンタルピー修正値
        private double tcg;//ギブス自由エネルギー修正値
        private double sezpe;//電子と零点エネルギー
        private double sete;//電子と内部エネルギー
        private double setet;//電子とエンタルピー
        private double setfe;//電子と自由エネルギー
        private double ett;//総内部エネルギー
        private double ettr;//並進・回転内部エネルギー
        private double etv;//振動内部エネルギー
        private double cvt;//総等容比熱
        private double cvtr;//並進・回転等容比熱
        private double cvv;//振動等容比熱
        private double stot;//総エントロピー
        private double sttr;//並進エントロピー
        private double stro;//回転エントロピー
        private double svib;//振動エントロピー
        private int lfvn;//低周波数振動数
        private double[] lfve;//低周波数振動内部エネルギー
        private double[] lfvcv;//低周波数振動等容比熱
        private double[] lfvs;//低周波数振動エントロピー
        private double lnqtb;//総Bot分配関数
        private double lnqtv;//総V=0分配関数
        private double lnqvb;//Bot振動分配関数
        private double[] lnqvbs;//Bot低周波数振動分配関数
        private double lnqvv;//V=0振動分配関数
        private double[] lnqvvs;//V=0低周波数振動分配関数
        private double lnqt;//並進分配関数
        private double lnqr;//回転分配関数
        private double[,] dico;//双極子配向
        private double edmdo;//電気双極子モーメント
        private double dpiso;//等方性電気双極子分極率
        private double dpaniso;//異方性電気双極子分極率
        private double[,] dpam;//電気双極子分極率Alpha行列
        private bool fuckedstructure = false;
        internal int _an
        {
            get
            {
                return an;
            }
        }
        internal short _rn
        {
            get
            {
                return rn;
            }
        }
        internal short _agn
        {
            get
            {
                return agn;
            }
        }
        internal short _dn
        {
            get
            {
                return dn;
            }
        }
        //妬し
        internal byte[] _als
        {
            get
            {
                return als;
            }
        }
        internal double[,] _acs
        {
            get
            {
                return acs;
            }
        }
        internal int[,] _rdl
        {
            get
            {
                return rdl;
            }
        }
        internal double[] _rdd
        {
            get
            {
                return rdd;
            }
        }
        internal int[,] _agl
        {
            get
            {
                return agl;
            }
        }
        internal double[] _agd
        {
            get
            {
                return agd;
            }
        }
        internal int[,] _dhl
        {
            get
            {
                return dhl;
            }
        }
        internal double[] _dhd
        {
            get
            {
                return dhd;
            }
        }
        internal int _dof
        {
            get
            {
                return dof;
            }
        }
        internal int _toco
        {
            get
            {
                return toco;
            }
        }
        internal double[,] _soco
        {
            get
            {
                return soco;
            }
        }
        internal double[] _rc
        {
            get
            {
                return rc;
            }
        }
        internal short _bfn
        {
            get
            {
                return bfn;
            }
        }
        internal double[] _mlkc
        {
            get
            {
                return mlkc;
            }
        }
        internal short _han
        {
            get
            {
                return han;
            }
        }
        internal double[] _mhsc
        {
            get
            {
                return mhsc;
            }
        }
        internal double _ese
        {
            get
            {
                return ese;
            }
        }
        internal double[] _dipmm
        {
            get
            {
                return dipmm;
            }
        }
        internal double _dipm
        {
            get
            {
                return dipm;
            }
        }
        internal double[,] _qdpmt
        {
            get
            {
                return qdpmt;
            }
        }
        internal double[,] _tlqmt
        {
            get
            {
                return tlqmt;
            }
        }
        internal double[,,] _ocpmt
        {
            get
            {
                return ocpmt;
            }
        }
        internal double[,,,] _hdpmt
        {
            get
            {
                return hdpmt;
            }
        }
        internal short _occmo
        {
            get
            {
                return occmo;
            }
        }
        internal short _vrtmo
        {
            get
            {
                return vrtmo;
            }
        }
        internal double _s2lme
        {
            get
            {
                return s2lme;
            }
        }
        internal int _s2lmei
        {
            get
            {
                return s2lmei;
            }
        }
        internal double _s2lmke
        {
            get
            {
                return s2lmke;
            }
        }
        internal double _slme
        {
            get
            {
                return slme;
            }
        }
        internal int _slmei
        {
            get
            {
                return slmei;
            }
        }
        internal double _slmke
        {
            get
            {
                return slmke;
            }
        }
        internal double _lme
        {
            get
            {
                return lme;
            }
        }
        internal int _lmei
        {
            get
            {
                return lmei;
            }
        }
        internal double _lmke
        {
            get
            {
                return lmke;
            }
        }
        internal double _hme
        {
            get
            {
                return hme;
            }
        }
        internal int _hmei
        {
            get
            {
                return hmei;
            }
        }
        internal double _hmke
        {
            get
            {
                return hmke;
            }
        }
        internal double _shme
        {
            get
            {
                return shme;
            }
        }
        internal int _shmei
        {
            get
            {
                return shmei;
            }
        }
        internal double _shmke
        {
            get
            {
                return shmke;
            }
        }
        internal double _s2hme
        {
            get
            {
                return s2hme;
            }
        }
        internal int _s2hmei
        {
            get
            {
                return s2hmei;
            }
        }
        internal double _s2hmke
        {
            get
            {
                return s2hmke;
            }
        }
        internal double[] _moev
        {
            get
            {
                return moev;
            }
        }
        internal bool _moevo
        {
            get
            {
                return moevo;
            }
        }
        internal double[,] _mocm
        {
            get
            {
                return mocm;
            }
        }
        internal int[] _aobl
        {
            get
            {
                return aobl;
            }
        }
        internal string[] _aol
        {
            get
            {
                return aol;
            }
        }
        internal double[,] _dnsm
        {
            get
            {
                return dnsm;
            }
        }
        internal double[,] _mpam
        {
            get
            {
                return mpam;
            }
        }
        internal double[] _gop
        {
            get
            {
                return gop;
            }
        }
        internal double[,] _cdnsm
        {
            get
            {
                return cdnsm;
            }
        }
        internal double _nnrepe
        {
            get
            {
                return nnrepe;
            }
        }
        internal double _enatre
        {
            get
            {
                return enatre;
            }
        }
        internal double _keknte
        {
            get
            {
                return keknte;
            }
        }
        internal double _eisd
        {
            get
            {
                return eisd;
            }
        }
        internal double _eisad
        {
            get
            {
                return eisad;
            }
        }
        internal double[] _HCAB
        {
            get
            {
                return HCAB;
            }
        }
        internal double[,] _HDXYZ
        {
            get
            {
                return HDXYZ;
            }
        }
        internal double _HCABt
        {
            get
            {
                return HCABt;
            }
        }
        internal double[] _HDXYZt
        {
            get
            {
                return HDXYZt;
            }
        }
        internal double[] _HDipc
        {
            get
            {
                return HDipc;
            }
        }
        internal double[] _HDipt
        {
            get
            {
                return HDipt;
            }
        }
        internal double[] _Hachg
        {
            get
            {
                return Hachg;
            }
        }
        internal double[] _Hacm5chg
        {
            get
            {
                return Hacm5chg;
            }
        }
        internal double[] _Hhachg
        {
            get
            {
                return Hhachg;
            }
        }
        internal double[] _Hhacm5chg
        {
            get
            {
                return Hhacm5chg;
            }
        }
        internal double _Hchgt
        {
            get
            {
                return Hchgt;
            }
        }
        internal double _EDD
        {
            get
            {
                return EDD;
            }
        }
        internal double[] _oke
        {
            get
            {
                return oke;
            }
        }
        internal double _toke
        {
            get
            {
                return toke;
            }
        }
        internal double[] _ESPc
        {
            get
            {
                return ESPc;
            }
        }
        internal double[] _ESPch
        {
            get
            {
                return ESPch;
            }
        }
        internal double[] _ESPdip
        {
            get
            {
                return ESPdip;
            }
        }
        internal double _ESPdipt
        {
            get
            {
                return ESPdipt;
            }
        }
        internal double[] _aep
        {
            get
            {
                return aep;
            }
        }
        internal double[] _naooc
        {
            get
            {
                return naooc;
            }
        }
        internal double[] _naoen
        {
            get
            {
                return naoen;
            }
        }
        internal bool?[] _naot
        {
            get
            {
                return naot;
            }
        }
        internal double[] _nch
        {
            get
            {
                return nch;
            }
        }
        internal double[] _npc
        {
            get
            {
                return npc;
            }
        }
        internal double[] _npv
        {
            get
            {
                return npv;
            }
        }
        internal double[] _npr
        {
            get
            {
                return npr;
            }
        }
        internal double[] _npt
        {
            get
            {
                return npt;
            }
        }
        internal double _npcr
        {
            get
            {
                return npcr;
            }
        }
        internal double _npvr
        {
            get
            {
                return npvr;
            }
        }
        internal double _nmbr
        {
            get
            {
                return nmbr;
            }
        }
        internal double _nrbr
        {
            get
            {
                return nrbr;
            }
        }
        internal double[] _nec2s
        {
            get
            {
                return nec2s;
            }
        }
        internal double[] _nec2p
        {
            get
            {
                return nec2p;
            }
        }
        internal double[] _necns
        {
            get
            {
                return necns;
            }
        }
        internal double[] _necnp
        {
            get
            {
                return necnp;
            }
        }
        internal double _nbvl
        {
            get
            {
                return nbvl;
            }
        }
        internal double _nbtl
        {
            get
            {
                return nbtl;
            }
        }
        internal double _nbvnl
        {
            get
            {
                return nbvnl;
            }
        }
        internal double _nbrnl
        {
            get
            {
                return nbrnl;
            }
        }
        internal double _nbtnl
        {
            get
            {
                return nbtnl;
            }
        }
        internal int _nbo1n
        {
            get
            {
                return nbo1n;
            }
        }
        internal int _nbo2n
        {
            get
            {
                return nbo2n;
            }
        }
        internal short[] _nboi1
        {
            get
            {
                return nboi1;
            }
        }
        internal short[] _nboi2
        {
            get
            {
                return nboi2;
            }
        }
        internal double[] _nboo1
        {
            get
            {
                return nboo1;
            }
        }
        internal double[] _nboo2
        {
            get
            {
                return nboo2;
            }
        }
        internal string[] _nbot1
        {
            get
            {
                return nbot1;
            }
        }
        internal string[] _nbot2
        {
            get
            {
                return nbot2;
            }
        }
        internal byte[] _nbok1
        {
            get
            {
                return nbok1;
            }
        }
        internal byte[] _nbok2
        {
            get
            {
                return nbok2;
            }
        }
        internal int[] _nbon1
        {
            get
            {
                return nbon1;
            }
        }
        internal int[] _nbon21
        {
            get
            {
                return nbon21;
            }
        }
        internal int[] _nbon22
        {
            get
            {
                return nbon22;
            }
        }
        internal double[] _nbos1
        {
            get
            {
                return nbos1;
            }
        }
        internal double[] _nbop1
        {
            get
            {
                return nbop1;
            }
        }
        internal double[] _nbod1
        {
            get
            {
                return nbod1;
            }
        }
        internal double[] _nbos21
        {
            get
            {
                return nbos21;
            }
        }
        internal double[] _nbos22
        {
            get
            {
                return nbos22;
            }
        }
        internal double[] _nbop21
        {
            get
            {
                return nbop21;
            }
        }
        internal double[] _nbop22
        {
            get
            {
                return nbop22;
            }
        }
        internal double[] _nbod21
        {
            get
            {
                return nbod21;
            }
        }
        internal double[] _nbod22
        {
            get
            {
                return nbod22;
            }
        }
        internal double[] _nbor21
        {
            get
            {
                return nbor21;
            }
        }
        internal double[] _nbor22
        {
            get
            {
                return nbor22;
            }
        }
        internal short[] _nhon
        {
            get
            {
                return nhon;
            }
        }
        internal double[] _nhod1
        {
            get
            {
                return nhod1;
            }
        }
        internal double[] _nhod2
        {
            get
            {
                return nhod2;
            }
        }
        internal short[] _sopd
        {
            get
            {
                return sopd;
            }
        }
        internal short[] _sopa
        {
            get
            {
                return sopa;
            }
        }
        internal double[] _sope
        {
            get
            {
                return sope;
            }
        }
        internal double[] _nboe1
        {
            get
            {
                return nboe1;
            }
        }
        internal double[] _nboe2
        {
            get
            {
                return nboe2;
            }
        }
        internal double _nre
        {
            get
            {
                return nre;
            }
        }
        internal double _scfe
        {
            get
            {
                return scfe;
            }
        }
        internal double[] _gmsi
        {
            get
            {
                return gmsi;
            }
        }
        internal double[] _gmsa
        {
            get
            {
                return gmsa;
            }
        }
        internal double[,,] _gmst
        {
            get
            {
                return gmst;
            }
        }
        internal double[,] _gmse
        {
            get
            {
                return gmse;
            }
        }
        internal double _ispo
        {
            get
            {
                return ispo;
            }
        }
        internal double[,] _dmdp
        {
            get
            {
                return dmdp;
            }
        }
        internal double[,] _dqct
        {
            get
            {
                return dqct;
            }
        }
        internal double[,] _orgt
        {
            get
            {
                return orgt;
            }
        }
        internal double[] _orge
        {
            get
            {
                return orge;
            }
        }
        internal double _orgi
        {
            get
            {
                return orgi;
            }
        }
        internal double[,] _orgev
        {
            get
            {
                return orgev;
            }
        }
        internal double _Mmass
        {
            get
            {
                return Mmass;
            }
        }
        internal double _AlphaD
        {
            get
            {
                return AlphaD;
            }
        }
        internal double[] _APTc
        {
            get
            {
                return APTc;
            }
        }
        internal double[] _APThc
        {
            get
            {
                return APThc;
            }
        }
        internal double[,] _Epol
        {
            get
            {
                return Epol;
            }
        }
        internal double[,] _Apol
        {
            get
            {
                return Apol;
            }
        }
        internal double[] _mwfc
        {
            get
            {
                return mwfc;
            }
        }
        internal double[] _dvp
        {
            get
            {
                return dvp;
            }
        }
        internal double[,,] _noco
        {
            get
            {
                return noco;
            }
        }
        internal double[] _ncfrq
        {
            get
            {
                return ncfrq;
            }
        }
        internal double[] _ncrm
        {
            get
            {
                return ncrm;
            }
        }
        internal double[] _ncfc
        {
            get
            {
                return ncfc;
            }
        }
        internal double[] _ncii
        {
            get
            {
                return ncii;
            }
        }
        internal double[] _ncds
        {
            get
            {
                return ncds;
            }
        }
        internal double[] _ncrs
        {
            get
            {
                return ncrs;
            }
        }
        internal double[] _ncema
        {
            get
            {
                return ncema;
            }
        }
        internal double[,] _pax
        {
            get
            {
                return pax;
            }
        }
        internal double[] _rott
        {
            get
            {
                return rott;
            }
        }
        internal double _zpve
        {
            get
            {
                return zpve;
            }
        }
        internal double _tce
        {
            get
            {
                return tce;
            }
        }
        internal double _tcet
        {
            get
            {
                return tcet;
            }
        }
        internal double _tcg
        {
            get
            {
                return tcg;
            }
        }
        internal double _sezpe
        {
            get
            {
                return sezpe;
            }
        }
        internal double _sete
        {
            get
            {
                return sete;
            }
        }
        internal double _setet
        {
            get
            {
                return setet;
            }
        }
        internal double _setfe
        {
            get
            {
                return setfe;
            }
        }
        internal double _ett
        {
            get
            {
                return ett;
            }
        }
        internal double _ettr
        {
            get
            {
                return ettr;
            }
        }
        internal double _etv
        {
            get
            {
                return etv;
            }
        }
        internal double _cvt
        {
            get
            {
                return cvt;
            }
        }
        internal double _cvtr
        {
            get
            {
                return cvtr;
            }
        }
        internal double _cvv
        {
            get
            {
                return cvv;
            }
        }
        internal double _stot
        {
            get
            {
                return stot;
            }
        }
        internal double _sttr
        {
            get
            {
                return sttr;
            }
        }
        internal double _stro
        {
            get
            {
                return stro;
            }
        }
        internal double _svib
        {
            get
            {
                return svib;
            }
        }
        internal int _ifvn
        {
            get
            {
                return lfvn;
            }
        }
        internal double[] _lfve
        {
            get
            {
                return lfve;
            }
        }
        internal double[] _lfvcv
        {
            get
            {
                return lfvcv;
            }
        }
        internal double[] _lfvs
        {
            get
            {
                return lfvs;
            }
        }
        internal double _lnqtb
        {
            get
            {
                return lnqtb;
            }
        }
        internal double _lnqtv
        {
            get
            {
                return lnqtv;
            }
        }
        internal double _lnqvb
        {
            get
            {
                return lnqvb;
            }
        }
        internal double[] _lnqvbs
        {
            get
            {
                return lnqvbs;
            }
        }
        internal double _lnqvv
        {
            get
            {
                return lnqvv;
            }
        }
        internal double[] _lnqvvs
        {
            get
            {
                return lnqvvs;
            }
        }
        internal double _lnqt
        {
            get
            {
                return lnqt;
            }
        }
        internal double _lnqr
        {
            get
            {
                return lnqr;
            }
        }
        internal double[,] _dico
        {
            get
            {
                return dico;
            }
        }
        internal double _edmdo
        {
            get
            {
                return edmdo;
            }
        }
        internal double _dpiso
        {
            get
            {
                return dpiso;
            }
        }
        internal double _dpaniso
        {
            get
            {
                return dpaniso;
            }
        }
        internal double[,] _dpam
        {
            get
            {
                return dpam;
            }
        }
        internal readonly static Regex r1 = new Regex(@"^\s*Charge\s*=\s*\d+\s*Multiplicity\s*=\s*\d+\s?$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, Regex.InfiniteMatchTimeout);//電荷と多重度情報
        internal readonly static Regex r2 = new Regex(@"^\s*(\p{L}+)\s+([-.\d]+)\s+([-.\d]+)\s+([-.\d]+)\s*$", RegexOptions.None, CommonParam.ts);//原子座標情報
        internal readonly static Regex r3 = new Regex(@"^\s?(?:Grad)+\s?$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分割線
        internal readonly static Regex r4 = new Regex(@"\s+!\s+Initial\s+Parameters\s+!\s?", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//入力パラメータタイトル
        internal readonly static Regex r5 = new Regex(@"^\s+!\s+R(\d+)\s+R\((\d+),(\d+)\)\s+([\d.]+)[\s\d\p{L}/]+!\s*$", RegexOptions.None, CommonParam.ts);//結合長情報
        internal readonly static Regex r6 = new Regex(@"^\s+!\s+A(\d+)\s+A\((\d+),(\d+),(\d+)\)\s+([\d.]+)[\s\d\p{L}/]+!\s*$", RegexOptions.None, CommonParam.ts);//結合角情報
        internal readonly static Regex r7 = new Regex(@"^\s+!\s+D(\d+)\s+D\((\d+),(\d+),(\d+),(\d+)\)\s+([-\d.]+)[\s\d\p{L}/]+!\s*$", RegexOptions.None, CommonParam.ts);//結合二面角情報
        internal readonly static Regex r8 = new Regex(@"^\s*Deg\.\sof\sfreedom\s*(\d+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自由度情報
        internal readonly static Regex r9 = new Regex(@"^\s+Standard\sorientation:\s+$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//標準配向タイトル
        internal readonly static Regex r10 = new Regex(@"^\s+(\d+)\s+(\d+)\s+(\d+)\s+([-.\d]+)\s+([-.\d]+)\s+([-.\d]+)\s*$", RegexOptions.None, CommonParam.ts);//標準配向情報
        internal readonly static Regex r11 = new Regex(@"^\s*Rotational\sconstants\s\(GHZ\):(\s+[\d.]+){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//回転定数情報
        internal readonly static Regex r11a = new Regex(@"^\s+(\d+)\sbasis\sfunctions[,\p{L}\d\s]+$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//基底関数個数情報
        internal readonly static Regex r11b = new Regex(@"^\s*NBasis=\s*(\d+)[-.,=\p{L}\d\s]+$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//基底関数個数情報2
        internal readonly static Regex r12 = new Regex(@"^\s*\*+\s*$", RegexOptions.None, CommonParam.ts);//分割線2
        internal readonly static Regex r13 = new Regex(@"^\s+Population\sanalysis\susing\sthe\sSCF\sDensity\.\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電子密度解析タイトル
        internal readonly static Regex r14 = new Regex(@"^\s*Orbital\ssymmetries:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//軌道対称性タイトル
        internal readonly static Regex r15 = new Regex(@"^\s+(Virtual|Occupied)?\s*(\([\p{L}\d]+\)\s*)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道カウント
        internal readonly static Regex r16 = new Regex(@"^\s*Alpha\s+(occ|virt)\.\s+eigenvalues\s+--(\s+[-.\d]+)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道エネルギー情報
        internal readonly static Regex r17 = new Regex(@"^\s*Molecular\sOrbital\sCoefficients:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道係数タイトル
        internal readonly static Regex r17a = new Regex(@"^(\s+\d+)+\s*$", RegexOptions.None, CommonParam.ts);//分子軌道/原子軌道/縮約行列/Hirshfeld/ESP/正規座標インデクス
        internal readonly static Regex r17b = new Regex(@"^(?:\s+\(?[\p{L}\d]*\)?-*(\p{L}))+\s*$", RegexOptions.None, CommonParam.ts);//分子軌道タイプ情報
        internal readonly static Regex r17c = new Regex(@"^\s*Eigenvalues\s--(\s+[-.\d]+)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道固有値情報
        internal readonly static Regex r18 = new Regex(@"^\s*(\d+)\s(\d+\s+)?(\p{L}+\s)?\s*(\d*\p{L}[-+\d\p{L}]*\s)(\s+[-.\d]+)+\s*$", RegexOptions.None, CommonParam.ts);//分子軌道係数、原子軌道密度、縮約密度、Hirshfeld、軌道エネるギー/運動エネルギー、ESP電荷、原子電位、自然電子密度まとめ
        internal readonly static Regex r19 = new Regex(@"^\s+Density\sMatrix:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//密度行列タイトル
        internal readonly static Regex r20 = new Regex(@"^\s+Full\sMulliken\spopulation\sanalysis:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Mulliken密度解析タイトル
        internal readonly static Regex r21 = new Regex(@"^\s+Gross\sorbital\spopulations:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//総軌道密度タイトル
        internal readonly static Regex r22 = new Regex(@"^\s+Condensed\sto\satoms\s\(all\selectrons\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//縮約密度タイトル
        internal readonly static Regex r23 = new Regex(@"^\s*Mulliken\scharges:$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Mulliken電荷タイトル
        internal readonly static Regex r24 = new Regex(@"^\s+(\d+)\s+(\p{L}+)\s+([-.\d]+)\s*$", RegexOptions.None, CommonParam.ts);//Mulliken/APT電荷&重原子Mulliken/APT電荷情報

        internal GLogReader(in string pth)
        {
            fpth = pth;
            GLogRead();
        }
        private void GLogRead()
        {
            if (!File.Exists(fpth)) throw new FileNotFoundException("File doesn't exists", fpth);
            FileInfo fi = new FileInfo(fpth);
            if (fi.Extension != ".log") throw new FileNotFoundException("File is not a .mol file", fpth);
            fi = null;
            using (FileStream fs = new FileStream(fpth, FileMode.Open, FileAccess.Read, FileShare.None))
            {
                using (StreamReader sr = new StreamReader(fs, Encoding.UTF8, false, -1, false))//Logは全部UTF8?
                {
                    string s = sr.ReadLine();
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Log file is empty.");
                    string emstm = "";//マッチングの為の空文字列
                    Match m = r1.Match(s ?? emstm);//入力座標前の一行を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r1.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find charge/multipliticity information.");
                    s = sr.ReadLine();
                    m = GLogReg.r2.Match(s ?? emstm);//原子座標情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r2.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find input coordinate.");
                    NatAtoms na = new NatAtoms();
                    byte? b;
                    byte bnn;
                    int cnt;
                    short scnt = 0;
                    han = 0;
                    List<byte> bl = new List<byte>();//原子ラベル
                    GroupCollection gc;
                    while (s != null && m.Success)
                    {
                        scnt++;//原子数を数える
                        gc = m.Groups;
                        if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc.Count", string.Format("GLogRead ({0}) : Incorrect initial coordinate format.", scnt));
                        b = na.fthPfL(gc[1].Value);
                        if (b == null) throw new ArgumentNullException("b", string.Format("GLogRead initial coordinate({0}) : Unknown atom lable", scnt));
                        bnn = (byte)b;
                        if (b != 1) han++;//非水素原子(重原子)を数える
                        bl.Add((byte)b);
                        s = sr.ReadLine();
                        m = GLogReg.r2.Match(s ?? emstm);
                    }
                    if (bl.Count != scnt) throw new ArgumentOutOfRangeException("bl/scnt", string.Format("GLogRead initial coordinate({0}) : Atom number can not be verified.", scnt));
                    an = (int)scnt;
                    //Console.WriteLine("SU : an={0}\than={1}", an, han);//debug用
                    als = bl.ToArray();
                    acs = new double[an, 3];
                    soco = new double[an, 3];
                    aobl = new int[an];
                    cdnsm = new double[an, an];
                    mlkc = new double[an];
                    mhsc = new double[han];
                    HCAB = new double[an];
                    HDXYZ = new double[an, 3];
                    Hachg = new double[an];
                    Hacm5chg = new double[an];
                    Hhachg = new double[han];
                    Hhacm5chg = new double[han];
                    ESPc = new double[an];
                    ESPch = new double[han];
                    aep = new double[an];
                    nch = new double[an];
                    npc = new double[an];
                    npv = new double[an];
                    npr = new double[an];
                    npt = new double[an];
                    nec2s = new double[han];
                    nec2p = new double[han];
                    necns = new double[han];
                    necnp = new double[han];
                    gmsi = new double[an];
                    gmsa = new double[an];
                    gmst = new double[an, 3, 3];
                    gmse = new double[an, 3];
                    APTc = new double[an];
                    APThc = new double[han];
                    toco = an * 3;
                    s = sr.ReadLine();
                    m = GLogReg.r3.Match(s ?? emstm);//分割線を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r3.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find separation between input coordinate and initial parameters.");
                    s = sr.ReadLine();
                    m = GLogReg.r4.Match(s ?? emstm);//初期パラメータを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r4.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find initial parameters.");
                    s = sr.ReadLine();
                    m = GLogReg.r5.Match(s ?? emstm);//初期結合長情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r5.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find initial parameters.");
                    scnt = 0;
                    short svf = 0, stemp;//確認用
                    int itemp = 0;
                    List<int> als1 = new List<int>();//原子1
                    List<int> als2 = new List<int>();//原子2
                    while (s != null && m.Success)
                    {
                        scnt++;//結合の数を数える
                        gc = m.Groups;
                        if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect radius initial parameters format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead ({0}) : Can not parse 2A radius to short.", scnt));
                        if (!int.TryParse(gc[2].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse R 1st atom to int.", scnt));
                        itemp--;
                        als1.Add(itemp);
                        if (!int.TryParse(gc[3].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse R 2nd atom to int.", scnt));
                        itemp--;
                        als2.Add(itemp);
                        s = sr.ReadLine();
                        m = GLogReg.r5.Match(s ?? emstm);
                    }
                    //Console.WriteLine("KO : svf={0}\tscnt={1}\r\nals1={2}\tals2={3}", svf, scnt, als1.Count, als2.Count);//debug用
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find angle information of initial parameters.");
                    if (svf != scnt || svf != als1.Count || svf != als2.Count) throw new ArgumentOutOfRangeException("svf/scent/als", "GLogRead : Radius number can not be verified.");
                    rn = scnt;
                    rdl = new int[rn, 2];
                    rdd = new double[rn];
                    itemp = rn;
                    for (cnt = 0; cnt < itemp; cnt++)//結合ラベルを保存する
                    {
                        rdl[cnt, 0] = als1[cnt];
                        rdl[cnt, 1] = als2[cnt];
                    }
                    m = GLogReg.r6.Match(s);//初期結合角情報を探す
                    if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Can not find angle information of initial parameters.");
                    scnt = 0;
                    als1 = new List<int>();
                    als2 = new List<int>();
                    List<int> als3 = new List<int>();
                    while (s != null && m.Success)
                    {
                        scnt++;//結合角の数を数える
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect angle initial parameters format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead ({0}) : Can not parse 3A angle to short.", scnt));
                        if (!int.TryParse(gc[2].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse A 1st atom to int.", scnt));
                        itemp--;
                        als1.Add(itemp);
                        if (!int.TryParse(gc[3].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse A 2nd atom to int.", scnt));
                        itemp--;
                        als2.Add(itemp);
                        if (!int.TryParse(gc[4].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse A 3rd atom to int.", scnt));
                        itemp--;
                        als3.Add(itemp);
                        s = sr.ReadLine();
                        m = GLogReg.r6.Match(s ?? emstm);
                    }
                    //Console.WriteLine("KO : svf={0}\tscnt={1}\r\nals1={2}\tals2={3}\tals3={4}", svf, scnt, als1.Count, als2.Count, als3.Count);//debug用
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dihedral angle information of initial parameters.");
                    if (svf != scnt || svf != als1.Count || svf != als2.Count || svf != als3.Count) throw new ArgumentOutOfRangeException("svf/scnt/als", "GLogRead : Angle number can not be verified.");
                    agn = scnt;
                    agl = new int[agn, 3];
                    agd = new double[agn];
                    itemp = agn;
                    for (cnt = 0; cnt < itemp; cnt++)//結合角ラベルを保存する
                    {
                        agl[cnt, 0] = als1[cnt];
                        agl[cnt, 1] = als2[cnt];
                        agl[cnt, 2] = als3[cnt];
                    }
                    m = GLogReg.r7.Match(s);//初期結合二面角情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r7.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentOutOfRangeException("s", "GLogRead : Can not find dihedral angle information of initial parameters.");
                    scnt = 0;
                    als1 = new List<int>();
                    als2 = new List<int>();
                    als3 = new List<int>();
                    List<int> als4 = new List<int>();
                    while (s != null && m.Success)
                    {
                        scnt++;//結合二面角の数を数える
                        gc = m.Groups;
                        if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect dihedral angle initial parameters format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead ({0}) : Can not parse 4A dihedral angle to short.", scnt));
                        if (!int.TryParse(gc[2].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 1st atom to int.", scnt));
                        itemp--;
                        als1.Add(itemp);
                        if (!int.TryParse(gc[3].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 2nd atom to int.", scnt));
                        itemp--;
                        als2.Add(itemp);
                        if (!int.TryParse(gc[4].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 3rd atom to int.", scnt));
                        itemp--;
                        als3.Add(itemp);
                        if (!int.TryParse(gc[5].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 4th atom to int.", scnt));
                        itemp--;
                        als4.Add(itemp);
                        s = sr.ReadLine();
                        m = GLogReg.r7.Match(s ?? emstm);
                    }
                    //Console.WriteLine("A : svf={0}\tscnt={1}\r\nals1={2}\tals2={3}\tals3={4}\tals4={5}", svf, scnt, als1.Count, als2.Count, als3.Count, als4.Count);//debug用
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find degree of freedom.");
                    if (svf != scnt || svf != als1.Count || svf != als2.Count || svf != als3.Count || svf != als4.Count) throw new ArgumentOutOfRangeException("svf/scnt/als", "GLogRead : Dihedral angle number can not be verified.");
                    dn = scnt;
                    dhl = new int[dn, 4];
                    dhd = new double[dn];
                    itemp = dn;
                    for (cnt = 0; cnt < itemp; cnt++)//結合二面角ラベルを保存する
                    {
                        dhl[cnt, 0] = als1[cnt];
                        dhl[cnt, 1] = als2[cnt];
                        dhl[cnt, 2] = als3[cnt];
                        dhl[cnt, 3] = als4[cnt];
                    }
                    m = GLogReg.r8.Match(s);//自由度情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r8.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find degree of freedom.");
                    //if (!short.TryParse(m.Groups[1].Value, out dof)) throw new ArgumentException("m", "GLogRead : Can not parse dof to short.");//初期データ
                    //Console.WriteLine("E : dof={0}", dof);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r9.Match(s ?? emstm);//標準配向タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r9.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find initial standard orientation title.");
                    m = GLogReg.r10.Match(s);//初期標準配向情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r10.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find standard orientation information.");
                    scnt = 0;
                    svf = 0;
                    stemp = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect standard orientation information format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead standard orientation({0}) : Can not parse center number to short.", scnt));
                        if (!short.TryParse(gc[2].Value, out stemp)) throw new ArgumentException("stemp", string.Format("GLogRead standard orientation({0}) : Can not parse atomic number to short.", scnt));
                        if (scnt > an) throw new ArgumentOutOfRangeException("stemp/als", string.Format("GLogRead standard orientation: Redundant atom detected.", scnt));
                        if (stemp != als[cnt]) throw new ArgumentOutOfRangeException("stemp/als", "GLogRead standard orientation: Atomic number can not be verified.");
                        s = sr.ReadLine();
                        m = GLogReg.r10.Match(s ?? emstm);
                        cnt++;
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find rotational constants.");
                    m = GLogReg.r11.Match(s);//初期回転定数情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r11.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find rotational constants information.");
                    if (m.Groups.Count != 2) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect rotational constants information format.");
                    if (m.Groups[1].Captures.Count != 3) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect rotational constants information format.");
                    rc = new double[3];
                    s = sr.ReadLine();
                    m = GLogReg.r11a.Match(s ?? emstm);//基底関数個数情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r11a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find basis function number information.");
                    if (m.Groups.Count != 2) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect basis function number information format.");
                    if (!short.TryParse(m.Groups[1].Value, out bfn)) throw new ArgumentOutOfRangeException("m", "GLogRead : Can not parse basis function number to short.");
                    //Console.WriteLine("KI : bfn={0}", bfn);//debug用
                    mocm = new double[bfn, bfn];
                    moev = new double[bfn];
                    aol = new string[bfn];
                    dnsm = new double[bfn, bfn];
                    mpam = new double[bfn, bfn];
                    gop = new double[bfn];
                    oke = new double[bfn];
                    naooc = new double[bfn];
                    naoen = new double[bfn];
                    naot = new bool?[bfn];
                    s = sr.ReadLine();
                    m = GLogReg.r11b.Match(s ?? emstm);//基底関数個数情報2を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r11b.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBasis information.");
                    if (m.Groups.Count != 2) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect NBasis information format.");
                    if (!short.TryParse(m.Groups[1].Value, out stemp)) throw new ArgumentOutOfRangeException("m", "GLogRead : Can not parse NBasis to short.");
                    if (stemp != bfn) throw new ArgumentOutOfRangeException("m", "GLogRead : Can not verify basis function number and NBasis.");
                    s = sr.ReadLine();
                    m = GLogReg.r12.Match(s ?? emstm);//分割線2を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r12.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find population analysis information.");
                    m = GLogReg.r13.Match(s ?? "");//電子密度解析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r13.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find population analysis information.");
                    m = GLogReg.r14.Match(s);//軌道対称性タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r14.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital symmetries information.");
                    s = sr.ReadLine();
                    m = GLogReg.r15.Match(s ?? emstm);//軌道対称性情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r15.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital symmetries information.");
                    scnt = 0;
                    stemp = 0;
                    CaptureCollection cc;
                    bool? flg = null;
                    occmo = 0;
                    vrtmo = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect orbital symmetries information format.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;
                        if (flg == null && itemp == 0) throw new ArgumentOutOfRangeException("cc", "GLogRead (orbital symmetries) : Can not obtain orbital type information.");
                        else if (itemp == 1)
                        {
                            if (string.Equals(cc[0].Value, "Occupied", StringComparison.InvariantCultureIgnoreCase)) flg = true;
                            else if (string.Equals(cc[0].Value, "Virtual", StringComparison.InvariantCultureIgnoreCase)) flg = false;
                            else throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (orbital symmetries) : Unknown orbital type.");
                        }
                        else if (itemp < 0 || itemp > 1) throw new ArgumentOutOfRangeException("itemp", "GLogRead (orbital symmetries) : Orbital type capture is out of range.");
                        cc = gc[2].Captures;
                        itemp = cc.Count;
                        if (flg == true)
                        {
                            if (itemp <= 0 || itemp > short.MaxValue) throw new ArgumentOutOfRangeException("itemp", "GLogRead (orbital symmetries) : Occupied orbital count is out of range.");
                            occmo += (short)itemp;
                        }
                        else if (flg == false)
                        {
                            if (itemp <= 0 || itemp > short.MaxValue) throw new ArgumentOutOfRangeException("itemp", "GLogRead (orbital symmetries) : Virtual orbital count is out of range.");
                            vrtmo += (short)itemp;
                        }
                        else throw new ArgumentOutOfRangeException("flg", "GLogRead (orbital symmetries) : Unknown \"if statement\" error.");
                        s = sr.ReadLine();
                        m = GLogReg.r15.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find MO energy information.");
                    if (occmo + vrtmo != bfn) throw new ArgumentOutOfRangeException("occmo/vrtmo/bfn", "GLogRead (orbital symmetries) : Can not verify molecular orbit number.");
                    //Console.WriteLine("KO : occmo={0}\tvrtmo={1}\tbfn={2}", occmo, vrtmo, bfn);//debug用
                    m = GLogReg.r16.Match(s);//初期分子軌道エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r16.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find MO energy information.");
                    cnt = 0;
                    svf = 0;
                    stemp = 0;
                    flg = null;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect MO energy information format.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;
                        if (itemp == 0) throw new ArgumentOutOfRangeException("cc", "GLogRead (MO energy) : Can not obtain orbital type information.");
                        else if (itemp == 1)
                        {
                            if (string.Equals(cc[0].Value, "occ", StringComparison.InvariantCultureIgnoreCase))
                            {
                                if (flg == null)
                                {
                                    flg = true;
                                    moevo = true;
                                }
                                else if (flg == false)
                                {
                                    //Console.WriteLine("E : svf={0}\tvrtmo={1}", svf, vrtmo);//debug用
                                    if (moevo != false) throw new ArgumentOutOfRangeException("moevo", "GLogRead (MO energy) : Can not verify \"virt->occ\" order.");
                                    if (svf != vrtmo) throw new ArgumentOutOfRangeException("svf/vrtmo", "GLogRead (MO energy) : Can not verify virtual orbital number.");
                                    flg = true;
                                }
                            }
                            else if (string.Equals(cc[0].Value, "virt", StringComparison.InvariantCultureIgnoreCase))
                            {
                                if (flg == null)
                                {
                                    flg = false;
                                    moevo = false;
                                }
                                else if (flg == true)
                                {
                                    //Console.WriteLine("SU : svf={0}\toccmo={1}", svf, occmo);//debug用
                                    if (moevo != true) throw new ArgumentOutOfRangeException("moevo", "GLogRead (MO energy) : Can not verify \"occ->virt\" order.");
                                    if (svf != occmo) throw new ArgumentOutOfRangeException("svf/occmo", "GLogRead (MO energy) : Can not verify occupied orbital number.");
                                    flg = false;
                                }
                            }
                            else throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (MO energy) : Unknown orbital type.");
                        }
                        else if (itemp < 0 || itemp > 1) throw new ArgumentOutOfRangeException("itemp", "GLogRead (MO energy) : Orbital type capture is out of range.");
                        else throw new ArgumentOutOfRangeException("itemp", "GLogRead (MO energy) : Unknown \"if statement\" error.");
                        cc = gc[2].Captures;
                        itemp = cc.Count;
                        if (flg == true)
                        {
                            if (itemp <= 0 || itemp > short.MaxValue) throw new ArgumentOutOfRangeException("itemp", "GLogRead (MO energy) : Occupied orbital count is out of range.");
                            svf += (short)itemp;
                            for (scnt = 0; scnt < itemp; scnt++)
                            {
                                //if (double.TryParse(cc[scnt].Value.Trim(), out moev[cnt])) throw new ArgumentOutOfRangeException("m", "GLogRead (MO energy) : Can not parse occupied orbital energy to short.");
                                if (++cnt >= bfn) throw new ArgumentOutOfRangeException("cnt/bfn", "GLogRead (MO energy) : Molecular orbital count is out of range.");
                            }
                        }
                        else if (flg == false)
                        {
                            if (itemp <= 0 || itemp > short.MaxValue) throw new ArgumentOutOfRangeException("itemp", "GLogRead (MO energy) : Virtual orbital count is out of range.");
                            svf += (short)itemp;
                            for (scnt = 0; scnt < itemp; scnt++)
                            {
                                //if (double.TryParse(cc[scnt].Value.Trim(), out moev[cnt])) throw new ArgumentOutOfRangeException("m", "GLogRead (MO energy) : Can not parse virtual orbital energy to short.");
                                if (++cnt > bfn) throw new ArgumentOutOfRangeException("cnt/bfn", "GLogRead (MO energy) : Molecular orbital count is out of range.");
                            }
                        }
                        else throw new ArgumentOutOfRangeException("flg", "GLogRead (MO energy) : Unknown \"if statement\" error.");
                        s = sr.ReadLine();
                        m = GLogReg.r16.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficients information.");
                    if (svf != bfn) throw new ArgumentOutOfRangeException("svf/bfn", "GLogRead (MO energy) : Can not verify molecular orbital number.");
                    //Console.WriteLine("A : svf={0}\tbfn={1}", svf, bfn);//debug用
                    if (moevo)//分子軌道エネルギーインデックスを決める
                    {
                        lmei = occmo;
                        slmei = lmei + 1;
                        s2lmei = lmei + 2;
                        hmei = lmei - 1;
                        shmei = lmei - 2;
                        s2hmei = lmei - 3;
                    }
                    else
                    {
                        hmei = vrtmo;
                        shmei = hmei + 1;
                        s2hmei = hmei + 2;
                        lmei = hmei - 1;
                        slmei = hmei - 2;
                        s2lmei = hmei - 3;
                    }
                    //Console.WriteLine("KI : s2lmei={0}\tslmei={1}\r\nlmei={2}\thmei={3}\tshmei={4}\ts2hmei={5}\t", s2lmei, slmei, lmei, hmei, shmei, s2hmei);//debug用
                    /*
                    lme = moev[lmei];
                    slme = moev[slmei];
                    s2lme = moev[s2lmei];
                    hme = moev[hmei];
                    shme = moev[shmei];
                    s2hme = moev[s2hmei];
                    */
                    //Console.WriteLine("KI : s2lme={0}\tslme={1}\r\nlme={2}\thme={3}\tshme={4}\ts2hme={5}\t", s2lme, slme, lme, hme, shme, s2hme);//debug用
                    m = GLogReg.r17.Match(s);//分子軌道係数タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    m = GLogReg.r17a.Match(s);//分子軌道係数インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    int cnt2 = 0;//列インデックス
                    int itemp2, cnt3, cnt4, ivf = 0, itemp3;
                    List<int> indl;//列インデックス一時リスト
                    flg = false;
                    while (s != null && m.Success)
                    {
                        cnt3 = 0;//行インデックス
                        cnt4 = 0;//原子インデックス
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (molecular orbital coefficient) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        indl = new List<int>();
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (molecular orbital coefficient) : Can not verify colomn index.");
                        }
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (type).");
                        m = GLogReg.r17b.Match(s);//分子軌道タイプ情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is incorrect (type).");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (molecular orbital coefficient) : Molecular orbital type format is incorrect.");
                        cc = gc[1].Captures;
                        if (itemp != cc.Count) throw new ArgumentOutOfRangeException("itemp/cc", "GLogRead (molecular orbital coefficient) : Can not verify colomn number (type).");
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            switch (cc[cnt].Value)
                            {
                                case "V":
                                    {
                                        if (moevo ? indl[cnt] < occmo : indl[cnt] >= vrtmo) throw new ArgumentOutOfRangeException(string.Format("indl[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Can not verify orbital type.");
                                        break;
                                    }
                                case "O":
                                    {
                                        if (moevo ? indl[cnt] >= occmo : indl[cnt] < vrtmo) throw new ArgumentOutOfRangeException(string.Format("indl[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Can not verify orbital type.");
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Unknown orbital type.");
                            }
                        }
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (eigenvalue).");
                        m = GLogReg.r17c.Match(s);//初期分子軌道固有値情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is incorrect (eigenvalue).");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (molecular orbital coefficient) : Molecular orbital eigenvalue format is incorrect.");
                        cc = gc[1].Captures;
                        if (itemp != cc.Count) throw new ArgumentOutOfRangeException("itemp/cc", "GLogRead (molecular orbital coefficient) : Can not verify colomn number (eigenvalue).");
                        /*
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", string.Format("GLogRead (molecular orbital coefficient) ({0}) : Can not parse eigenvalue to double.", cnt));
                            if (moev[indl[cnt]] != dtemp) throw new ArgumentOutOfRangeException(string.Format("dtemp/moev{0}", cnt), "GLogRead (molecular orbital coefficient) : Can not verify molecular orbital energy.");
                        }
                        //*///初期データ
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);//初期分子軌道係数情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is incorrect (matrix).");
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Molecular orbital coefficient format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Molecular orbital coefficient format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (molecular orbital coefficient) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (molecular orbital coefficient) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (molecular orbital coefficient) : Can not parse matrix atom number to int.");
                                if (itemp3 != cnt4 + 1) throw new ArgumentOutOfRangeException("itemp3/cnt4", "GLogRead (molecular orbital coefficient) : Can not verify atom number (matrix).");
                                if (flg == false) aobl[cnt4] = cnt3;
                                else if (flg == true)
                                {
                                    if (aobl[cnt4] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (molecular orbital coefficient) : Can not verify atomic orbital borderline (matrix).");
                                }
                                else throw new ArgumentNullException("flg", "GLogRead (molecular orbital coefficient-matrix) : Unknown flag error.");
                            }
                            else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (molecular orbital coefficient) : Atom number format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (molecular orbital coefficient) : Atom number format is incorrect (matrix).");
                            else if (cc.Count == 1)
                            {
                                if (!cc[0].Value.Trim().Equals(na.fthLfP(als[cnt4]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (molecular orbital coefficient) : Can not verify atom lable (matrix).");
                                cnt4++;
                            }
                            else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (molecular orbital coefficient) : Atom lable format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Molecular orbital coefficient format is incorrect.");
                            if (flg == false) aol[cnt3] = cc[0].Value.Trim();
                            else if (flg == true)
                            {
                                if (!aol[cnt3].Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (molecular orbital coefficient) : Can not verify atomic orbital lable (matrix).");
                            }
                            else throw new ArgumentNullException("flg", "GLogRead (molecular orbital coefficient-matrix) : Unknown flag error.");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (cnt != itemp) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (molecular orbital coefficient-matrix) : Can not verify colomn number.");
                            /*
                            for (cnt = 0; cnt < itemp; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out mocm[cnt3, indl[cnt]])) throw new ArgumentOutOfRangeException(string.Format("cc{cnt}", cnt), "GLogRead (molecular orbital coefficient-matrix) : Can not parse coefficient to double.");
                            }
                            //*///初期データ
                            /*
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                Console.Write("KO : {0} {1} {2}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim());
                                for (cnt = 0; cnt < itemp; cnt++) Console.Write("I : {0}", mocm[cnt3, indl[cnt]]);
                                Console.WriteLine();

                            }//*///debug用
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (matrix).");
                            m = GLogReg.r18.Match(s);
                            cnt3++;
                            if (!m.Success && flg == false)
                            {
                                /*
                                for(cnt=0;cnt<an;cnt++)
                                {
                                    Console.WriteLine("SU : {0,-4} {1,-3} {2}", cnt + 1, na.fthLfP(als[cnt]), aobl[cnt]);//debug用
                                }
                                //*/
                                flg = true;
                            }
                        }
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find density matrix.");
                    //Console.WriteLine("SU : aobl[0]={0}\taobl[1]={1}\taobl[2]={2}", aobl[0], aobl[1], aobl[2]);//debug用
                    m = GLogReg.r19.Match(s);//密度行列タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r19.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    m = GLogReg.r17a.Match(s);//密度行列の列インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    cnt2 = 0;//列インデックス
                    cnt4 = 0;//行短縮数
                    double dtemp;
                    itemp3 = 0;
                    while (s != null && m.Success)
                    {
                        cnt3 = cnt4;  //行インデックス
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (density matrix) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        cnt4 += itemp;
                        indl = new List<int>();//列インデックス一時リスト
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (density matrix) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (density matrix) : Can not verify colomn index.");
                        }
                        //Console.WriteLine("KI : cnt3={0} indl[0]={1}", cnt3, indl[0]);//debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Density matrix information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);//初期密度行列情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Density matrix information is incorrect (matrix).");
                        itemp2 = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Density matrix format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Density matrix format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (density matrix) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (density matrix) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (density matrix) : Can not parse matrix atom number to int.");
                                itemp3--;
                                if (aobl[itemp3] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (density matrix) : Can not verify atomic orbital borderline (matrix).");
                            }
                            else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (density matrix) : Atom number format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (density matrix) : Atom number format is incorrect (matrix).");
                            else if (cc.Count == 1)
                            {
                                if (!cc[0].Value.Trim().Equals(na.fthLfP(als[itemp3]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (density matrix) : Can not verify atom lable (matrix).");
                            }
                            else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (density matrix) : Atom lable format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Density matrix format is incorrect.");
                            if (aol[cnt3] != cc[0].Value.Trim()) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (density matrix) : Can not verify atomic orbital lable (matrix).");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (itemp2 < itemp) itemp2 += 1;
                            if (cnt != itemp2) throw new ArgumentOutOfRangeException("itemp2/gc[5]", "GLogRead (density matrix-matrix) : Can not verify colomn number.");
                            /*
                            for (cnt = 0; cnt < itemp2; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc{cnt}", cnt), "GLogRead (density matrix-matrix) : Can not parse coefficient to double.");
                                dnsm[cnt3, indl[cnt]] = dtemp;
                                if (cnt3 != indl[cnt]) dnsm[indl[cnt], cnt3] = dtemp;
                            }
                            //*///初期データ
                            /*
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                Console.Write("E : {0} {1} {2}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim());
                                for (cnt = 0; cnt < itemp2; cnt++) Console.Write("A: {0}", dnsm[cnt3, indl[cnt]]);
                                Console.WriteLine();
                            }
                            //*///debug用
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Density matrix information is insufficient (matrix).");
                            m = GLogReg.r18.Match(s);
                            cnt3++;
                        }
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full Mulliken population analysis title.");
                    m = GLogReg.r20.Match(s);//Mulliken密度解析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r20.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full Mulliken population analysis matrix.");
                    m = GLogReg.r17a.Match(s);//Mulliken密度解析行列の列インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead (full Mulliken population analysis matrix): Can not find colomn index.");
                    cnt2 = 0;//列インデックス
                    cnt4 = 0;//行短縮数
                    itemp3 = 0;
                    while (s != null && m.Success)
                    {
                        cnt3 = cnt4;  //行インデックス
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (full Mulliken population analysis matrix) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        cnt4 += itemp;
                        indl = new List<int>();//列インデックス一時リスト
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (full Mulliken population analysis) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (full Mulliken population analysis) : Can not verify colomn index.");
                        }
                        //Console.WriteLine("E : cnt3={0} indl[0]={1}", cnt3, indl[0]);//debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Full Mulliken population analysis information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);//初期密度行列情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Full Mulliken population analysis information is incorrect (matrix).");
                        itemp2 = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Full Mulliken population analysis format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Full Mulliken population analysis format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (full Mulliken population analysis) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (full Mulliken population analysis) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (full Mulliken population analysis) : Can not parse matrix atom number to int.");
                                itemp3--;
                                if (aobl[itemp3] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (full Mulliken population analysis) : Can not verify atomic orbital borderline (matrix).");
                            }
                            else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (full Mulliken population analysis) : Atom number format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (full Mulliken population analysis) : Atom number format is incorrect (matrix).");
                            else if (cc.Count == 1)
                            {
                                if (!cc[0].Value.Trim().Equals(na.fthLfP(als[itemp3]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (full Mulliken population analysis) : Can not verify atom lable (matrix).");
                            }
                            else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (full Mulliken population analysis) : Atom lable format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Full Mulliken population analysis format is incorrect.");
                            if (!aol[cnt3].Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (full Mulliken population analysis) : Can not verify atomic orbital lable (matrix).");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (itemp2 < itemp) itemp2 += 1;
                            if (cnt != itemp2) throw new ArgumentOutOfRangeException("itemp2/gc[5]", "GLogRead (full Mulliken population analysis-matrix) : Can not verify colomn number.");
                            /*
                            for (cnt = 0; cnt < itemp2; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc{cnt}", cnt), "GLogRead (full Mulliken population analysis-matrix) : Can not parse coefficient to double.");
                                mpam[cnt3, indl[cnt]] = dtemp;
                                if (cnt3 != indl[cnt]) mpam[indl[cnt], cnt3] = dtemp;
                            }
                            //*///初期データ
                            /*
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                Console.Write("A : {0} {1} {2}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim());
                                for (cnt = 0; cnt < itemp2; cnt++) Console.Write("I : {0}", mpam[cnt3, indl[cnt]]);
                                Console.WriteLine();
                            }//*///debug用
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Full Mulliken population analysis information is insufficient (matrix).");
                            m = GLogReg.r18.Match(s);
                            cnt3++;
                        }
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population title.");
                    m = GLogReg.r21.Match(s);//総軌道密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r21.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s);//総軌道密度の列の番号を探す
                    if (!m.Success) throw new ArgumentOutOfRangeException("s", "GLogRead (gross orbital population) : Can not find colomn index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (gross orbital population) : Colomn index format is incorrect.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (gross orbital population) : Colomn index format is incorrect.");
                    if (!short.TryParse(cc[0].Value, out svf)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (gross orbital population) : Can not parse colomn index to short.");
                    if (svf != 1) throw new ArgumentOutOfRangeException("svf", "GLogRead (gross orbital population) : Colomn index format is incorrect.");
                    s = sr.ReadLine();
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population information.");
                    m = GLogReg.r18.Match(s);
                    if (!m.Success) throw new ArgumentOutOfRangeException("s", "GLogRead (gross orbital population) : Can not find matrix information.");
                    cnt3 = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Gross orbital population format is incorrect.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Gross orbital population format is incorrect.");
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (gross orbital population) : Can not parse matrix row number to int.");
                        if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (gross orbital population) : Can not verify row number (matrix).");
                        cc = gc[2].Captures;
                        cnt = cc.Count;
                        if (cnt == 1)
                        {
                            if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (gross orbital population) : Can not parse matrix atom number to int.");
                            itemp3--;
                            if (aobl[itemp3] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (gross orbital population) : Can not verify atomic orbital borderline (matrix).");
                        }
                        else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (gross orbital population) : Atom number format is incorrect (matrix).");
                        cc = gc[3].Captures;
                        if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (gross orbital population) : Atom number format is incorrect (matrix).");
                        else if (cc.Count == 1)
                        {
                            if (!cc[0].Value.Trim().Equals(na.fthLfP(als[itemp3]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (gross orbital population) : Can not verify atom lable (matrix).");
                        }
                        else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (gross orbital population) : Atom lable format is incorrect (matrix).");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Gross orbital population format is incorrect.");
                        if (aol[cnt3] != cc[0].Value.Trim()) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (gross orbital population : Can not verify atomic orbital lable (matrix).");
                        cc = gc[5].Captures;
                        cnt = cc.Count;
                        if (cnt != 1) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (gross orbital population-matrix) : Can not verify colomn number.");
                        //if (!double.TryParse(cc[0].Value.Trim(), out gop[cnt3])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (gross orbital population-matrix) : Can not parse coefficient to double.");//初期データ
                        /*
                        cc = gc[2].Captures;
                        cnt = cc.Count;
                        if (cnt == 1) Console.WriteLine("KI : {0} {1} {2} {3}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim(), gop[cnt3]);
                        //*///debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Gross orbital population information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);
                        cnt3++;
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find condensed population title.");
                    m = GLogReg.r22.Match(s);//縮約密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r22.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find condensed population title.");
                    /*
                    m = r17a.Match(s);//縮約密度行列の列インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead (condensed population matrix): Can not find colomn index.");
                    cnt2 = 0;//列インデックス
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (condensed population matrix) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        indl = new List<int>();//列インデックス一時リスト
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (condensed population) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (condensed population) : Can not verify colomn index.");
                        }
                        //Console.WriteLine("A : cnt3={0} indl[0]={1}", cnt3, indl[0]);//debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Condensed population information is insufficient (matrix).");
                        m = r18.Match(s);//縮約密度行列情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Condensed population information is incorrect (matrix).");
                        cnt3 = 0;  //行インデックス
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Condensed population format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-atom number) : Condensed population format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (condensed population) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (condensed population) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Condensed population format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Condensed population format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-atom lable) : Condensed population format is incorrect.");
                            if (!na.fthLfP(als[cnt3]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (condensed population) : Can not verify atom lable (matrix).");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (cnt != itemp) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (condensed population-matrix) : Can not verify colomn number.");
                            for (cnt = 0; cnt < itemp; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc{cnt}", cnt), "GLogRead (condensed population-matrix) : Can not parse coefficient to double.");
                                cdnsm[cnt3, indl[cnt]] = dtemp;
                                //if (cnt3 == indl[cnt]) Console.Write("SU : {0} {1} {2}", cnt3 + 1, gc[4].Captures[0].Value.Trim(), cdnsm[cnt3, indl[cnt]]);//debug用
                            }
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Condensed population information is insufficient (matrix).");
                            m = r18.Match(s);
                            cnt3++;
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population title.");
                    *///不完全
                    s = sr.ReadLine();
                    m = GLogReg.r23.Match(s ?? emstm);//Mulliken電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r23.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Mulliken charge title.");
                    s = sr.ReadLine();
                    s = sr.ReadLine();
                    m = GLogReg.r24.Match(s ?? emstm);//初期Mulliken電荷情報を探す
                    scnt = 0;
                    svf = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect Mulliken charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", string.Format("GLogRead ({0}) : Incorrect Mulliken charge information format.", scnt));
                        if (!short.TryParse(cc[0].Value, out svf)) throw new ArgumentOutOfRangeException("svf", string.Format("GLogRead Mulliken charge({0}) : Can not parse atom number to short.", scnt));
                        if (svf != scnt) throw new ArgumentOutOfRangeException("svf/scent", "GLogRead (Mulliken charge): Can not verify atom number.");
                        b = na.fthPfL(gc[2].Value);
                        if (b == null) throw new ArgumentNullException("b", string.Format("GLogRead (Mulliken charge({0})) : Unknown atom lable", scnt));
                        if (cnt > an) throw new ArgumentOutOfRangeException("cnt", string.Format("GLogRead (Mulliken charge({0})) : Redundant atom is detected.", scnt));
                        if (b != als[cnt]) throw new ArgumentOutOfRangeException("b/als", string.Format("GLogRead (Mulliken charge({0})) : Can not verify atomic number.", scnt));
                        //if(!double.TryParse(gc[3].Value,out mlkc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (Mulliken charge({0})) : Can not parse Mulliken charge to double.", scnt));//初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);
                        cnt++;
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom Mulliken charges.");
                    //Console.WriteLine("I : svf={0}", svf);//debug用
                    if (svf != an) throw new ArgumentOutOfRangeException("svf/an", "GLogRead Mulliken charges : Atom number can not be verified.");
                    m = GLogReg.r26.Match(s);//重原子Mulliken電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r26.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom Mulliken charge information.");
                    s = sr.ReadLine();
                    m = GLogReg.r24.Match(s ?? emstm);//初期重原子Mulliken電荷情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom Mulliken charge information.");
                    scnt = 0;
                    svf = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect heavy atom Mulliken charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", string.Format("GLogRead ({0}) : Incorrect heavy atom Mulliken charge information format.", scnt));
                        if (!short.TryParse(cc[0].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead heavy atom Mulliken({0}) : Can not parse atom number to short.", scnt));
                        if (svf != scnt) throw new ArgumentOutOfRangeException("svf/scent", "GLogRead (heavy atom Mulliken charge): Can not verify atom number.");
                        b = na.fthPfL(gc[2].Value);
                        if (b == null) throw new ArgumentNullException("b", string.Format("GLogRead heavy atom Mulliken({0}) : Unknown atom lable", scnt));
                        if (scnt > han) throw new ArgumentOutOfRangeException("cnt", string.Format("GLogRead heavy atom Mulliken({0}) : Redundant atom is detected.", scnt));
                        //if (!double.TryParse(gc[3].Value, out mhsc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (heavy atom Mulliken charge({0})) : Can not parse heavy atom Mulliken charge to double.", scnt));//初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);
                        cnt++;
                    }
                    //Console.WriteLine("SU : svf={0}\tscnt={1}\than={2}", svf, scnt, han);//debug用
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electronic spatial extent information.");
                    if (svf != han) throw new ArgumentOutOfRangeException("svf/han", "GLogRead heavy atom Mulliken charges : Heavy atom number can not be verified.");
                    m = GLogReg.r27.Match(s);//ESE情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r27.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electronic spatial extent information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect electronic spatial extent information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc.Count", "GLogRead : Incorrect electronic spatial extent information format.");
                    //if (!double.TryParse(cc[0].Value.Trim(), out ese)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (electronic spatial extent) : Can not parse electronic spatial extent to double.");//初期データ
                    s = sr.ReadLine();
                    m = GLogReg.r28.Match(s ?? emstm);//双極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r28.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole moment title.");
                    s = sr.ReadLine();
                    m = GLogReg.r29.Match(s ?? emstm);//初期双極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole moment information.");
                    dipmm = new double[3];//双極子モーメントベクトル
                    qdpmt = new double[3, 3];//四極子モーメント行列
                    tlqmt = new double[3, 3];//トレスレス四極子モーメント行列
                    ocpmt = new double[3, 3, 3];//八極子モーメントテンソル
                    hdpmt = new double[3, 3, 3, 3];//十六極子モーメント4テンソル
                    CaptureCollection cc2;
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect dipole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect dipole moment information format.");
                        /*
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "X":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipmm[0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse dipole moment X to double.");
                                        break;
                                    }
                                case "Y":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipmm[1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse dipole moment Y to double.");
                                        break;
                                    }
                                case "Z":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipmm[2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse dipole moment Z to double.");
                                        break;
                                    }
                                case "TOT":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipm)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse total dipole moment to double.");
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown dipole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        //*///初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find quadrupole moment title.");
                    //Console.WriteLine("KI : cnt3(行数)={0}\tcnt2(マッチ数)={1}", cnt3, cnt2);//debug用
                    m = GLogReg.r30.Match(s);//四極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r30.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find quadrupole moment title.");
                    s = sr.ReadLine();
                    m = GLogReg.r29.Match(s ?? emstm);//初期四極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find quadrupole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect quadrupole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect quadrupole moment information format.");
                        /*
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out qdpmt[0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment XX to double.");
                                        break;
                                    }
                                case "YY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out qdpmt[1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment YY to double.");
                                        break;
                                    }
                                case "ZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out qdpmt[2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment ZZ to double.");
                                        break;
                                    }
                                case "XY":
                                case "YX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment XY to double.");
                                        qdpmt[0, 1] = dtemp;
                                        qdpmt[1, 0] = dtemp;
                                        break;
                                    }
                                case "XZ":
                                case "ZX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment XZ to double.");
                                        qdpmt[0, 2] = dtemp;
                                        qdpmt[2, 0] = dtemp;
                                        break;
                                    }
                                case "YZ":
                                case "ZY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment YZ to double.");
                                        qdpmt[1, 2] = dtemp;
                                        qdpmt[2, 1] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown quadrupole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        //*///初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find traceless quadrupole moment title.");
                    //Console.WriteLine("SU : cnt3(行数)={0}\tcnt2(マッチ数)={1}", cnt3, cnt2);//debug用
                    m = GLogReg.r31.Match(s);//跡無し四極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r31.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find traceless quadrupole moment title.");
                    s = sr.ReadLine();
                    m = GLogReg.r29.Match(s ?? emstm);//初期跡無し四極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find traceless quadrupole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect traceless quadrupole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect traceless quadrupole moment information format.");
                        /*
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out tlqmt[0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment XX to double.");
                                        break;
                                    }
                                case "YY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out tlqmt[1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment YY to double.");
                                        break;
                                    }
                                case "ZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out tlqmt[2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment ZZ to double.");
                                        break;
                                    }
                                case "XY":
                                case "YX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment XY to double.");
                                        tlqmt[0, 1] = dtemp;
                                        tlqmt[1, 0] = dtemp;
                                        break;
                                    }
                                case "XZ":
                                case "ZX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment XZ to double.");
                                        tlqmt[0, 2] = dtemp;
                                        tlqmt[2, 0] = dtemp;
                                        break;
                                    }
                                case "YZ":
                                case "ZY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment YZ to double.");
                                        tlqmt[1, 2] = dtemp;
                                        tlqmt[2, 1] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown traceless quadrupole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        //*///初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find octapole moment title.");
                    //Console.WriteLine("KI : cnt3(行数)={0}\tcnt2(マッチ数)={1}", cnt3, cnt2);//debug用
                    m = GLogReg.r32.Match(s);//八極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r32.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find octapole moment title.");
                    m = GLogReg.r29.Match(s);//初期八極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find octapole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect octapole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect octapole moment information format.");
                        /*
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out ocpmt[0, 0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XXX to double.");
                                        break;
                                    }
                                case "YYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out ocpmt[1, 1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment YYY to double.");
                                        break;
                                    }
                                case "ZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out ocpmt[2, 2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment ZZZ to double.");
                                        break;
                                    }
                                case "XYY":
                                case "YXY":
                                case "YYX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XYY to double.");
                                        ocpmt[0, 1, 1] = dtemp;
                                        ocpmt[1, 0, 1] = dtemp;
                                        ocpmt[1, 1, 0] = dtemp;
                                        break;
                                    }
                                case "XXY":
                                case "XYX":
                                case "YXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XXY to double.");
                                        ocpmt[0, 0, 1] = dtemp;
                                        ocpmt[0, 1, 0] = dtemp;
                                        ocpmt[1, 0, 0] = dtemp;
                                        break;
                                    }
                                case "XXZ":
                                case "XZX":
                                case "ZXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XXZ to double.");
                                        ocpmt[0, 0, 2] = dtemp;
                                        ocpmt[0, 2, 0] = dtemp;
                                        ocpmt[2, 0, 0] = dtemp;
                                        break;
                                    }
                                case "XZZ":
                                case "ZXZ":
                                case "ZZX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XZZ to double.");
                                        ocpmt[0, 2, 2] = dtemp;
                                        ocpmt[2, 0, 2] = dtemp;
                                        ocpmt[2, 2, 0] = dtemp;
                                        break;
                                    }
                                case "YZZ":
                                case "ZYZ":
                                case "ZZY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment YZZ to double.");
                                        ocpmt[1, 2, 2] = dtemp;
                                        ocpmt[2, 1, 2] = dtemp;
                                        ocpmt[2, 2, 1] = dtemp;
                                        break;
                                    }
                                case "YYZ":
                                case "YZY":
                                case "ZYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment YYZ to double.");
                                        ocpmt[1, 1, 2] = dtemp;
                                        ocpmt[1, 2, 1] = dtemp;
                                        ocpmt[2, 1, 1] = dtemp;
                                        break;
                                    }
                                case "XYZ":
                                case "XZY":
                                case "YXZ":
                                case "YZX":
                                case "ZXY":
                                case "ZYX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XYZ to double.");
                                        ocpmt[0, 1, 2] = dtemp;
                                        ocpmt[0, 2, 1] = dtemp;
                                        ocpmt[1, 0, 2] = dtemp;
                                        ocpmt[1, 2, 0] = dtemp;
                                        ocpmt[2, 0, 1] = dtemp;
                                        ocpmt[2, 1, 0] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown octapole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        //*///初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find hexadecapole moment information.");
                    //Console.WriteLine("A : cnt3(行数)={0}\tcnt2(マッチ数)={1}", cnt3, cnt2);//debug用
                    m = GLogReg.r33.Match(s);//十六極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r33.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find hexadecapole moment title.");
                    m = GLogReg.r29.Match(s);//初期十六極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find hexadecapole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect hexadecapole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect hexadecapole moment information format.");
                        /*
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XXXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out hdpmt[0, 0, 0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXXX to double.");
                                        break;
                                    }
                                case "YYYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out hdpmt[1, 1, 1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYYY to double.");
                                        break;
                                    }
                                case "ZZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out hdpmt[2, 2, 2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZZZ to double.");
                                        break;
                                    }
                                case "XXXY":
                                case "XXYX":
                                case "XYXX":
                                case "YXXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXXY to double.");
                                        hdpmt[0, 0, 0, 1] = dtemp;
                                        hdpmt[0, 0, 1, 0] = dtemp;
                                        hdpmt[0, 1, 0, 0] = dtemp;
                                        hdpmt[1, 0, 0, 0] = dtemp;
                                        break;
                                    }
                                case "XXXZ":
                                case "XXZX":
                                case "XZXX":
                                case "ZXXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXXZ to double.");
                                        hdpmt[0, 0, 0, 2] = dtemp;
                                        hdpmt[0, 0, 2, 0] = dtemp;
                                        hdpmt[0, 2, 0, 0] = dtemp;
                                        hdpmt[2, 0, 0, 0] = dtemp;
                                        break;
                                    }
                                case "YYYX":
                                case "YYXY":
                                case "YXYY":
                                case "XYYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYYX to double.");
                                        hdpmt[1, 1, 1, 0] = dtemp;
                                        hdpmt[1, 1, 0, 1] = dtemp;
                                        hdpmt[1, 0, 1, 1] = dtemp;
                                        hdpmt[0, 1, 1, 1] = dtemp;
                                        break;
                                    }
                                case "YYYZ":
                                case "YYZY":
                                case "YZYY":
                                case "ZYYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYYZ to double.");
                                        hdpmt[1, 1, 1, 2] = dtemp;
                                        hdpmt[1, 1, 2, 1] = dtemp;
                                        hdpmt[1, 2, 1, 1] = dtemp;
                                        hdpmt[2, 1, 1, 1] = dtemp;
                                        break;
                                    }
                                case "ZZZX":
                                case "ZZXZ":
                                case "ZXZZ":
                                case "XZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZZX to double.");
                                        hdpmt[2, 2, 2, 0] = dtemp;
                                        hdpmt[2, 2, 0, 2] = dtemp;
                                        hdpmt[2, 0, 2, 2] = dtemp;
                                        hdpmt[0, 2, 2, 2] = dtemp;
                                        break;
                                    }
                                case "ZZZY":
                                case "ZZYZ":
                                case "ZYZZ":
                                case "YZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZZY to double.");
                                        hdpmt[2, 2, 2, 1] = dtemp;
                                        hdpmt[2, 2, 1, 2] = dtemp;
                                        hdpmt[2, 1, 2, 2] = dtemp;
                                        hdpmt[1, 2, 2, 2] = dtemp;
                                        break;
                                    }
                                case "XXYY":
                                case "XYXY":
                                case "XYYX":
                                case "YYXX":
                                case "YXYX":
                                case "YXXY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXYY to double.");
                                        hdpmt[0, 0, 1, 1] = dtemp;
                                        hdpmt[0, 1, 0, 1] = dtemp;
                                        hdpmt[0, 1, 1, 0] = dtemp;
                                        hdpmt[1, 1, 0, 0] = dtemp;
                                        hdpmt[1, 0, 1, 0] = dtemp;
                                        hdpmt[1, 0, 0, 1] = dtemp;
                                        break;
                                    }
                                case "XXZZ":
                                case "XZXZ":
                                case "XZZX":
                                case "ZZXX":
                                case "ZXZX":
                                case "ZXXZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXZZ to double.");
                                        hdpmt[0, 0, 2, 2] = dtemp;
                                        hdpmt[0, 2, 0, 2] = dtemp;
                                        hdpmt[0, 2, 2, 0] = dtemp;
                                        hdpmt[2, 2, 0, 0] = dtemp;
                                        hdpmt[2, 0, 2, 0] = dtemp;
                                        hdpmt[2, 0, 0, 2] = dtemp;
                                        break;
                                    }
                                case "YYZZ":
                                case "YZYZ":
                                case "YZZY":
                                case "ZZYY":
                                case "ZYZY":
                                case "ZYYZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYZZ to double.");
                                        hdpmt[1, 1, 2, 2] = dtemp;
                                        hdpmt[1, 2, 1, 2] = dtemp;
                                        hdpmt[1, 2, 2, 1] = dtemp;
                                        hdpmt[2, 2, 1, 1] = dtemp;
                                        hdpmt[2, 1, 2, 1] = dtemp;
                                        hdpmt[2, 1, 1, 2] = dtemp;
                                        break;
                                    }
                                case "XXYZ":
                                case "XXZY":
                                case "XYXZ":
                                case "XYZX":
                                case "XZXY":
                                case "XZYX":
                                case "YXXZ":
                                case "YXZX":
                                case "YZXX":
                                case "ZXXY":
                                case "ZXYX":
                                case "ZYXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXYZ to double.");
                                        hdpmt[0, 0, 1, 2] = dtemp;
                                        hdpmt[0, 0, 2, 1] = dtemp;
                                        hdpmt[0, 1, 0, 2] = dtemp;
                                        hdpmt[0, 1, 2, 0] = dtemp;
                                        hdpmt[0, 2, 0, 1] = dtemp;
                                        hdpmt[0, 2, 1, 0] = dtemp;
                                        hdpmt[1, 0, 0, 2] = dtemp;
                                        hdpmt[1, 0, 2, 0] = dtemp;
                                        hdpmt[1, 2, 0, 0] = dtemp;
                                        hdpmt[2, 0, 0, 1] = dtemp;
                                        hdpmt[2, 0, 1, 0] = dtemp;
                                        hdpmt[2, 1, 0, 0] = dtemp;
                                        break;
                                    }
                                case "YYXZ":
                                case "YYZX":
                                case "YXYZ":
                                case "YXZY":
                                case "YZXY":
                                case "YZYX":
                                case "XYYZ":
                                case "XYZY":
                                case "XZYY":
                                case "ZYYX":
                                case "ZYXY":
                                case "ZXYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYXZ to double.");
                                        hdpmt[1, 1, 0, 2] = dtemp;
                                        hdpmt[1, 1, 2, 0] = dtemp;
                                        hdpmt[1, 0, 1, 2] = dtemp;
                                        hdpmt[1, 0, 2, 1] = dtemp;
                                        hdpmt[1, 2, 0, 1] = dtemp;
                                        hdpmt[1, 2, 1, 0] = dtemp;
                                        hdpmt[0, 1, 1, 2] = dtemp;
                                        hdpmt[0, 1, 2, 1] = dtemp;
                                        hdpmt[0, 2, 1, 1] = dtemp;
                                        hdpmt[2, 1, 1, 0] = dtemp;
                                        hdpmt[2, 1, 0, 1] = dtemp;
                                        hdpmt[2, 0, 1, 1] = dtemp;
                                        break;
                                    }
                                case "ZZXY":
                                case "ZZYX":
                                case "ZXZY":
                                case "ZXYZ":
                                case "ZYXZ":
                                case "ZYZX":
                                case "XZZY":
                                case "XZYZ":
                                case "XYZZ":
                                case "YZZX":
                                case "YZXZ":
                                case "YXZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZXY to double.");
                                        hdpmt[2, 2, 0, 1] = dtemp;
                                        hdpmt[2, 2, 1, 0] = dtemp;
                                        hdpmt[2, 0, 2, 1] = dtemp;
                                        hdpmt[2, 0, 1, 2] = dtemp;
                                        hdpmt[2, 1, 0, 2] = dtemp;
                                        hdpmt[2, 1, 2, 0] = dtemp;
                                        hdpmt[0, 2, 2, 1] = dtemp;
                                        hdpmt[0, 2, 1, 2] = dtemp;
                                        hdpmt[0, 1, 2, 2] = dtemp;
                                        hdpmt[1, 2, 2, 0] = dtemp;
                                        hdpmt[1, 2, 0, 2] = dtemp;
                                        hdpmt[1, 0, 2, 2] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown hexadecapole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        //*///初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find repulsion/attraction/kinetic energy information.");
                    //Console.WriteLine("KO : cnt3(行数)={0}\tcnt2(マッチ数)={1}", cnt, cnt2);//debug用
                    m = GLogReg.r34.Match(s);//初期反発/吸引/運動エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r34.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find repulsion/attraction/kinetic energy information.");
                    gc = m.Groups;
                    if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect repulsion/attraction/kinetic energy information format.");
                    if (gc[1].Captures.Count != 1 || gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]/gc[2]", "GLogRead : Incorrect repulsion energy information format.");
                    if (gc[3].Captures.Count != 1 || gc[4].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]/gc[2]", "GLogRead : Incorrect attraction energy information format.");
                    if (gc[5].Captures.Count != 1 || gc[6].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]/gc[2]", "GLogRead : Incorrect kinetic energy information format.");
                    StringBuilder sb = new StringBuilder();
                    /*
                    sb.Append(gc[1].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[2].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out nnrepe)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse repulsion energy to double.");
                    sb.Clear();
                    sb.Append(gc[3].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[4].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out enatre)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse attraction energy to double.");
                    sb.Clear();
                    sb.Append(gc[5].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[6].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out keknte)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse kinetic energy to double.");
                    //Console.WriteLine("E : nnrepe={0}\tenatre={1}\tkeknte={2}", nnrepe, enatre, keknte);//debug用
                    //*///初期データ
                    s = sr.ReadLine();
                    m = GLogReg.r35.Match(s ?? emstm);//初期EISum情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r35.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find EISum information.");
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect EISum information format.");
                        cc = gc[1].Captures;
                        if (cc.Count == 1)
                        {
                            cc = gc[2].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect atomic densities EISum information format.");
                            if (!double.TryParse(cc[0].Value, out eisad)) throw new ArgumentOutOfRangeException("cc", "GLogRead : Can not parse atomic densities EISum to double.");
                        }
                        else if (cc.Count == 0)
                        {
                            cc = gc[2].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect density EISum information format.");
                            if (!double.TryParse(cc[0].Value, out eisd)) throw new ArgumentOutOfRangeException("cc", "GLogRead : Can not parse density EISum to double.");
                        }
                        else throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect EISum information format.");
                        s = sr.ReadLine();
                        m = GLogReg.r35.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld populations title.");
                    //Console.WriteLine("KO : eisad={0}\teisd={1}", eisad, eisd);//debug用
                    m = GLogReg.r36.Match(s);//Hirshfeld電荷密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r36.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld populations title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//Hirshfeld電荷密度インデックスを探す
                    if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld populations index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld populations index format.");
                    cc = gc[1].Captures;
                    itemp = cc.Count;
                    cnt = 0;
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//初期Hirshfeld電荷密度情報を探す
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentNullException("gc", "GLogRead : Incorrect Hirshfeld populations format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentNullException("gc[1]", "GLogRead (Hirshfeld populations): Incorrect atom index format.");
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld populations) : Can not parse atom index to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (Hirshfeld populations) : Can not verify atom index.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentNullException("gc[2]/gc[3]", "GLogRead : Incorrect Hirshfeld populations format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentNullException("gc[4]", "GLogRead (Hirshfeld populations): Incorrect atom index format.");
                        if (!na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (Hirshfeld populations) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != itemp) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (Hirshfeld populations) : Can not verify colomn number.");
                        /*
                        if (itemp == 5)
                        {
                            if (!double.TryParse(cc[0].Value.Trim(), out HCAB[cnt])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld populations) : Can not parse CA to double.");
                            if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld populations) : Can not parse CB to double.");
                            if (Math.Abs(HCAB[cnt] - dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("HCAB[{0}]/dtemp", cnt), "GLogRead (Hirshfeld populations) : Can not verify CA & CB.");
                            if (!double.TryParse(cc[2].Value.Trim(), out HDXYZ[cnt, 0])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld populations) : Can not parse DipX to double.");
                            if (!double.TryParse(cc[3].Value.Trim(), out HDXYZ[cnt, 1])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (Hirshfeld populations) : Can not parse DipY to double.");
                            if (!double.TryParse(cc[4].Value.Trim(), out HDXYZ[cnt, 2])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (Hirshfeld populations) : Can not parse DipZ to double.");
                        }
                        else if (itemp == 6)
                        {
                            if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld populations) : Can not parse CX to double.");
                            if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("dtemp", cnt), "GLogRead (Hirshfeld populations) : CX is not 0.");
                            if (!double.TryParse(cc[1].Value.Trim(), out HCAB[cnt])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld populations) : Can not parse CA to double.");
                            if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld populations) : Can not parse CB to double.");
                            if (Math.Abs(HCAB[cnt] - dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("HCAB[{0}]/dtemp", cnt), "GLogRead (Hirshfeld populations) : Can not verify CA & CB.");
                            if (!double.TryParse(cc[3].Value.Trim(), out HDXYZ[cnt, 0])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (Hirshfeld populations) : Can not parse DipX to double.");
                            if (!double.TryParse(cc[4].Value.Trim(), out HDXYZ[cnt, 1])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (Hirshfeld populations) : Can not parse DipY to double.");
                            if (!double.TryParse(cc[5].Value.Trim(), out HDXYZ[cnt, 2])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (Hirshfeld populations) : Can not parse DipZ to double.");
                        }
                        else throw new ArgumentOutOfRangeException("ivf", "GLogRead : Unknown Hirshfeld populations format (colomn number).");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld populations information.");
                    //Console.WriteLine("SU : itemp={0}\tivf={1}", itemp, ivf);//debug用
                    HDXYZt = new double[3];
                    m = GLogReg.r37.Match(s ?? emstm);//初期total Hirshfeld populations を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r37.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld populations information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentNullException("gc", "GLogRead : Incorrect total Hirshfeld populations format.");
                    cc = gc[1].Captures;
                    if (cc.Count != itemp) throw new ArgumentOutOfRangeException("itemp/gc[1]", "GLogRead (total Hirshfeld populations) : Can not verify colomn number.");
                    /*
                    if (itemp == 5)
                    {
                        if (!double.TryParse(cc[0].Value.Trim(), out HCABt)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (total Hirshfeld populations) : Can not parse CA to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (total Hirshfeld populations) : Can not parse CB to double.");
                        if (Math.Abs(HCABt - dtemp) > 0.00001) throw new ArgumentOutOfRangeException("HCABt/dtemp", "GLogRead (total Hirshfeld populations) : Can not verify CA & CB.");
                        if (!double.TryParse(cc[2].Value.Trim(), out HDXYZt[0])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (total Hirshfeld populations) : Can not parse DipX to double.");
                        if (!double.TryParse(cc[3].Value.Trim(), out HDXYZt[1])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (total Hirshfeld populations) : Can not parse DipY to double.");
                        if (!double.TryParse(cc[4].Value.Trim(), out HDXYZt[2])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (total Hirshfeld populations) : Can not parse DipZ to double.");
                    }
                    else if (itemp == 6)
                    {
                        if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (total Hirshfeld populations) : Can not parse CX to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("dtemp", cnt), "GLogRead (total Hirshfeld populations) : CX is not 0.");
                        if (!double.TryParse(cc[1].Value.Trim(), out HCABt)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (total Hirshfeld populations) : Can not parse CA to double.");
                        if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (total Hirshfeld populations) : Can not parse CB to double.");
                        if (Math.Abs(HCABt - dtemp) > 0.00001) throw new ArgumentOutOfRangeException("HCABt/dtemp", "GLogRead (total Hirshfeld populations) : Can not verify CA & CB.");
                        if (!double.TryParse(cc[3].Value.Trim(), out HDXYZt[0])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (total Hirshfeld populations) : Can not parse DipX to double.");
                        if (!double.TryParse(cc[4].Value.Trim(), out HDXYZt[1])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (total Hirshfeld populations) : Can not parse DipY to double.");
                        if (!double.TryParse(cc[5].Value.Trim(), out HDXYZt[2])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (total Hirshfeld populations) : Can not parse DipZ to double.");
                    }
                    else throw new ArgumentOutOfRangeException("itemp", "GLogRead : Unknown Hirshfeld populations format (colomn number).");
                    //*///初期データ
                    //Console.WriteLine("A : HCABt={0}\tHDipx={1}\r\nHDipy={2}\tHDipz={3}", HCABt, HDXYZt[0], HDXYZt[1], HDXYZt[2]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r38.Match(s ?? emstm);//初期Hirshfeld双極子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r38.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld Dip from chg information.");
                    HDipc = new double[3];
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentNullException("gc", "GLogRead : Incorrect Hirshfeld Dip from chg format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld Dip from chg) : Can not verify Dip number.");
                    /*
                    if (!double.TryParse(cc[0].Value.Trim(), out HDipc[0])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld Dip from chg) : Can not parse DipX to double.");
                    if (!double.TryParse(cc[1].Value.Trim(), out HDipc[1])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld Dip from chg) : Can not parse DipY to double.");
                    if (!double.TryParse(cc[2].Value.Trim(), out HDipc[2])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld Dip from chg) : Can not parse DipZ to double.");
                    //*///初期データ
                    s = sr.ReadLine();
                    m = GLogReg.r39.Match(s ?? emstm);//初期total Hirshfeld双極子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r39.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld Dip information.");
                    HDipt = new double[3];
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentNullException("gc", "GLogRead : Incorrect total Hirshfeld Dip format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (total Hirshfeld Dip) : Can not verify Dip number.");
                    /*
                    if (!double.TryParse(cc[0].Value.Trim(), out HDipt[0])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (total Hirshfeld Dip) : Can not parse DipX to double.");
                    if (!double.TryParse(cc[1].Value.Trim(), out HDipt[1])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (total Hirshfeld Dip) : Can not parse DipY to double.");
                    if (!double.TryParse(cc[2].Value.Trim(), out HDipt[2])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (total Hirshfeld Dip) : Can not parse DipZ to double.");
                    //*///初期データ
                    //Console.WriteLine("KI : HDipcx={0}\tHDipcy={1}\tHDipcz={2}\r\nHDiptx[0]={3}\tHDipty[1]={4}\tHDiptz[2]={5}", HDipc[0], HDipc[1], HDipc[2], HDipt[0], HDipt[1], HDipt[2]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r40.Match(s ?? emstm);//Hirshfeld原子情報タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r40.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld atom information.");
                    s = sr.ReadLine();
                    m = GLogReg.r41.Match(s ?? emstm);//Hirshfeld原子情報インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r41.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld atom index.");
                    gc = m.Groups;
                    if (gc.Count != 7 || gc[1].Captures.Count != 1 || gc[2].Captures.Count != 1 || gc[3].Captures.Count != 1 || gc[4].Captures.Count != 1 || gc[5].Captures.Count != 1 || gc[6].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld atom information format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//初期Hirshfeld原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld atom information.");
                    cnt = 0;
                    ivf = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld atom information format.");
                        cc = gc[1].Captures;
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld atom information) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (Hirshfeld atom information) : can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect Hirshfeld atom information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Incorrect Hirshfeld atom information format.");
                        if (!na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (Hirshfeld atom information) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != 6) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect Hirshfeld atom information format.");
                        /*
                        if (!double.TryParse(cc[0].Value.Trim(), out Hachg[cnt])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld atom information) : Can not parse Q-H to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld atom information) : Can not parse S-H to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("dtemp", "GLogRead (Hirshfeld atom information) : S-H is not 0.");
                        if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld atom information) : Can not parse Dx to double.");
                        if (dtemp != HDXYZ[cnt, 0]) throw new ArgumentOutOfRangeException("dtemp/HDXYZ", "GLogRead (Hirshfeld atom information) : Can not verify Dipx.");
                        if (!double.TryParse(cc[3].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (Hirshfeld atom information) : Can not parse Dy to double.");
                        if (dtemp != HDXYZ[cnt, 1]) throw new ArgumentOutOfRangeException("dtemp/HDXYZ", "GLogRead (Hirshfeld atom information) : Can not verify Dipy.");
                        if (!double.TryParse(cc[4].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (Hirshfeld atom information) : Can not parse Dz to double.");
                        if (dtemp != HDXYZ[cnt, 2]) throw new ArgumentOutOfRangeException("dtemp/HDXYZ", "GLogRead (Hirshfeld atom information) : Can not verify Dipz.");
                        if (!double.TryParse(cc[5].Value.Trim(), out Hacm5chg[cnt])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (Hirshfeld atom information) : Can not parse Q-CM5 to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld atom information.");
                    if (ivf != an) throw new ArgumentOutOfRangeException("ivf/an", "Can not verify atom number.");
                    m = GLogReg.r37.Match(s);//初期total Hirshfeld原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r37.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld atom information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect total Hirshfeld atom information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 6) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect total Hirshfeld atom information format.");
                    /*
                    if (!double.TryParse(cc[0].Value.Trim(), out Hchgt)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead : Can not parse total Hirshfeld charge to double.");
                    if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead : Can not parse total Hirshfeld spin density to double.");
                    if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead : total Hirshfeld spin density is not 0.");
                    if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead : Can not parse total Hirshfeld Dx to double.");
                    if (dtemp != HDXYZt[0]) throw new ArgumentOutOfRangeException("dtemp/HDXYZt", "GLogRead : Can not verify total Hirshfeld Dx.");
                    if (!double.TryParse(cc[3].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead : Can not parse total Hirshfeld Dy to double.");
                    if (dtemp != HDXYZt[1]) throw new ArgumentOutOfRangeException("dtemp/HDXYZt", "GLogRead : Can not verify total Hirshfeld Dy.");
                    if (!double.TryParse(cc[4].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead : Can not parse total Hirshfeld Dz to double.");
                    if (dtemp != HDXYZt[2]) throw new ArgumentOutOfRangeException("dtemp/HDXYZt", "GLogRead : Can not verify total Hirshfeld Dz.");
                    if (!double.TryParse(cc[5].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead : Can not parse total Hirshfeld CM5 charge to double.");
                    if (Hchgt != dtemp) throw new ArgumentOutOfRangeException("Hchgt/dtemp", "GLogRead : Can not verify total Hirshfeld charge.");
                    //*///初期データ
                    s = sr.ReadLine();
                    //Console.WriteLine("KO : Hchgt={0}\tHDXYZtx={1}\r\nHDXYZty={2}\tHDXYZtz={3}", Hchgt, HDXYZt[0], HDXYZt[1], HDXYZt[2]);//debug用
                    m = GLogReg.r42.Match(s ?? emstm);//初期total Hirshfeld重原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r42.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld heavy atom information.");
                    s = sr.ReadLine();
                    m = GLogReg.r41.Match(s ?? emstm);//total Hirshfeld重原子情報インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r41.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld heavy atom information.");
                    gc = m.Groups;
                    if (gc.Count != 7 || gc[1].Captures.Count != 1 || gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0 || gc[4].Captures.Count != 0 || gc[5].Captures.Count != 0 || gc[6].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//初期Hirshfeld重原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld heavy atom information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        cc = gc[1].Captures;
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld heavy atom information) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (Hirshfeld heavy atom information) : can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        if (!na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (Hirshfeld heavy atom information) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        /*
                        if (!double.TryParse(cc[0].Value.Trim(), out Hhachg[cnt])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld heavy atom information) : Can not parse Q-H to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out Hhacm5chg[cnt])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (Hirshfeld heavy atom information) : Can not parse Q-CM5 to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld atom information.");
                    if (ivf != han) throw new ArgumentOutOfRangeException("ivf/an", "Can not verify heavy atom number.");
                    m = GLogReg.r43.Match(s);//初期EQQ/EQD/EDD情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r43.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find EQQ/EQD/EDD information.");
                    gc = m.Groups;
                    if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect EQQ/EQD/EDD information format.");
                    /*
                    cc = gc[1].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (EQQ/EQD/EDD) : Can not parse EQQ to double.");
                    if (Math.Abs(dtemp) > 0.0000000001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (EQQ/EQD/EDD) : EQQ is not 0.");
                    cc = gc[2].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (EQQ/EQD/EDD) : Can not parse EQD to double.");
                    if (Math.Abs(dtemp) > 0.0000000001) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (EQQ/EQD/EDD) : EQD is not 0.");
                    cc = gc[3].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out EDD)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (EQQ/EQD/EDD) : Can not parse EDD to double.");
                    //*///初期データ
                    //Console.WriteLine("E : dtemp={0}\tEDD={1}", dtemp, EDD);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r44.Match(s ?? emstm);//EQQ+QD+DD情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r44.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find EQQ+QD+DD information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect EQQ+QD+DD information format.");
                    /*
                    cc = gc[1].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (EQQ+QD+DD) : Can not parse EQQ+QD+DD to double.");
                    if (Math.Abs(EDD - dtemp) > 0.0000000001) throw new ArgumentOutOfRangeException("EDD/dtemp", "GLogRead (EQQ+QD+DD) : Can not verify EDD.");
                    //*///初期データ
                    //Console.WriteLine("SU : dtemp={0}", dtemp);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r45.Match(s ?? emstm);//軌道エネルギーと運動エネルギータイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r45.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//軌道エネルギーと運動エネルギー情報インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    if (m.Groups.Count != 2 || m.Groups[1].Captures.Count != 2) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect orbital energy & kinetic energy information.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//初期軌道エネルギーと運動エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect orbital energy & kinetic energy information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (orbital energy & kinetic energy) : Can not parse orbital number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (orbital energy & kinetic energy) : Can not verify orbital number.");
                        if (ivf > bfn) throw new ArgumentOutOfRangeException("ivf/bfn", "GLogRead (orbital energy & kinetic energy) : Redundant orbital detected.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect orbital energy & kinetic energy information format.");
                        cc = gc[4].Captures;
                        s = cc[0].Value.Trim();
                        if (moevo)
                        {
                            if (s != (cnt < occmo ? "O" : "V")) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (orbital energy & kinetic energy) : Can not verify orbital type.");
                        }
                        else
                        {
                            if (s != (cnt < vrtmo ? "V" : "O")) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (orbital energy & kinetic energy) : Can not verify orbital type.");
                        }
                        /*
                        cc = gc[5].Captures;
                        if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect orbital energy & kinetic energy information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (orbital energy & kinetic energy) : Can not parse energy to double.");
                        if (dtemp != moev[cnt]) throw new ArgumentOutOfRangeException("dtemp/moev", "GLogRead (orbital energy & kinetic energy) : Can not verify energy.");
                        if (!double.TryParse(cc[1].Value.Trim(), out oke[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (orbital energy & kinetic energy) : Can not parse kinetic energy to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total kinetic energy information.");
                    if (ivf != bfn) throw new ArgumentOutOfRangeException("ivf/bfn", "GLogRead (orbital energy & kinetic energy): Can not verify orbital number.");
                    m = GLogReg.r46.Match(s);//初期総軌道エネルギーと運動エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r46.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    gc = m.Groups;
                    if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect total orbital kinetic energy information format.");
                    /*
                    sb.Clear();
                    sb.Append(gc[1].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[2].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out toke)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse total orbital kinetic energy to double.");
                    //*///初期データ
                    //Console.WriteLine("E : toke={0}", toke);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r12.Match(s ?? emstm);//ESP(Merz-Kollman)分割線を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r12.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP information.");
                    s = sr.ReadLine();
                    m = GLogReg.r47.Match(s ?? emstm);//ESP(Merz-Kollman)タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r47.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP title.");
                    s = sr.ReadLine();
                    m = GLogReg.r48.Match(s ?? emstm);//ESP電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r48.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//ESP電荷インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP charge index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect ESP charge index format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect ESP charge index format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//初期ESP電荷情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP charge information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect ESP charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (ESP charge) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (ESP charge) : Can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect ESP charge information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1 || !cc[0].Value.Trim().Equals(na.fthLfP(als[cnt]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]/als", "GLogRead (ESP charge) : Can not verify atom lable.");
                        /*
                        cc = gc[5].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect ESP charge information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out ESPc[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse ESP charge to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge title.");
                    if (ivf != an) throw new ArgumentOutOfRangeException("ivf/an", "GLogRead (ESP charge) : Can not verify atom number.");
                    //Console.WriteLine("I : ESPc[0]={0}", ESPc[0]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r49.Match(s ?? emstm);//ESP重原子電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r49.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//ESP重原子電荷インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect heavy atom ESP charge index format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect heavy atom ESP charge index format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//初期ESP重原子電荷情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect heavy atom ESP charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (heavy atom ESP charge) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (heavy atom ESP charge) : Can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect heavy atom ESP charge information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1 || !cc[0].Value.Trim().Equals(na.fthLfP(als[cnt]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]/als", "GLogRead (heavy atom ESP charge) : Can not verify atom lable.");
                        /*
                        cc = gc[5].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect heavy atom ESP charge information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out ESPch[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse heavy atom ESP charge to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP total charge & dipole information.");
                    if (ivf != han) throw new ArgumentOutOfRangeException("ivf/han", "GLogRead (heavy atom ESP charge) : Can not verify heavy atom number.");
                    //Console.WriteLine("A : ESPch[0]={0}", ESPch[0]);//debug用
                    m = GLogReg.r50.Match(s ?? emstm);//初期ESP総電荷＆双極子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r50.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP total charge & dipole information.");
                    gc = m.Groups;
                    if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect ESP total charge & dipole information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse ESP total charge to double.");
                    if (Math.Abs(dtemp) > 0.0001) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : ESP total charge is not 0.");
                    ESPdip = new double[3];
                    /*
                    cc = gc[2].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdip[0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse ESP dipole X to double.");
                    cc = gc[3].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdip[1])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Can not parse ESP dipole Y to double.");
                    cc = gc[4].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdip[2])) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Can not parse ESP dipole Z to double.");
                    cc = gc[5].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdipt)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse ESP dipole to double.");
                    //*///初期データ
                    //Console.WriteLine("KI : dtemp={0}\tESPdipx={1}\r\nESPdipy{2}\tESPdipz{3}\tESPdipt{4}", dtemp, ESPdip[0], ESPdip[1], ESPdip[2], ESPdipt);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r51.Match(s ?? emstm);//原子電位タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r51.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric potential title.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//初期原子電位情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric potential information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect electric potential information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (electric potential) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (electric potential) : Can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect electric potential information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1 || !cc[0].Value.Trim().Equals("Atom", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Incorrect electric potential information format.");
                        /*
                        cc = gc[5].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect electric potential information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out aep[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse electric potential to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO information.");
                    if (ivf != an) throw new ArgumentOutOfRangeException("ivf/an", "GLogRead (electric potential) : Can not verify atom number.");
                    //Console.WriteLine("A : aep[0]={0}", aep[0]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r52.Match(s ?? emstm);//NBOタイトル1を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r52.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO title1.");
                    s = sr.ReadLine();
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO title2.");
                    m = GLogReg.r53.Match(s);
                    if (!m.Success) throw new ArgumentNullException("m", "GLogRead : Can not find NBO title2.");
                    s = sr.ReadLine();
                    m = GLogReg.r54.Match(s ?? emstm);//NAOタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r54.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NAO title.");
                    s = sr.ReadLine();
                    m = GLogReg.r55.Match(s ?? emstm);//NAOインデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r55.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NAO index.");
                    s = sr.ReadLine();
                    m = GLogReg.r56.Match(s ?? emstm);//初期NAO情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r56.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NAO information.");
                    cnt = 0;
                    cnt2 = 0;
                    itemp2 = 1;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 8) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NAO information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse NAO number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead : Can not verify NAO number.");
                        cc = gc[2].Captures;
                        cc2 = gc[3].Captures;
                        if (cc2.Count != 1 || !int.TryParse(cc2[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (NAO) : Can not parse atom number to int.");
                        if (itemp2 != itemp)
                        {
                            cnt2++;
                            if (aobl[cnt2] != cnt) throw new ArgumentOutOfRangeException("aobl/cnt", "GLogRead (NAO) : Can not verify atom orbital boundary.");
                        }
                        if (cc.Count != 1 || !na.fthLfP(als[cnt2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (NAO) : Can not verify atom lable.");
                        itemp2 = itemp;
                        if (cnt >= (itemp == an ? bfn : aobl[itemp]) || cnt < aobl[cnt2]) throw new ArgumentOutOfRangeException("aobl/cnt", "GLogRead (NAO) : Can not verify NAO number.");
                        if (gc[4].Captures.Count != 1 || gc[5].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[4]/gc[5]", "GLogRead : Incorrect NAO information format.");
                        cc = gc[6].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead : Incorrect NAO information format.");
                        switch (cc[0].Value.ToUpperInvariant())
                        {
                            case "COR":
                                {
                                    naot[cnt] = true;
                                    break;
                                }
                            case "VAL":
                                {
                                    naot[cnt] = false;
                                    break;
                                }
                            case "RYD":
                                {
                                    naot[cnt] = null;
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[6]", "GLogRead (NAO) : Unknown NAO type.");
                        }
                        cc = gc[7].Captures;
                        if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead : Incorrect NAO information format.");
                        /*
                        if (!double.TryParse(cc[0].Value.Trim(), out naooc[cnt])) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead (NAO) : Can not parse occupancy to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out naoen[cnt])) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead (NAO) : Can not parse energy to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        if (s.Trim() == emstm) s = sr.ReadLine();
                        m = GLogReg.r56.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis title.");
                    //Console.WriteLine("SU : naooc[0]={0}\tnaoen[0]={1}", naooc[0], naoen[0]);//debug用
                    m = GLogReg.r57.Match(s);//自然電子密度まとめタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r57.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis title.");
                    s = sr.ReadLine();
                    m = GLogReg.r58.Match(s ?? emstm);//自然電子密度まとめインデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r58.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis index.");
                    s = sr.ReadLine();
                    m = GLogReg.r59.Match(s ?? emstm);//初期自然電子密度まとめ情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r59.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect summary of natural population analysis information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[1]/als", "GLogRead (summary of natural population analysis) : Can not verify atom lable.");
                        cc = gc[2].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (summary of natural population analysis) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[2]/cnt", "GLogRead (summary of natural population analysis) : Can not verify atom number.");
                        cc = gc[3].Captures;
                        if (cc.Count != 5) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Incorrect summary of natural population analysis information format.");
                        /*
                        if (!double.TryParse(cc[0].Value.Trim(), out nch[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural charge to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out npc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural population of core to double.");
                        if (!double.TryParse(cc[2].Value.Trim(), out npv[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural population of valence to double.");
                        if (!double.TryParse(cc[3].Value.Trim(), out npr[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural population of Rydberg to double.");
                        if (!double.TryParse(cc[4].Value.Trim(), out npt[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse total natural population to double.");
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r59.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total natural population analysis information.");
                    if (ivf != an) throw new ArgumentOutOfRangeException("ivf/an", "GLogRead (summary of natural population analysis) : Can not verify atom number.");
                    //Console.WriteLine("KI : nch[0]={0}\tnpc[0]={1}\r\nnpv[0]={2}\tnpr[0]={3}\tnpt[0]={4}", nch[0], npc[0], npv[0], npr[0], npt[0]);//debug用
                    m = GLogReg.r60.Match(s);//総自然電子密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r60.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total natural population analysis title.");
                    s = sr.ReadLine();
                    m = GLogReg.r61.Match(s ?? emstm);//初期総自然電子密度情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r61.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total natural population analysis information.");
                    npcr = 0;
                    npvr = 0;
                    nmbr = 0;
                    nrbr = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect total natural population analysis information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect total natural population analysis information format.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (total natural population analysis) : Can not parse natural population to double.");
                        if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (total natural population analysis) : Can not parse natural population ratio to double.");
                        if (gc[4].Captures.Count != 1 || !(int.TryParse(gc[4].Captures[0].Value, out itemp) || gc[4].Captures[0].Value.Equals("***", StringComparison.InvariantCultureIgnoreCase))) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (total natural population analysis) : Can not parse electron summation to int.");
                        /*
                        dtemp /= 100;
                        switch (cc[0].Value.Trim().ToUpperInvariant())
                        {
                            case "CORE":
                                {
                                    npcr = dtemp;
                                    break;
                                }
                            case "VALENCE":
                                {
                                    npvr = dtemp;
                                    break;
                                }
                            case "NATURAL MINIMAL BASIS":
                                {
                                    nmbr = dtemp;
                                    break;
                                }
                            case "NATURAL RYDBERG BASIS":
                                {
                                    nrbr = dtemp;
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (total natural population analysis) : Unknown information.");
                        }
                        //*///初期データ
                        s = sr.ReadLine();
                        m = GLogReg.r61.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find natural electron configuration information.");
                    //if (npcr == 0 || npvr == 0 || nmbr == 0 || nrbr == 0) throw new ArgumentOutOfRangeException("npcr/npvr/nmbr/nrbr", "GLogRead (total natural population analysis) : Incorrect ratio.");
                    //Console.WriteLine("KO : npcr={0}\tnpvr={1}\r\nnpbr={2}\tnrbr={3}", npcr, npvr, nmbr, nrbr);//debug用
                    m = GLogReg.r62.Match(s ?? emstm);//自然電子配置タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r62.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find natural electron configuration title.");
                    s = sr.ReadLine();
                    m = GLogReg.r63.Match(s ?? emstm);//初期自然電子配置情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r63.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find natural electron configuration information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect natural electron configuration information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !na.fthLfP(als[cnt]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (natural electron configuration information) : Can not verify atom lable.");
                        cc = gc[2].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (natural electron configuration information) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (natural electron configuration information) : Can not verify atom number.");
                        cc = gc[3].Captures;
                        cc2 = gc[4].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect natural electron configuration information format.");
                        /*
                        if (cc[0].Value.Equals("2S", StringComparison.InvariantCultureIgnoreCase))
                        {
                            if (!double.TryParse(cc2[0].Value, out nec2s[cnt])) throw new ArgumentOutOfRangeException("cc2", "GLogRead (natural electron configuration information) : Can not parse 2S electron to double.");
                        }
                        else nec2s[cnt] = 0;
                        if (cc[1].Value.Equals("2p", StringComparison.InvariantCultureIgnoreCase))
                        {
                            if (!double.TryParse(cc2[1].Value, out nec2p[cnt])) throw new ArgumentOutOfRangeException("cc2", "GLogRead (natural electron configuration information) : Can not parse 2p electron to double.");
                        }
                        else nec2p[cnt] = 0;
                        //*///初期データ
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r63.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis information.");
                    if (ivf != han) throw new ArgumentOutOfRangeException("ivf/han", "GLogRead (natural electron configuration information) : Can not verify atom number.");
                    //Console.WriteLine("I : nec2s[0]={0}\tnec2p[0]={1}", nec2s[0], nec2p[0]);//debug用
                    m = GLogReg.r64.Match(s ?? emstm);//自然結合軌道分析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r64.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis title.");
                    s = sr.ReadLine();
                    m = GLogReg.r61.Match(s ?? emstm);//初期（非）ルイス電子情報を探す
                    Match m2 = GLogReg.r65.Match(s ?? emstm);//自然結合テーブルタイトルを探す
                    nbvl = 0;
                    nbtl = 0;
                    nbvnl = 0;
                    nbrnl = 0;
                    nbtnl = 0;
                    while (s != null && !m2.Success)
                    {
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect (non-)Lewis electron information format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect (non-)Lewis electron information format.");
                            if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead ((non-)Lewis electron) : Can not parse electron to double.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead ((non-)Lewis electron) : Can not parse electron ratio to double.");
                            if (gc[4].Captures.Count != 1 || !(int.TryParse(gc[4].Captures[0].Value, out itemp) || gc[4].Captures[0].Value.Equals("***", StringComparison.InvariantCultureIgnoreCase))) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead ((non-)Lewis electron) : Can not parse electron summation to int.");
                            /*
                            dtemp /= 100;
                            switch (cc[0].Value.Trim().ToUpperInvariant())
                            {
                                case "CORE":
                                    {
                                        break;
                                    }
                                case "VALENCE LEWIS":
                                    {
                                        nbvl = dtemp;
                                        break;
                                    }
                                case "TOTAL LEWIS":
                                    {
                                        nbtl = dtemp;
                                        break;
                                    }
                                case "VALENCE NON-LEWIS":
                                    {
                                        nbvnl = dtemp;
                                        break;
                                    }
                                case "RYDBERG NON-LEWIS":
                                    {
                                        nbrnl = dtemp;
                                        break;
                                    }
                                case "TOTAL NON-LEWIS":
                                    {
                                        nbtnl = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException("gc[3]", "GLogRead ((non-)Lewis electron) : Unknown information.");
                            }
                            //*///初期データ
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r61.Match(s ?? emstm);
                        m2 = GLogReg.r65.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis table.");
                    //if (nbvl == 0 || nbtl == 0 || nbvnl == 0 || nbrnl == 0 || nbtnl == 0) throw new ArgumentOutOfRangeException("npcr/npvr/nmbr/nrbr", "GLogRead ((non-)Lewis electron) : Incorrect ratio.");
                    //Console.WriteLine("A : nbvl={0}\tnbtl={1}\r\nnbvnl={2}\tnbrnl={3}\tnbtnl={4}", nbvl, nbtl, nbvnl, nbrnl, nbtnl);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r66.Match(s ?? emstm);//初期自然結合軌道テーブル情報1を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r66.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis title.");
                    m2 = GLogReg.r68.Match(s);//NHO方向＆結合曲がりタイトルを探す
                    cnt = 0;//一中心NBOカウンター
                    cnt2 = 0;//二中心NBOカウンター
                    scnt = 0;//NBOインデックス
                    byte btemp;//NBO数え
                    List<short> nboi1l = new List<short>();//一中心NBOインデックス一時リスト
                    List<short> nboi2l = new List<short>();//二中心NBOインデックス一時リスト
                    /*
                    List<double> nboo1l = new List<double>();//一中心NBO占有数一時リスト
                    List<double> nboo2l = new List<double>();//二中心NBO占有数一時リスト
                    //*///初期データ
                    List<string> nbot1l = new List<string>();//一中心NBOタイプ一時リスト
                    List<string> nbot2l = new List<string>();//二中心NBOタイプ一時リスト
                    List<byte> nbok1l = new List<byte>();//一中心NBO数え一時リスト
                    List<byte> nbok2l = new List<byte>();//二中心NBO数え一時リスト
                    List<int> nbon1l = new List<int>();//一中心NBO原子インデックス一時リスト
                    List<int> nbon21l = new List<int>();//二中心NBO原子インデックス1一時リスト
                    List<int> nbon22l = new List<int>();//二中心NBO原子インデックス2一時リスト
                    /*
                    List<double> nbos1l = new List<double>();//一中心NBOs軌道混合率一時リスト
                    List<double> nbop1l = new List<double>();//一中心NBOp軌道混合率一時リスト
                    List<double> nbod1l = new List<double>();//一中心NBOd軌道混合率一時リスト
                    List<double> nbos21l = new List<double>();//二中心NBOs軌道混合率1一時リスト
                    List<double> nbos22l = new List<double>();//二中心NBOs軌道混合率2一時リスト
                    List<double> nbop21l = new List<double>();//二中心NBOp軌道混合率1一時リスト
                    List<double> nbop22l = new List<double>();//二中心NBOp軌道混合率2一時リスト
                    List<double> nbod21l = new List<double>();//二中心NBOd軌道混合率1一時リスト
                    List<double> nbod22l = new List<double>();//二中心NBOd軌道混合率2一時リスト
                    List<double> nbor21l = new List<double>();//二中心NBO原子混合率1一時リスト
                    List<double> nbor22l = new List<double>();//二中心NBO原子混合率2一時リスト
                    //*///初期データ
                    while (s != null && !m2.Success)
                    {
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 12) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NBO table format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1 || !short.TryParse(cc[0].Value, out stemp)) throw new ArgumentNullException("gc[1]", "GLogRead (NBO table) : Can not parse NBO index to short.");
                            if (stemp != scnt + 1) throw new ArgumentOutOfRangeException("stemp/scnt", string.Format("GLogRead (NBO table)({0}/{1}) : Can not verify NBO index.", stemp, scnt));
                            if (gc[7].Captures.Count == 1 && gc[8].Captures.Count == 1 && gc[9].Captures.Count == 0 && gc[10].Captures.Count == 0 && gc[11].Captures.Count == 0)//二中心
                            {
                                nboi2l.Add(stemp);
                                if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse occupancy to double.", stemp));
                                //nboo2l.Add(dtemp);//*///初期データ
                                if (gc[3].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (NBO table)([{0}]) : Incorrect NBO type format.", stemp));
                                nbot2l.Add(gc[3].Captures[0].Value);
                                if (gc[4].Captures.Count != 1 || !byte.TryParse(gc[4].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse kazoe to byte.", stemp));
                                nbok2l.Add(btemp);
                                if (gc[5].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead ([{0}]) : Incorrect NBO atom lable format.", stemp));
                                if (gc[6].Captures.Count != 1 || !int.TryParse(gc[6].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                itemp--;
                                if (!na.fthLfP(als[itemp]).Equals(gc[5].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                nbon21l.Add(itemp);
                                if (!int.TryParse(gc[8].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[8]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                itemp--;
                                if (!na.fthLfP(als[itemp]).Equals(gc[7].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[7]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                nbon22l.Add(itemp);
                                cnt3 = 0;
                                while (s != null && cnt3 < 2)
                                {
                                    s = sr.ReadLine();
                                    m2 = GLogReg.r67.Match(s ?? emstm);//初期自然結合軌道テーブル情報2を探す
                                    if (m2.Success)
                                    {
                                        cnt3++;
                                        gc = m2.Groups;
                                        if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NBO table format.");
                                        if (gc[1].Captures.Count != 1 || !double.TryParse(gc[1].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom ratio to double.", stemp));
                                        if (gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead ([{0}]) : Incorrect NBO atom lable format.", stemp));
                                        if (gc[3].Captures.Count != 1 || !int.TryParse(gc[3].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                        itemp--;
                                        dtemp /= 100;
                                        if (na.fthLfP(als[itemp]).Equals(gc[5].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                        /*
                                        if (cnt3 == 0)
                                        {
                                            if (itemp != nbon21l[cnt2]) throw new ArgumentOutOfRangeException("itemp/nbon21", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                            nbor21l.Add(dtemp);
                                            if (gc[4].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[4].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse s hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbos21l.Add(dtemp);
                                            }
                                            else nbos21l.Add(0);
                                            if (gc[5].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[5].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse p hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbop21l.Add(dtemp);
                                            }
                                            else nbop21l.Add(0);
                                            if (gc[6].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[6].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse d hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbod21l.Add(dtemp);
                                            }
                                            else nbod21l.Add(0);
                                        }
                                        else if (cnt3 == 1)
                                        {
                                            if (itemp != nbon22l[cnt2]) throw new ArgumentOutOfRangeException("itemp/nbon22", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                            nbor22l.Add(dtemp);
                                            if (gc[4].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[4].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse s hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbos22l.Add(dtemp);
                                            }
                                            else nbos22l.Add(0);
                                            if (gc[5].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[5].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse p hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbop22l.Add(dtemp);
                                            }
                                            else nbop22l.Add(0);
                                            if (gc[6].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[6].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse d hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbod22l.Add(dtemp);
                                            }
                                            else nbod22l.Add(0);
                                        }
                                        //*///初期データ
                                    }
                                }
                                if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO table subinformation.");
                                cnt2++;
                            }
                            else if (gc[7].Captures.Count == 0 && gc[8].Captures.Count == 0)//一中心
                            {
                                nboi1l.Add(stemp);
                                if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse occupancy to double.", stemp));
                                //nboo2l.Add(dtemp);//*///初期データ
                                if (gc[3].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead ([{0}]) : Incorrect NBO type format.", stemp));
                                nbot1l.Add(gc[3].Captures[0].Value);
                                if (gc[4].Captures.Count != 1 || !byte.TryParse(gc[4].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse kazoe to byte.", stemp));
                                nbok1l.Add(btemp);
                                if (gc[5].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead ([{0}]) : Incorrect NBO atom lable format.", stemp));
                                if (gc[6].Captures.Count != 1 || !int.TryParse(gc[6].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                itemp--;
                                if (!na.fthLfP(als[itemp]).Equals(gc[5].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                nbon1l.Add(itemp);
                                /*
                                if (gc[9].Captures.Count == 1)
                                {
                                    if (!double.TryParse(gc[9].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[9]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse s hybrid ratio to double.", stemp));
                                    dtemp /= 100;
                                    nbos1l.Add(dtemp);
                                }
                                else nbos1l.Add(0);
                                if (gc[10].Captures.Count == 1)
                                {
                                    if (!double.TryParse(gc[10].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[10]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse p hybrid ratio to double.", stemp));
                                    dtemp /= 100;
                                    nbop1l.Add(dtemp);
                                }
                                else nbop1l.Add(0);
                                if (gc[11].Captures.Count == 1)
                                {
                                    if (!double.TryParse(gc[11].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[11]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse d hybrid ratio to double.", stemp));
                                    dtemp /= 100;
                                    nbod1l.Add(dtemp);
                                }
                                else nbod1l.Add(0);
                                //*///初期データ
                                cnt++;
                            }
                            else throw new ArgumentOutOfRangeException("gc[7/8/9/10/11]", string.Format("GLogRead ([{0}]): Incorrect NBO table format.", stemp));
                            scnt++;
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r66.Match(s ?? emstm);
                        m2 = GLogReg.r68.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO & bond bending information.");
                    if (cnt + cnt2 != bfn || scnt != bfn) throw new ArgumentOutOfRangeException("cnt/cnt2/scnt/bfn", "GLogRead (NBO table) : Can not verify NBO number.");
                    nbo1n = cnt;
                    nbo2n = cnt2;
                    if (nboi1l.Count != nbo1n || nbot1l.Count != nbo1n || nbok1l.Count != nbo1n || nbon1l.Count != nbo1n) throw new ArgumentOutOfRangeException("nbo1n/nboi1l/nbot1l/nbok1l/nbon1l", "GLogRead (NBO table) : Can not verify 1 center NBO number.");
                    nboi1 = nboi1l.ToArray();
                    nbot1 = nbot1l.ToArray();
                    nbok1 = nbok1l.ToArray();
                    nbon1 = nbon1l.ToArray();
                    if (nboi2l.Count != nbo2n || nbot2l.Count != nbo2n || nbok2l.Count != nbo2n || nbon21l.Count != nbo2n || nbon22l.Count != nbo2n) throw new ArgumentOutOfRangeException("nbo2n/nboi2l/nbot2l/nbok2l/nbon21l/nbon22l", "GLogRead (NBO table) : Can not verify 2 center NBO number.");
                    nboi2 = nboi2l.ToArray();
                    nbot2 = nbot2l.ToArray();
                    nbok2 = nbok2l.ToArray();
                    nbon21 = nbon21l.ToArray();
                    nbon22 = nbon22l.ToArray();
                    //Console.WriteLine("KO : nbo1n={0}\tnboi1[0]={1}\r\nnbot1[0]={2}\tnbok1[0]={3}\tnbon1[0]={4}\r\n\r\nnbo2n={5}\tnboi2[0]={6}\r\nnbot2[0]={7}\tnbok2[0]={8}\tnbon21[0]={9}\tnbon22[0]={10}", nbo1n, nboi1[0], nbot1[0], nbok1[0], nbon1[0], nbo2n, nboi2[0], nbot2[0], nbok2[0], nbon21[0], nbon22[0]);//debug用
                    nboi1l = null;
                    nboi2l = null;
                    nbot1l = null;
                    nbot2l = null;
                    nbok1l = null;
                    nbok2l = null;
                    nbon1l = null;
                    nbon21l = null;
                    nbon22l = null;
                    nboo1 = new double[nbo1n];
                    nboo2 = new double[nbo2n];
                    nbos1 = new double[nbo1n];
                    nbop1 = new double[nbo1n];
                    nbod1 = new double[nbo1n];
                    nbos21 = new double[nbo2n];
                    nbos22 = new double[nbo2n];
                    nbop21 = new double[nbo2n];
                    nbop22 = new double[nbo2n];
                    nbod21 = new double[nbo2n];
                    nbod22 = new double[nbo2n];
                    nbor21 = new double[nbo2n];
                    nbor22 = new double[nbo2n];
                    nboe1 = new double[nbo1n];
                    nboe2 = new double[nbo2n];
                    s = sr.ReadLine();
                    m = GLogReg.r69.Match(s ?? emstm);//NHO方向＆結合曲がりインデックス1を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r69.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO/bond bending index 1.");
                    s = sr.ReadLine();
                    m = GLogReg.r70.Match(s ?? emstm);//NHO方向＆結合曲がりインデックス2を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r70.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO/bond bending index 2.");
                    s = sr.ReadLine();
                    m = GLogReg.r71.Match(s ?? emstm);//初期NHO方向＆結合曲がり情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r71.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO/bond bending information.");
                    List<short> nhonl = new List<short>();//NHO番号一時リスト
                    List<double> nhod1l = new List<double>();//NHO結合曲がり1一時リスト
                    List<double> nhod2l = new List<double>();//NHO結合曲がり2一時リスト
                    /*
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 9) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NHO/bond bending information format.");
                        cc = gc[6].Captures;
                        cc2 = gc[7].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("gc[6]/gc[7]", "GLogRead : Incorrect NHO/bond bending information format.");
                        if (cc.Count == 0)
                        {
                            s = sr.ReadLine();
                            m = r71.Match(s ?? emstm);
                            continue;
                        }
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !short.TryParse(cc[0].Value, out stemp)) throw new ArgumentNullException("gc[1]", "GLogRead (NHO/bond bending) : Can not parse NHO index to short.");
                        nhonl.Add(stemp);
                        cc = gc[2].Captures;
                        itemp = Array.FindIndex(nboi2, (short n) => { return n == stemp; });
                        if (itemp == -1) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead (NHO/bond bending) : Can not find NHO[{0}] in nboi2.", stemp));
                        if (cc.Count != 1 || !nbot2[itemp].Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentNullException("gc[2]/nbot2", "GLogRead (NHO/bond bending) : Can not verify NHO type.");
                        cc = gc[3].Captures;
                        if (cc.Count != 1 || !byte.TryParse(cc[0].Value, out btemp)) throw new ArgumentNullException("gc[3]", "GLogRead (NHO/bond bending) : Can not parse NHO kazoe to short.");
                        if (nbok2[itemp] != btemp) throw new ArgumentNullException("gc[3]/nbok2", "GLogRead (NHO/bond bending) : Can not verify NHO kazoe.");
                        cc = gc[4].Captures;
                        cc2 = gc[5].Captures;
                        itemp2 = nbon21[itemp];
                        if (cc2.Count != 1 || !int.TryParse(cc2[0].Value, out itemp3)) throw new ArgumentNullException("gc[5]", "GLogRead (NHO/bond bending) : Can not parse NHO atom number 1 to int.");
                        if (itemp2 != itemp3 - 1) throw new ArgumentOutOfRangeException("gc[5]/nbon21", "GLogRead (NHO/bond bending) : Can not verify NHO atom number 1.");
                        if (cc.Count != 1 || !na.fthLfP(als[itemp2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]/als", "GLogRead (NHO/bond bending) : Can not verify NHO atom lable 1.");
                        cc = gc[6].Captures;
                        cc2 = gc[7].Captures;
                        itemp2 = nbon22[itemp];
                        if (cc2.Count != 1 || !int.TryParse(cc2[0].Value, out itemp3)) throw new ArgumentNullException("gc[7]", "GLogRead (NHO/bond bending) : Can not parse NHO atom number 2 to int.");
                        if (itemp2 != itemp3 - 1) throw new ArgumentOutOfRangeException("gc[7]/nbon22", "GLogRead (NHO/bond bending) : Can not verify NHO atom number 2.");
                        if (cc.Count != 1 || !na.fthLfP(als[itemp2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[6]/als", "GLogRead (NHO/bond bending) : Can not verify NHO atom lable 2.");
                        cc = gc[8].Captures;
                        if (cc.Count != 8) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead : Incorrect NHO/bond bending information format.");
                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentNullException("cc[0]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] LoC Theta to double.", stemp));
                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentNullException("cc[1]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] LoC Phi to double.", stemp));
                        if (double.TryParse(cc[2].Value, out dtemp))
                        {
                            if (!double.TryParse(cc[3].Value, out dtemp)) throw new ArgumentNullException("cc[3]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid1 Phi to double.", stemp));
                            if (!double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentNullException("cc[4]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid1 Dev to double.", stemp));
                            nhod1l.Add(dtemp);
                        }
                        else if (double.TryParse(cc[3].Value, out dtemp) || double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentNullException("cc[2]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid1 Theta to double.", stemp));
                        else nhod1l.Add(0);
                        if (double.TryParse(cc[5].Value, out dtemp))
                        {
                            if (!double.TryParse(cc[6].Value, out dtemp)) throw new ArgumentNullException("cc[6]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid2 Phi to double.", stemp));
                            if (!double.TryParse(cc[7].Value, out dtemp)) throw new ArgumentNullException("cc[7]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid2 Dev to double.", stemp));
                            nhod2l.Add(dtemp);
                        }
                        else if (double.TryParse(cc[6].Value, out dtemp) || double.TryParse(cc[7].Value, out dtemp)) throw new ArgumentNullException("cc[5]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid2 Theta to double.", stemp));
                        else nhod1l.Add(0);
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r71.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find second order perturbation theory analysis information.");
                    if (nhonl.Count != cnt || nhod1l.Count != cnt || nhod2l.Count != cnt) throw new ArgumentOutOfRangeException("nhonl/nhod1l/nhod2l/cnt", "GLogRead (NHO/bond bending) : Can not verify NHO number.");
                    nhon = nhonl.ToArray();
                    nhod1 = nhod1l.ToArray();
                    nhod2 = nhod2l.ToArray();
                    //Console.WriteLine("E : cnt={0}\tnhon[0]={1}\r\nnhod1[0]={2}\tnhod2[0]={3}", cnt, nhon[0], nhod1[0], nhod2[0]);//debug用
                    nhonl = null;
                    nhod1l = null;
                    nhod2l = null;
                    //*///初期データ
                    s = sr.ReadLine();
                    m = GLogReg.r72.Match(s ?? emstm);//初期二次摂動理論分析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r72.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find second order perturbation theory analysis title.");
                    s = sr.ReadLine();
                    m = GLogReg.r73.Match(s ?? emstm);//初期二次摂動理論分析情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r73.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find second order perturbation theory analysis information.");
                    List<short> sopdl = new List<short>();
                    List<short> sopal = new List<short>();
                    List<double> sopel = new List<double>();
                    m2 = GLogReg.r74.Match(s);//初期NBOまとめタイトルを探す
                    //cnt = 0;
                    while (s != null && !m2.Success)
                    {
                        /*
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 9) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            if (cc[0].Value == "***")
                            {
                                flg = null;
                                cnt2 = 0;
                                if (!byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO kazoe to byte.");
                                if (!int.TryParse(gc[5].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                if (gc[6].Captures[0].Value == emstm && gc[7].Captures[0].Value == emstm)
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon1, cnt2, (int i) => { return i == itemp; });
                                        if (nbok1[itemp2] == btemp)
                                        {
                                            if (nbot1[itemp2].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase))
                                            {
                                                stemp = nboi1[itemp2];
                                                flg = true;
                                                break;
                                            }
                                        }
                                        cnt2++;
                                        if (cnt2 == nbo1n) break;
                                    }
                                }
                                else
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon21, cnt2, (int i) => { return i == itemp; });
                                        if (!int.TryParse(gc[7].Captures[0].Value, out itemp3)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                        if (itemp3 == nbon22[itemp2])
                                        {
                                            if (nbok2[itemp2] == btemp)
                                            {
                                                if (nbot2[itemp2].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase))
                                                {
                                                    stemp = nboi2[itemp2];
                                                    flg = true;
                                                    break;
                                                }
                                            }
                                        }
                                        cnt2++;
                                    }
                                }
                                if (flg == null) throw new ArgumentNullException("flg", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO information.");
                            }
                            else if (!short.TryParse(cc[0].Value, out stemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO index to short.");
                            sopdl.Add(stemp);
                            if (cc[1].Value == "***")
                            {
                                flg = null;
                                cnt2 = 0;
                                if (!byte.TryParse(gc[3].Captures[1].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO kazoe to byte.");
                                if (!int.TryParse(gc[5].Captures[1].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                if (gc[6].Captures[1].Value == emstm && gc[7].Captures[1].Value == emstm)
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon1, cnt2, (int i) => { return i == itemp; });
                                        if (nbok1[itemp2] == btemp)
                                        {
                                            if (nbot1[itemp2].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase))
                                            {
                                                scnt = nboi1[itemp2];
                                                flg = true;
                                                break;
                                            }
                                        }
                                        cnt2++;
                                        if (cnt2 == nbo1n) break;
                                    }
                                }
                                else
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon21, cnt2, (int i) => { return i == itemp; });
                                        if (!int.TryParse(gc[7].Captures[1].Value, out itemp3)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                        if (itemp3 == nbon22[itemp2])
                                        {
                                            if (nbok2[itemp2] == btemp)
                                            {
                                                if (nbot2[itemp2].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase))
                                                {
                                                    scnt = nboi2[itemp2];
                                                    flg = true;
                                                    break;
                                                }
                                            }
                                        }
                                        cnt2++;
                                    }
                                }
                                if (flg == null) throw new ArgumentNullException("flg", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO information.");
                            }
                            else if (!short.TryParse(cc[1].Value, out scnt)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO index to short.");
                            sopal.Add(scnt);
                            if (gc[2].Captures.Count != 2 || gc[3].Captures.Count != 2 || gc[4].Captures.Count != 2 || gc[5].Captures.Count != 2 || gc[6].Captures.Count != 2 || gc[7].Captures.Count != 2) throw new ArgumentOutOfRangeException("gc[2/3/4/5/6/7]", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            cc = gc[6].Captures;
                            cc2 = gc[7].Captures;
                            if (cc[0].Value == emstm && cc2[0].Value == emstm)
                            {
                                itemp = Array.FindIndex(nboi1, (short n) => { return n == stemp; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi1/stemp", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO index.");
                                if (!nbot1[itemp].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot1/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO kazoe to byte.");
                                if (nbok1[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok1/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[0].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                itemp2--;
                                if (nbon1[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon1/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom lable.");
                            }
                            else
                            {
                                itemp = Array.FindIndex(nboi2, (short n) => { return n == stemp; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi2/stemp", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO index.");
                                if (!nbot2[itemp].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot2/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO kazoe to byte.");
                                if (nbok2[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok2/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[0].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom 1 number to int.");
                                itemp2--;
                                if (nbon21[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon21/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 1 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 1 lable.");
                                if (!int.TryParse(cc2[0].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[7]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom 2 number to int.");
                                itemp2--;
                                if (nbon22[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon22/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 2 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[6]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 2 lable.");
                            }
                            if (cc[1].Value == emstm && cc2[1].Value == emstm)
                            {
                                itemp = Array.FindIndex(nboi1, (short n) => { return n == scnt; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi1/stemp", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO index.");
                                if (!nbot1[itemp].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot1/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[1].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO kazoe to byte.");
                                if (nbok1[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok1/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[1].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom number to int.");
                                itemp2--;
                                if (nbon1[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon1/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom lable.");
                            }
                            else
                            {
                                itemp = Array.FindIndex(nboi2, (short n) => { return n == scnt; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi2/stemp", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO index.");
                                if (!nbot2[itemp].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot2/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[1].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO kazoe to byte.");
                                if (nbok2[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok2/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[1].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom 1 number to int.");
                                itemp2--;
                                if (nbon21[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon21/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 1 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 1 lable.");
                                if (!int.TryParse(cc2[1].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[7]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom 2 number to int.");
                                itemp2--;
                                if (nbon22[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon22/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 2 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(cc[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[6]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 2 lable.");
                            }
                            cc = gc[8].Captures;
                            if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (second order perturbation theory analysis) : Can not parse E(2) to double.");
                            sopel.Add(dtemp);
                            if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (second order perturbation theory analysis) : Can not parse E(j)-E(i) to double.");
                            if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (second order perturbation theory analysis) : Can not parse F(i,j) to double.");
                            cnt++;
                        }
                        //*///初期データ
                        s = sr.ReadLine();
                        //m = r73.Match(s ?? emstm);
                        m2 = GLogReg.r74.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO summary information.");
                    /*
                    if (sopdl.Count != cnt || sopal.Count != cnt || sopel.Count != cnt) throw new ArgumentOutOfRangeException("sopdl/sopal/sopel/cnt", "GLogRead (second order perturbation theory analysis) : Can not verify amount.");
                    sopd = sopdl.ToArray();
                    sopa = sopal.ToArray();
                    sope = sopel.ToArray();
                    //Console.WriteLine("I : cnt={0}\tsopd[0]={1}\r\nsopa[0]={2}\tsope[0]={3}", cnt, sopd[0], sopa[0], sope[0]);//debug用
                    //*///初期データ
                    s = sr.ReadLine();
                    m = GLogReg.r75.Match(s ?? emstm);//初期NBOまとめインデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r75.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO summary index.");
                    s = sr.ReadLine();
                    m = GLogReg.r76.Match(s ?? emstm);//初期NBOまとめ情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r76.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO summary information.");
                    cnt = 0;//一中心
                    cnt2 = 0;//二中心
                    m2 = GLogReg.r3.Match(s);//分割線を探す
                    while (s != null && !m2.Success)
                    {
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 10) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NBO summary information format.");
                            cc = gc[6].Captures;
                            cc2 = gc[7].Captures;
                            if (cc.Count == 0 && cc2.Count == 0)
                            {
                                if (gc[1].Captures.Count != 1 || !short.TryParse(gc[1].Captures[0].Value, out svf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (NBO summary) : Can not parse NBO index to short.");
                                cnt4 = Array.FindIndex(nboi1, (i) => { return i == svf; });
                                if (gc[2].Captures.Count != 1 || !nbot1[cnt4].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot1/gc[2]", "GLogRead (NBO summary) : Can not verify NBO type.");
                                if (gc[3].Captures.Count != 1 || !byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (NBO summary) : Can not parse NBO kazoe to byte.");
                                if (nbok1[cnt4] != btemp) throw new ArgumentOutOfRangeException("nbok1/btemp", "GLogRead (NBO summary) : Can not verify NBO kazoe.");
                                if (gc[5].Captures.Count != 1 || !int.TryParse(gc[5].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (NBO summary) : Can not parse NBO atom number to int.");
                                ivf--;
                                if (nbon1[cnt4] != ivf) throw new ArgumentOutOfRangeException("nbon1/gc[5]", "GLogRead (NBO summary) : Can not verify NBO atom number.");
                                if (!na.fthLfP(als[ivf]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (NBO summary) : Can not verify NBO atom lable.");
                                if (gc[8].Captures.Count != 1 || !double.TryParse(gc[8].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (NBO summary) : Can not parse NBO occupancy to double.");
                                /*
                                if (dtemp != nboo1[cnt4]) throw new ArgumentOutOfRangeException("gc[8]/nboo1", "GLogRead (NBO summary) : Can not verify NBO occupancy.");
                                if (gc[9].Captures.Count != 1 || !double.TryParse(gc[9].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[9]", "GLogRead (NBO summary) : Can not parse NBO energy to double.");
                                nboe1[cnt4] = dtemp;
                                //*///初期データ
                                cnt++;
                            }
                            else if (cc.Count == 1 && cc2.Count == 1)
                            {
                                if (gc[1].Captures.Count != 1 || !short.TryParse(gc[1].Captures[0].Value, out svf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (NBO summary) : Can not parse NBO index to short.");
                                cnt4 = Array.FindIndex(nboi2, (i) => { return i == svf; });
                                if (gc[2].Captures.Count != 1 || !nbot2[cnt4].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot2/gc[2]", "GLogRead (NBO summary) : Can not verify NBO type.");
                                if (gc[3].Captures.Count != 1 || !byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (NBO summary) : Can not parse NBO kazoe to byte.");
                                if (nbok2[cnt4] != btemp) throw new ArgumentOutOfRangeException("nbok2/btemp", "GLogRead (NBO summary) : Can not verify NBO kazoe.");
                                if (gc[5].Captures.Count != 1 || !int.TryParse(gc[5].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (NBO summary) : Can not parse NBO atom 1 number to int.");
                                ivf--;
                                if (nbon21[cnt4] != ivf) throw new ArgumentOutOfRangeException("nbon21/gc[5]", "GLogRead (NBO summary) : Can not verify NBO atom 1 number.");
                                if (!na.fthLfP(als[ivf]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (NBO summary) : Can not verify NBO atom 1 lable.");
                                if (!int.TryParse(cc2[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[7]", "GLogRead (NBO summary) : Can not parse NBO atom 2 number to int.");
                                ivf--;
                                if (nbon22[cnt4] != ivf) throw new ArgumentOutOfRangeException("nbon22/gc[7]", "GLogRead (NBO summary) : Can not verify NBO atom 2 number.");
                                if (!na.fthLfP(als[ivf]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[6]", "GLogRead (NBO summary) : Can not verify NBO atom 2 lable.");
                                if (gc[8].Captures.Count != 1 || !double.TryParse(gc[8].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (NBO summary) : Can not parse NBO occupancy to double.");
                                /*
                                if (dtemp != nboo2[cnt4]) throw new ArgumentOutOfRangeException("gc[8]/nboo2", "GLogRead (NBO summary) : Can not verify NBO occupancy.");
                                if (gc[9].Captures.Count != 1 || !double.TryParse(gc[9].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[9]", "GLogRead (NBO summary) : Can not parse NBO energy to double.");
                                nboe2[cnt4] = dtemp;
                                //*///初期データ
                                cnt2++;
                            }
                            else throw new ArgumentOutOfRangeException("gc[6]/gc[7]", "GLogRead : Incorrect NBO summary information format.");
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r76.Match(s ?? emstm);
                        m2 = GLogReg.r3.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optimization information.");
                    //Console.WriteLine("I : cnt={0}\tcnt2={1}\tscnt={2}\r\nnboe1[0]={3}\tnboe2[0]={4}", cnt, cnt2, scnt, nboe1[0], nboe2[0]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r78.Match(s ?? emstm);//最適化構造タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r78.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optimized structure title.");
                    s = sr.ReadLine();
                    m = GLogReg.r5.Match(s ?? emstm);//結合長情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r5.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optimized structure information.");
                    scnt = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect radius parameters format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead ({0}) : Can not parse 2A radius index to short.", scnt));
                        if (scnt != svf) throw new ArgumentOutOfRangeException("scnt/svf", "GLogRead ({0}) : Can not verify 2A radius index.");
                        if (!int.TryParse(gc[2].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse R 1st atom to int.", scnt));
                        itemp--;
                        if (itemp != rdl[cnt, 0]) throw new ArgumentOutOfRangeException("gc[2]/rdl", string.Format("GLogRead ({0}) : Can not verify R 1st atom.", scnt));
                        if (!int.TryParse(gc[3].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse R 2nd atom to int.", scnt));
                        itemp--;
                        if (itemp != rdl[cnt, 1]) throw new ArgumentOutOfRangeException("gc[3]/rdl", string.Format("GLogRead ({0}) : Can not verify R 2nd atom.", scnt));
                        if (gc[4].Captures.Count != 1 || !double.TryParse(gc[4].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead ({0}) : Can not parse 2A radius to double.", scnt));
                        rdd[cnt] = dtemp;
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r5.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find angle information of initial parameters.");
                    if (svf != rn || scnt != rn || cnt != rn) throw new ArgumentOutOfRangeException("svf/scent/cnt/rn", "GLogRead : Radius number can not be verified.");
                    //Console.WriteLine("KI : cnt={0}\tscnt={1}\r\nrdl[0,0]={2}\trdl[0,1]={3}\trdd[0]={4}", cnt, scnt, rdl[0, 0], rdl[0, 1], rdd[0]);//debug用
                    m = GLogReg.r6.Match(s);//結合角情報を探す
                    if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Can not find angle information.");
                    scnt = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect angle initial parameters format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead ({0}) : Can not parse 3A angle to short.", scnt));
                        if (scnt != svf) throw new ArgumentOutOfRangeException("scnt/svf", "GLogRead ({0}) : Can not verify 3A angle index.");
                        if (!int.TryParse(gc[2].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse A 1st atom to int.", scnt));
                        itemp--;
                        if (itemp != agl[cnt, 0]) throw new ArgumentOutOfRangeException("gc[2]/agl", string.Format("GLogRead ({0}) : Can not verify A 1st atom.", scnt));
                        if (!int.TryParse(gc[3].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse A 2nd atom to int.", scnt));
                        itemp--;
                        if (itemp != agl[cnt, 1]) throw new ArgumentOutOfRangeException("gc[3]/agl", string.Format("GLogRead ({0}) : Can not verify A 2nd atom.", scnt));
                        if (!int.TryParse(gc[4].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse A 3rd atom to int.", scnt));
                        itemp--;
                        if (itemp != agl[cnt, 2]) throw new ArgumentOutOfRangeException("gc[4]/agl", string.Format("GLogRead ({0}) : Can not verify A 3rd atom.", scnt));
                        if (gc[5].Captures.Count != 1 || !double.TryParse(gc[5].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead ({0}) : Can not parse 3A angle to double.", scnt));
                        agd[cnt] = dtemp;
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r6.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dihedral angle information.");
                    if (svf != agn || scnt != agn || cnt != agn) throw new ArgumentOutOfRangeException("svf/scnt/cnt/agn", "GLogRead : Angle number can not be verified.");
                    //Console.WriteLine("A : cnt={0}\tscnt={1}\r\nagl[0,0]={2}\tagl[0,1]={3}\tagl[0,2]={4}\r\nagd[0]={5}", cnt, scnt, agl[0, 0], agl[0, 1], agl[0, 2], agd[0]);//debug用
                    m = GLogReg.r7.Match(s);//結合二面角情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r7.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentOutOfRangeException("s", "GLogRead : Can not find dihedral angle information of initial parameters.");
                    scnt = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect dihedral angle initial parameters format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead ({0}) : Can not parse 4A dihedral angle to short.", scnt));
                        if (!int.TryParse(gc[2].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 1st atom to int.", scnt));
                        itemp--;
                        if (itemp != dhl[cnt, 0]) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not verify D 1st atom.", scnt));
                        if (!int.TryParse(gc[3].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 2nd atom to int.", scnt));
                        itemp--;
                        if (itemp != dhl[cnt, 1]) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not verify D 2nd atom.", scnt));
                        if (!int.TryParse(gc[4].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 3rd atom to int.", scnt));
                        itemp--;
                        if (itemp != dhl[cnt, 2]) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not verify D 3rd atom.", scnt));
                        if (!int.TryParse(gc[5].Value, out itemp)) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not parse D 4th atom to int.", scnt));
                        itemp--;
                        if (itemp != dhl[cnt, 3]) throw new ArgumentException("itemp", string.Format("GLogRead ({0}) : Can not verify D 4th atom.", scnt));
                        if (gc[6].Captures.Count != 1 || !double.TryParse(gc[6].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead ({0}) : Can not parse 4D angle to double.", scnt));
                        dhd[cnt] = dtemp;
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r7.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find degree of freedom.");
                    if (scnt != dn || svf != dn || cnt != dn) throw new ArgumentOutOfRangeException("svf/scnt/cnt", "GLogRead : Dihedral angle number can not be verified.");
                    //Console.WriteLine("A : cnt={0}\tscnt={1}\r\ndhl[0,0]={2}\tdhl[0,1]={3}\tdhl[0,2]={4}\tdhl[0,3]={5}\r\ndhd[0]={6}", cnt, scnt, dhl[0, 0], dhl[0, 1], dhl[0, 2], dhl[0, 3], dhd[0]);//debug用
                    m = GLogReg.r8.Match(s);//自由度情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r8.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find degree of freedom.");
                    if (!int.TryParse(m.Groups[1].Value, out dof)) throw new ArgumentException("m", "GLogRead : Can not parse dof to int.");
                    //Console.WriteLine("SU : dof={0}", dof);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r9.Match(s ?? emstm);//標準配向タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r9.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find standard orientation title.");
                    m = GLogReg.r10.Match(s);//標準配向情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r10.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find standard orientation information.");
                    scnt = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect standard orientation information format.");
                        if (!short.TryParse(gc[1].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead (standard orientation)({0}) : Can not parse center number to short.", scnt));
                        if (scnt != svf) throw new ArgumentOutOfRangeException("svf/scnt", string.Format("GLogRead (standard orientation)({0}) : Can not verify center number.", scnt));
                        if (!byte.TryParse(gc[2].Value, out btemp)) throw new ArgumentException("btemp", string.Format("GLogRead (standard orientation)({0}) : Can not parse atomic number to byte.", scnt));
                        if (scnt > an) throw new ArgumentOutOfRangeException("scnt/an", string.Format("GLogRead standard orientation: Redundant atom detected.", scnt));
                        if (!na.fthLfP(btemp).Equals(na.fthLfP(als[cnt]))) throw new ArgumentOutOfRangeException("btemp/als", "GLogRead standard orientation: Atomic number can not be verified.");
                        if (!byte.TryParse(gc[3].Value, out btemp)) throw new ArgumentException("btemp", string.Format("GLogRead (standard orientation)({0}) : Can not parse atomic type to byte.", scnt));
                        if (!double.TryParse(gc[4].Value, out soco[cnt, 0])) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (standard orientation)({0}) : Can not parse coordinate X to double.", scnt));
                        if (!double.TryParse(gc[5].Value, out soco[cnt, 1])) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead (standard orientation)({0}) : Can not parse coordinate Y to double.", scnt));
                        if (!double.TryParse(gc[6].Value, out soco[cnt, 2])) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (standard orientation)({0}) : Can not parse coordinate Z to double.", scnt));
                        s = sr.ReadLine();
                        m = GLogReg.r10.Match(s ?? emstm);
                        cnt++;
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find rotational constants.");
                    //Console.WriteLine("E : soco[0,0]={0}\tsoco[0,1]={1}\tsoco[0,2]={2}", soco[0, 0], soco[0, 1], soco[0, 2]);//debug用
                    m = GLogReg.r11.Match(s);//回転定数情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r11.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find rotational constants information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect rotational constants information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect rotational constants information format.");
                    if (!double.TryParse(cc[0].Value.Trim(), out rc[0])) throw new ArgumentOutOfRangeException("GLogRead (rotational constants) : Can not parse IA to double.");
                    if (!double.TryParse(cc[1].Value.Trim(), out rc[1])) throw new ArgumentOutOfRangeException("GLogRead (rotational constants) : Can not parse IB to double.");
                    if (!double.TryParse(cc[2].Value.Trim(), out rc[2])) throw new ArgumentOutOfRangeException("GLogRead (rotational constants) : Can not parse IC to double.");
                    //Console.WriteLine("A : rc[0]={0}\trc[1]={1}\trc[2]={2}", rc[0], rc[1], rc[2]);//debug用
                    while (!fuckedstructure)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r79.Match(s ?? emstm);//核反発エネルギー情報を探す
                        m2 = GLogReg.r12.Match(s ?? emstm);//分割線2を探す
                        while (s != null && !(m.Success || m2.Success))
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r79.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find nuclear repulsion energy information or population analysis information.");
                        if (!m.Success && m2.Success) break;
                        else if (m.Success && !m2.Success) fuckedstructure = true;
                        else
                        {
                            throw new ArgumentNullException("s", "GLogRead : Unexpected nuclear repulsion energy information or population analysis information.");
                        }
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect nuclear repulsion energy information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out nre)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse nuclear repulsion energy to double.");
                        //Console.WriteLine("KI : nre={0}", nre);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r80.Match(s ?? emstm);//自己無撞着場エネルギー情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r80.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find SCF energy information.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect SCF energy information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out scfe)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse SCF energy to double.");
                        //Console.WriteLine("KO : scfe={0}", scfe);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r81.Match(s ?? emstm);//GIAO磁気遮蔽テンソルタイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r81.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find GIAO Magnetic shielding tensor information.");
                        s = sr.ReadLine();
                        m = GLogReg.r82.Match(s ?? emstm);//GIAO等方/異方磁気遮蔽情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r82.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find GIAO Magnetic shielding tensor information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor information format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse atom index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]/ivf", "GLogRead (GIAO) : Can not verify atom index.");
                            if (cnt >= an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead (GIAO) : Redundant atom detected.");
                            if (gc[2].Captures.Count != 1 || !gc[2].Captures[0].Value.Equals(na.fthLfP(als[cnt]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not verify atom lable.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out gmsi[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (GIAO) : Can not parse isotropic to double.");
                            if (gc[4].Captures.Count != 1 || !double.TryParse(gc[4].Captures[0].Value, out gmsa[cnt])) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (GIAO) : Can not parse anisotropic to double.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                s = sr.ReadLine();
                                if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead (GIAO) ({0}) : GIAO Magnetic shielding tensor information is not sufficient.", cnt));
                                m = GLogReg.r83.Match(s);//GIAO磁気遮蔽テンソル情報を探す
                                if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                                gc = m.Groups;
                                if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                                cc = gc[1].Captures;
                                cc2 = gc[2].Captures;
                                if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                                for (cnt3 = 0; cnt3 < 3; cnt3++)
                                {
                                    switch (cc[cnt3].Value)
                                    {
                                        case "XX":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 0, 0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor XX to double.");
                                                break;
                                            }
                                        case "XY":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 0, 1])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor XY to double.");
                                                break;
                                            }
                                        case "XZ":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 0, 2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor XZ to double.");
                                                break;
                                            }
                                        case "YX":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 1, 0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor YX to double.");
                                                break;
                                            }
                                        case "YY":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 1, 1])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor YY to double.");
                                                break;
                                            }
                                        case "YZ":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 1, 2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor YZ to double.");
                                                break;
                                            }
                                        case "ZX":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 2, 0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor ZX to double.");
                                                break;
                                            }
                                        case "ZY":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 2, 1])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor ZY to double.");
                                                break;
                                            }
                                        case "ZZ":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 2, 2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor ZZ to double.");
                                                break;
                                            }
                                    }
                                }
                            }
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead (GIAO) ({0}) : GIAO Magnetic shielding tensor information is not sufficient.", cnt));
                            m = GLogReg.r84.Match(s);//GIAO磁気遮蔽固有値情報を探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                            if (!double.TryParse(cc[0].Value, out gmse[cnt, 0])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding eigenvalue 1 to double.");
                            if (!double.TryParse(cc[1].Value, out gmse[cnt, 1])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding eigenvalue 2 to double.");
                            if (!double.TryParse(cc[2].Value, out gmse[cnt, 2])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding eigenvalue 3 to double.");
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r82.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find GIAO Magnetic shielding tensor information.");
                        if (cnt != an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead (GIAO) : Can not verify atom number.");
                        //Console.WriteLine("KO : gmsi[0]={0}\tgmsa[0]={1}\r\ngmst[0,0,0]={2}\tgmst[0,1,2]={3}\r\ngmse[0,0]={4}\tgmse[0,1]={5}\tgmse[0,2]={6}", gmsi[0], gmsa[0], gmst[0, 0, 0], gmst[0, 1, 2], gmse[0, 0], gmse[0, 1], gmse[0, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r85.Match(s ?? emstm);//等方性分極率情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r85.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find isotropic polarizability information.");
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect isotropic polarizability information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : W is not 0.");
                        cc = gc[2].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ispo)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (isotropic polarizability) : Can not parse isotropic polarizability to double.");
                        //Console.WriteLine("I : ispo={0}", ispo);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r86.Match(s ?? emstm);//磁気双極子分極率タイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r86.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole-magnetic dipole polarizability title.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect isotropic polarizability title format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : W is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r87.Match(s ?? emstm);//磁気双極子分極率インデックスを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r87.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole-magnetic dipole polarizability index.");
                        dmdp = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead ({0}) : Dipole-magnetic dipole polarizability tensor information is not sufficient.", cnt));
                            m = GLogReg.r88.Match(s);//磁気双極子分極率テンソルを探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect dipole-magnetic dipole polarizability tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect dipole-magnetic dipole polarizability tensor format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (dipole-magnetic dipole polarizability tensor) : Can not parse row index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (dipole-magnetic dipole polarizability tensor) : Can not verify row index.");
                            cc = gc[2].Captures;
                            cc2 = gc[3].Captures;
                            if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect dipole-magnetic dipole polarizability tensor format.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                sb.Clear();
                                sb.Append(cc[cnt2].Value);
                                sb.Append("E");
                                sb.Append(cc2[cnt2].Value);
                                if (!double.TryParse(sb.ToString(), out dmdp[cnt, cnt2])) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead (dipole-magnetic dipole polarizability tensor) : Can not parse coefficient to double.");
                            }
                        }
                        //Console.WriteLine("SU : dmdp[0,0]={0}\tdmdp[1,1]={1}\tdmdp[2,2]={2}", dmdp[0, 0], dmdp[1, 1], dmdp[2, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r89.Match(s ?? emstm);//DQタイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r89.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find DQ title.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect DQtitle format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ) : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ) : W is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r87.Match(s ?? emstm);//DQインデックスを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r87.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find DQ index.");
                        dqct = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead ({0}) : DQ tensor information is not sufficient.", cnt));
                            m = GLogReg.r88.Match(s);//DQテンソルを探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect DQ tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect DQ tensor format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ tensor) : Can not parse row index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ tensor) : Can not verify row index.");
                            cc = gc[2].Captures;
                            cc2 = gc[3].Captures;
                            if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect DQ tensor format.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                sb.Clear();
                                sb.Append(cc[cnt2].Value);
                                sb.Append("E");
                                sb.Append(cc2[cnt2].Value);
                                if (!double.TryParse(sb.ToString(), out dqct[cnt, cnt2])) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead (DQ tensor) : Can not parse coefficient to double.");
                            }
                        }
                        //Console.WriteLine("I : dqct[0,0]={0}\tdqct[1,1]={1}\tdqct[2,2]={2}", dqct[0, 0], dqct[1, 1], dqct[2, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r90.Match(s ?? emstm);//旋光Gタイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r90.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' title.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' title format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G') : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G') : W is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r87.Match(s ?? emstm);//DQインデックスを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r87.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' index.");
                        orgt = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead ({0}) : Optical rotation G' tensor information is not sufficient.", cnt));
                            m = GLogReg.r88.Match(s);//DQテンソルを探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect optical rotation G' tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' tensor format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G' tensor) : Can not parse row index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G' tensor) : Can not verify row index.");
                            cc = gc[2].Captures;
                            cc2 = gc[3].Captures;
                            if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect optical rotation G' tensor format.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                sb.Clear();
                                sb.Append(cc[cnt2].Value);
                                sb.Append("E");
                                sb.Append(cc2[cnt2].Value);
                                if (!double.TryParse(sb.ToString(), out orgt[cnt, cnt2])) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead (optical rotation G' tensor) : Can not parse coefficient to double.");
                            }
                        }
                        //Console.WriteLine("A : orgt[0,0]={0}\torgt[1,1]={1}\torgt[2,2]={2}", orgt[0, 0], orgt[1, 1], orgt[2, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r91.Match(s ?? emstm);//旋光G固有値とiso旋光G情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r91.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' eigenvalue and iso.");
                        orge = new double[3];
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' eigenvalue and iso format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect optical rotation G' eigenvalue format.");
                        if (!double.TryParse(cc[0].Value, out orge[0])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvalue 1 to double.");
                        if (!double.TryParse(cc[1].Value, out orge[1])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvalue 2 to double.");
                        if (!double.TryParse(cc[2].Value, out orge[2])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvalue 3 to double.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out orgi)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse iso optical rotation G' to double.");
                        //Console.WriteLine("A : orge[0]={0}\torge[1]={1}\torge[2]={2}\r\norgi={3}", orge[0], orge[1], orge[2], orgi);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r92.Match(s ?? emstm);//旋光G固有ベクトル情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r92.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' eigenvector information.");
                        orgev = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Optical rotation G' eigenvector information is insufficient.");
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect optical rotation G' eigenvector information format.");
                            gc = m.Groups;
                            if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' eigenvector information format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect optical rotation G' eigenvector information format.");
                            if (!double.TryParse(cc[0].Value, out orgev[0, cnt])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvector 1 to double.");
                            if (!double.TryParse(cc[1].Value, out orgev[1, cnt])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvector 2 to double.");
                            if (!double.TryParse(cc[2].Value, out orgev[2, cnt])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvector 3 to double.");
                            s = sr.ReadLine();
                            m = GLogReg.r92.Match(s ?? emstm);
                        }
                        //Console.WriteLine("KI : orgev[0,0]={0}\torgev[1,2]={1}\torgev[2,2]={2}", orgev[0, 0], orgev[1, 2], orgev[2, 2]);//debug用
                        m = GLogReg.r93.Match(s ?? emstm);//分子量とalpha D情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r93.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molar mass and alpha D information.");
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect molar mass and alpha D information format.");
                        if (gc[1].Captures.Count != 1 || !double.TryParse(gc[1].Captures[0].Value, out Mmass)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse molar mass to double.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out AlphaD)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse alpha D to double.");
                        break;
                    }
                    s = sr.ReadLine();
                    /*
                    m = GLogReg.r12.Match(s ?? emstm);//分割線2を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r12.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find population analysis information.");
                    */
                    m = GLogReg.r13.Match(s ?? emstm);//電子密度解析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r13.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find population analysis information.");
                    m = GLogReg.r14.Match(s);//軌道対称性タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r14.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital symmetries information.");
                    s = sr.ReadLine();
                    m = GLogReg.r15.Match(s ?? emstm);//軌道対称性情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r15.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital symmetries information.");
                    s = sr.ReadLine();
                    m = GLogReg.r16.Match(s ?? emstm);//分子軌道エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r16.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find MO energy information.");
                    cnt = 0;
                    svf = 0;
                    flg = moevo;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect MO energy information format.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;
                        if (itemp == 0) throw new ArgumentOutOfRangeException("cc", "GLogRead (MO energy) : Can not obtain orbital type information.");
                        else if (itemp == 1)
                        {
                            if (string.Equals(cc[0].Value, "occ", StringComparison.InvariantCultureIgnoreCase))
                            {
                                if (flg == false)
                                {
                                    //Console.WriteLine("KO : svf={0}\tvrtmo={1}", svf, vrtmo);//debug用
                                    if (svf != vrtmo) throw new ArgumentOutOfRangeException("svf/vrtmo", "GLogRead (MO energy) : Can not verify virtual orbital number.");
                                    flg = true;
                                }
                            }
                            else if (string.Equals(cc[0].Value, "virt", StringComparison.InvariantCultureIgnoreCase))
                            {
                                if (flg == true)
                                {
                                    //Console.WriteLine("KI : svf={0}\toccmo={1}", svf, occmo);//debug用
                                    if (svf != occmo) throw new ArgumentOutOfRangeException("svf/occmo", "GLogRead (MO energy) : Can not verify occupied orbital number.");
                                    flg = false;
                                }
                            }
                            else throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (MO energy) : Unknown orbital type.");
                        }
                        else if (itemp < 0 || itemp > 1) throw new ArgumentOutOfRangeException("itemp", "GLogRead (MO energy) : Orbital type capture is out of range.");
                        cc = gc[2].Captures;
                        itemp = cc.Count;
                        if (flg == true)
                        {
                            if (itemp <= 0 || itemp > short.MaxValue) throw new ArgumentOutOfRangeException("itemp", "GLogRead (MO energy) : Occupied orbital count is out of range.");
                            svf += (short)itemp;
                            for (cnt2 = 0; cnt2 < itemp; cnt2++)
                            {
                                if (!double.TryParse(cc[cnt2].Value.Trim(), out moev[cnt])) throw new ArgumentOutOfRangeException("m", "GLogRead (MO energy) : Can not parse occupied orbital energy to double.");
                                if (++cnt >= bfn) throw new ArgumentOutOfRangeException("cnt/bfn", "GLogRead (MO energy) : Molecular orbital count is out of range.");
                            }
                        }
                        else if (flg == false)
                        {
                            if (itemp <= 0 || itemp > short.MaxValue) throw new ArgumentOutOfRangeException("itemp", "GLogRead (MO energy) : Virtual orbital count is out of range.");
                            svf += (short)itemp;
                            for (cnt2 = 0; cnt2 < itemp; cnt2++)
                            {
                                if (!double.TryParse(cc[cnt2].Value.Trim(), out moev[cnt])) throw new ArgumentOutOfRangeException("m", "GLogRead (MO energy) : Can not parse virtual orbital energy to double.");
                                if (++cnt > bfn) throw new ArgumentOutOfRangeException("cnt/bfn", "GLogRead (MO energy) : Molecular orbital count is out of range.");
                            }
                        }
                        else throw new ArgumentOutOfRangeException("flg", "GLogRead (MO energy) : Unknown \"if statement\" error.");
                        s = sr.ReadLine();
                        m = GLogReg.r16.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficients information.");
                    if (svf != bfn) throw new ArgumentOutOfRangeException("svf/bfn", "GLogRead (MO energy) : Can not verify molecular orbital number.");
                    //Console.WriteLine("A : svf={0}\tmoevo={1}\toccmo={2}\tvrtmo={3}\r\nmoev[0]={4}\tmoev[{5}]={6}", svf, moevo, occmo, vrtmo, moev[0], moevo ? occmo : vrtmo, moev[moevo ? occmo : vrtmo]);//debug用
                    lme = moev[lmei];
                    slme = moev[slmei];
                    s2lme = moev[s2lmei];
                    hme = moev[hmei];
                    shme = moev[shmei];
                    s2hme = moev[s2hmei];
                    //Console.WriteLine("I : s2lme={0}\tslme={1}\r\nlme={2}\thme={3}\tshme={4}\ts2hme={5}\t", s2lme, slme, lme, hme, shme, s2hme);//debug用
                    m = GLogReg.r17.Match(s);//分子軌道係数タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    m = GLogReg.r17a.Match(s);//分子軌道係数インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    cnt2 = 0;//列インデックス
                    ivf = 0;
                    while (s != null && m.Success)
                    {
                        cnt3 = 0;//行インデックス
                        cnt4 = 0;//原子インデックス
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (molecular orbital coefficient) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        indl = new List<int>();
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (molecular orbital coefficient) : Can not verify colomn index.");
                        }
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (type).");
                        m = GLogReg.r17b.Match(s);//分子軌道タイプ情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is incorrect (type).");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (molecular orbital coefficient) : Molecular orbital type format is incorrect.");
                        cc = gc[1].Captures;
                        if (itemp != cc.Count) throw new ArgumentOutOfRangeException("itemp/cc", "GLogRead (molecular orbital coefficient) : Can not verify colomn number (type).");
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            switch (cc[cnt].Value)
                            {
                                case "V":
                                    {
                                        if (moevo ? indl[cnt] < occmo : indl[cnt] >= vrtmo) throw new ArgumentOutOfRangeException(string.Format("indl[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Can not verify orbital type.");
                                        break;
                                    }
                                case "O":
                                    {
                                        if (moevo ? indl[cnt] >= occmo : indl[cnt] < vrtmo) throw new ArgumentOutOfRangeException(string.Format("indl[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Can not verify orbital type.");
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (molecular orbital coefficient) : Unknown orbital type.");
                            }
                        }
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (eigenvalue).");
                        m = GLogReg.r17c.Match(s);//分子軌道固有値情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is incorrect (eigenvalue).");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (molecular orbital coefficient) : Molecular orbital eigenvalue format is incorrect.");
                        cc = gc[1].Captures;
                        if (itemp != cc.Count) throw new ArgumentOutOfRangeException("itemp/cc", "GLogRead (molecular orbital coefficient) : Can not verify colomn number (eigenvalue).");
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", string.Format("GLogRead (molecular orbital coefficient) ({0}) : Can not parse eigenvalue to double.", cnt));
                            if (moev[indl[cnt]] != dtemp) throw new ArgumentOutOfRangeException(string.Format("dtemp/moev{0}", cnt), "GLogRead (molecular orbital coefficient) : Can not verify molecular orbital energy.");
                        }
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);//分子軌道係数情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is incorrect (matrix).");
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Molecular orbital coefficient format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Molecular orbital coefficient format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (molecular orbital coefficient) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (molecular orbital coefficient) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (molecular orbital coefficient) : Can not parse matrix atom number to int.");
                                if (itemp3 != cnt4 + 1) throw new ArgumentOutOfRangeException("itemp3/cnt4", "GLogRead (molecular orbital coefficient) : Can not verify atom number (matrix).");
                                if (aobl[cnt4] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (molecular orbital coefficient) : Can not verify atomic orbital borderline (matrix).");
                            }
                            else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (molecular orbital coefficient) : Atom number format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (molecular orbital coefficient) : Atom number format is incorrect (matrix).");
                            else if (cc.Count == 1)
                            {
                                if (!cc[0].Value.Trim().Equals(na.fthLfP(als[cnt4]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (molecular orbital coefficient) : Can not verify atom lable (matrix).");
                                cnt4++;
                            }
                            else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (molecular orbital coefficient) : Atom lable format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Molecular orbital coefficient format is incorrect.");
                            if (!aol[cnt3].Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (molecular orbital coefficient) : Can not verify atomic orbital lable (matrix).");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (cnt != itemp) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (molecular orbital coefficient-matrix) : Can not verify colomn number.");
                            for (cnt = 0; cnt < itemp; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out mocm[cnt3, indl[cnt]])) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (molecular orbital coefficient-matrix) : Can not parse coefficient to double.");
                            }
                            /*
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                Console.Write("KO : {0} {1} {2}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim());
                                for (cnt = 0; cnt < itemp; cnt++) Console.Write("I : {0}", mocm[cnt3, indl[cnt]]);
                                Console.WriteLine();
                            }
                            //*///debug用
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Molecular orbital coefficient information is insufficient (matrix).");
                            m = GLogReg.r18.Match(s);
                            cnt3++;
                            /*
                            for(cnt=0;cnt<an;cnt++)
                            {
                                Console.WriteLine("SU : {0,-4} {1,-3} {2}", cnt + 1, na.fthLfP(als[cnt]), aobl[cnt]);//debug用
                            }
                            //*///debug用
                        }
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find density matrix.");
                    m = GLogReg.r19.Match(s);//密度行列タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r19.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    m = GLogReg.r17a.Match(s);//密度行列の列インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molecular orbital coefficient information.");
                    cnt2 = 0;//列インデックス
                    cnt4 = 0;//行短縮数
                    itemp3 = 0;
                    while (s != null && m.Success)
                    {
                        cnt3 = cnt4;  //行インデックス
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (density matrix) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        cnt4 += itemp;
                        indl = new List<int>();//列インデックス一時リスト
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (density matrix) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (density matrix) : Can not verify colomn index.");
                        }
                        //Console.WriteLine("KO : cnt3={0} indl[0]={1}", cnt3, indl[0]);//debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Density matrix information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);//密度行列情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Density matrix information is incorrect (matrix).");
                        itemp2 = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Density matrix format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Density matrix format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (density matrix) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (density matrix) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (density matrix) : Can not parse matrix atom number to int.");
                                itemp3--;
                                if (aobl[itemp3] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (density matrix) : Can not verify atomic orbital borderline (matrix).");
                            }
                            else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (density matrix) : Atom number format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (density matrix) : Atom number format is incorrect (matrix).");
                            else if (cc.Count == 1)
                            {
                                if (!cc[0].Value.Trim().Equals(na.fthLfP(als[itemp3]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (density matrix) : Can not verify atom lable (matrix).");
                            }
                            else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (density matrix) : Atom lable format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Density matrix format is incorrect.");
                            if (aol[cnt3] != cc[0].Value.Trim()) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (density matrix) : Can not verify atomic orbital lable (matrix).");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (itemp2 < itemp) itemp2 += 1;
                            if (cnt != itemp2) throw new ArgumentOutOfRangeException("itemp2/gc[5]", "GLogRead (density matrix-matrix) : Can not verify colomn number.");
                            for (cnt = 0; cnt < itemp2; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc{cnt}", cnt), "GLogRead (density matrix-matrix) : Can not parse coefficient to double.");
                                dnsm[cnt3, indl[cnt]] = dtemp;
                                if (cnt3 != indl[cnt]) dnsm[indl[cnt], cnt3] = dtemp;
                            }
                            /*
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                Console.Write("I : {0} {1} {2}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim());
                                for (cnt = 0; cnt < itemp2; cnt++) Console.Write("A: {0}", dnsm[cnt3, indl[cnt]]);
                                Console.WriteLine();
                            }
                            //*///debug用
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Density matrix information is insufficient (matrix).");
                            m = GLogReg.r18.Match(s);
                            cnt3++;
                        }
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full Mulliken population analysis title.");
                    m = GLogReg.r20.Match(s);//Mulliken密度解析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r20.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full Mulliken population analysis matrix.");
                    m = GLogReg.r17a.Match(s);//Mulliken密度解析行列の列インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead (full Mulliken population analysis matrix): Can not find colomn index.");
                    cnt2 = 0;//列インデックス
                    cnt4 = 0;//行短縮数
                    itemp3 = 0;
                    while (s != null && m.Success)
                    {
                        cnt3 = cnt4;  //行インデックス
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (full Mulliken population analysis matrix) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        cnt4 += itemp;
                        indl = new List<int>();//列インデックス一時リスト
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (full Mulliken population analysis) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (full Mulliken population analysis) : Can not verify colomn index.");
                        }
                        //Console.WriteLine("A : cnt3={0} indl[0]={1}", cnt3, indl[0]);//debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Full Mulliken population analysis information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);//密度行列情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Full Mulliken population analysis information is incorrect (matrix).");
                        itemp2 = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Full Mulliken population analysis format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Full Mulliken population analysis format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (full Mulliken population analysis) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (full Mulliken population analysis) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (full Mulliken population analysis) : Can not parse matrix atom number to int.");
                                itemp3--;
                                if (aobl[itemp3] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (full Mulliken population analysis) : Can not verify atomic orbital borderline (matrix).");
                            }
                            else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (full Mulliken population analysis) : Atom number format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (full Mulliken population analysis) : Atom number format is incorrect (matrix).");
                            else if (cc.Count == 1)
                            {
                                if (!cc[0].Value.Trim().Equals(na.fthLfP(als[itemp3]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (full Mulliken population analysis) : Can not verify atom lable (matrix).");
                            }
                            else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (full Mulliken population analysis) : Atom lable format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Full Mulliken population analysis format is incorrect.");
                            if (!aol[cnt3].Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (full Mulliken population analysis) : Can not verify atomic orbital lable (matrix).");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (itemp2 < itemp) itemp2 += 1;
                            if (cnt != itemp2) throw new ArgumentOutOfRangeException("itemp2/gc[5]", "GLogRead (full Mulliken population analysis-matrix) : Can not verify colomn number.");
                            for (cnt = 0; cnt < itemp2; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc{cnt}", cnt), "GLogRead (full Mulliken population analysis-matrix) : Can not parse coefficient to double.");
                                mpam[cnt3, indl[cnt]] = dtemp;
                                if (cnt3 != indl[cnt]) mpam[indl[cnt], cnt3] = dtemp;
                            }
                            /*
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt == 1)
                            {
                                Console.Write("A : {0} {1} {2}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim());
                                for (cnt = 0; cnt < itemp2; cnt++) Console.Write("I : {0}", mpam[cnt3, indl[cnt]]);
                                Console.WriteLine();
                            }
                            //*///debug用
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Full Mulliken population analysis information is insufficient (matrix).");
                            m = GLogReg.r18.Match(s);
                            cnt3++;
                        }
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population title.");
                    m = GLogReg.r21.Match(s);//総軌道密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r21.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s);//総軌道密度の列の番号を探す
                    if (!m.Success) throw new ArgumentOutOfRangeException("s", "GLogRead (gross orbital population) : Can not find colomn index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (gross orbital population) : Colomn index format is incorrect.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (gross orbital population) : Colomn index format is incorrect.");
                    if (!byte.TryParse(cc[0].Value, out btemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (gross orbital population) : Can not parse colomn index to byte.");
                    if (btemp != 1) throw new ArgumentOutOfRangeException("btemp", "GLogRead (gross orbital population) : Colomn index format is incorrect.");
                    s = sr.ReadLine();
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population information.");
                    m = GLogReg.r18.Match(s);
                    if (!m.Success) throw new ArgumentOutOfRangeException("s", "GLogRead (gross orbital population) : Can not find matrix information.");
                    cnt3 = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Gross orbital population format is incorrect.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO number) : Gross orbital population format is incorrect.");
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (gross orbital population) : Can not parse matrix row number to int.");
                        if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (gross orbital population) : Can not verify row number (matrix).");
                        cc = gc[2].Captures;
                        cnt = cc.Count;
                        if (cnt == 1)
                        {
                            if (!int.TryParse(cc[0].Value.Trim(), out itemp3)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (gross orbital population) : Can not parse matrix atom number to int.");
                            itemp3--;
                            if (aobl[itemp3] != cnt3) throw new ArgumentOutOfRangeException("aobl/cnt3", "GLogRead (gross orbital population) : Can not verify atomic orbital borderline (matrix).");
                        }
                        else if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (gross orbital population) : Atom number format is incorrect (matrix).");
                        cc = gc[3].Captures;
                        if (cnt != cc.Count) throw new ArgumentOutOfRangeException("gc[3]/gc[2]", "GLogRead (gross orbital population) : Atom number format is incorrect (matrix).");
                        else if (cc.Count == 1)
                        {
                            if (!cc[0].Value.Trim().Equals(na.fthLfP(als[itemp3]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[3]/als", "GLogRead (gross orbital population) : Can not verify atom lable (matrix).");
                        }
                        else if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (gross orbital population) : Atom lable format is incorrect (matrix).");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-AO type) : Gross orbital population format is incorrect.");
                        if (!aol[cnt3].Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol/gc[4]", "GLogRead (gross orbital population : Can not verify atomic orbital lable (matrix).");
                        cc = gc[5].Captures;
                        cnt = cc.Count;
                        if (cnt != 1) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (gross orbital population-matrix) : Can not verify colomn number.");
                        if (!double.TryParse(cc[0].Value.Trim(), out gop[cnt3])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (gross orbital population-matrix) : Can not parse coefficient to double.");
                        /*
                        cc = gc[2].Captures;
                        cnt = cc.Count;
                        if (cnt == 1) Console.WriteLine("SU : {0} {1} {2} {3}", cnt3 + 1, cc[0].Value.Trim(), gc[3].Captures[0].Value.Trim(), gop[cnt3]);
                        //*///debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Gross orbital population information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);
                        cnt3++;
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find condensed population title.");
                    m = GLogReg.r22.Match(s);//縮約密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r22.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find condensed population title.");
                    /*
                    m = GLogReg.r17a.Match(s);//縮約密度行列の列インデクスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead (condensed population matrix): Can not find colomn index.");
                    cnt2 = 0;//列インデックス
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (condensed population matrix) : Index format is incorrect.");
                        cc = gc[1].Captures;
                        itemp = cc.Count;//列の数
                        indl = new List<int>();//列インデックス一時リスト
                        for (cnt = 0; cnt < itemp; cnt++)
                        {
                            if (!int.TryParse(cc[cnt].Value.Trim(), out itemp2)) throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead (condensed population) : Can not parse colomn index to int.");
                            indl.Add(cnt2);
                            if (++cnt2 != itemp2) throw new ArgumentOutOfRangeException("cnt2/itemp2", "GLogRead (condensed population) : Can not verify colomn index.");
                        }
                        //Console.WriteLine("A : cnt3={0} indl[0]={1}", cnt3, indl[0]);//debug用
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Condensed population information is insufficient (matrix).");
                        m = GLogReg.r18.Match(s);//縮約密度行列情報を探す
                        if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Condensed population information is incorrect (matrix).");
                        cnt3 = 0;  //行インデックス
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead (matrix) : Condensed population format is incorrect.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-atom number) : Condensed population format is incorrect.");
                            if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (condensed population) : Can not parse matrix row number to int.");
                            if (ivf != cnt3 + 1) throw new ArgumentOutOfRangeException("ivf/cnt3", "GLogRead (condensed population) : Can not verify row number (matrix).");
                            cc = gc[2].Captures;
                            cnt = cc.Count;
                            if (cnt != 0) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Condensed population format is incorrect (matrix).");
                            cc = gc[3].Captures;
                            if (cc.Count != 0) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Condensed population format is incorrect (matrix).");
                            cc = gc[4].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc", "GLogRead (matrix-atom lable) : Condensed population format is incorrect.");
                            if (!na.fthLfP(als[cnt3]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (condensed population) : Can not verify atom lable (matrix).");
                            cc = gc[5].Captures;
                            cnt = cc.Count;
                            if (cnt != itemp) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (condensed population-matrix) : Can not verify colomn number.");
                            for (cnt = 0; cnt < itemp; cnt++)
                            {
                                if (!double.TryParse(cc[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc{cnt}", cnt), "GLogRead (condensed population-matrix) : Can not parse coefficient to double.");
                                cdnsm[cnt3, indl[cnt]] = dtemp;
                                //if (cnt3 == indl[cnt]) Console.Write("SU : {0} {1} {2}", cnt3 + 1, gc[4].Captures[0].Value.Trim(), cdnsm[cnt3, indl[cnt]]);//debug用
                            }
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Condensed population information is insufficient (matrix).");
                            m = GLogReg.r18.Match(s);
                            cnt3++;
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find gross orbital population title.");
                    *///不完全
                    s = sr.ReadLine();
                    m = GLogReg.r23.Match(s ?? emstm);//Mulliken電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r23.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Mulliken charge title.");
                    s = sr.ReadLine();
                    m = GLogReg.r24.Match(s ?? emstm);//Mulliken電荷情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Mulliken charge information.");
                    scnt = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect Mulliken charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", string.Format("GLogRead ({0}) : Incorrect Mulliken charge information format.", scnt));
                        if (!short.TryParse(cc[0].Value, out svf)) throw new ArgumentOutOfRangeException("svf", string.Format("GLogRead Mulliken charge({0}) : Can not parse atom number to short.", scnt));
                        if (svf != scnt) throw new ArgumentOutOfRangeException("svf/scent", "GLogRead (Mulliken charge): Can not verify atom number.");
                        b = na.fthPfL(gc[2].Value);
                        if (b == null) throw new ArgumentNullException("b", string.Format("GLogRead (Mulliken charge({0})) : Unknown atom lable", scnt));
                        if (cnt > an) throw new ArgumentOutOfRangeException("cnt", string.Format("GLogRead (Mulliken charge({0})) : Redundant atom is detected.", scnt));
                        if (b != als[cnt]) throw new ArgumentOutOfRangeException("b/als", string.Format("GLogRead (Mulliken charge({0})) : Can not verify atomic number.", scnt));
                        if (!double.TryParse(gc[3].Value, out mlkc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (Mulliken charge({0})) : Can not parse Mulliken charge to double.", scnt));
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);
                        cnt++;
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom Mulliken charges.");
                    //Console.WriteLine("KO : svf={0}\tmlkc[0]={1}", svf, mlkc[0]);//debug用
                    if (svf != an || cnt != an) throw new ArgumentOutOfRangeException("svf/cnt/an", "GLogRead Mulliken charges : Atom number can not be verified.");
                    m = GLogReg.r26.Match(s);//重原子Mulliken電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r26.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom Mulliken charge information.");
                    s = sr.ReadLine();
                    m = GLogReg.r24.Match(s ?? emstm);//重原子Mulliken電荷情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom Mulliken charge information.");
                    scnt = 0;
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        scnt++;
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect heavy atom Mulliken charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", string.Format("GLogRead ({0}) : Incorrect heavy atom Mulliken charge information format.", scnt));
                        if (!short.TryParse(cc[0].Value, out svf)) throw new ArgumentException("svf", string.Format("GLogRead heavy atom Mulliken({0}) : Can not parse atom number to short.", scnt));
                        if (svf != scnt) throw new ArgumentOutOfRangeException("svf/scent", "GLogRead (heavy atom Mulliken charge): Can not verify atom number.");
                        b = na.fthPfL(gc[2].Value);
                        if (b == null) throw new ArgumentNullException("b", string.Format("GLogRead (heavy atom Mulliken)({0}) : Unknown atom lable", scnt));
                        if (!na.fthLfP(als[cnt]).Equals(gc[2].Value)) throw new ArgumentOutOfRangeException("gc[2]/als", "GLogRead (heavy atom Mulliken)({0}) : Can not verify atom lable.");
                        if (cnt >= han) throw new ArgumentOutOfRangeException("cnt", string.Format("GLogRead (heavy atom Mulliken)({0}) : Redundant atom is detected.", scnt));
                        if (!double.TryParse(gc[3].Value, out mhsc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (heavy atom Mulliken charge({0})) : Can not parse heavy atom Mulliken charge to double.", scnt));
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);
                    }
                    //Console.WriteLine("E : svf={0}\tcnt={1}\r\nhan={2}\tmhsc[0]={3}", svf, cnt, han, mhsc[0]);//debug用
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electronic spatial extent information.");
                    if (svf != han || cnt != han) throw new ArgumentOutOfRangeException("svf/cnt/han", "GLogRead heavy atom Mulliken charges : Heavy atom number can not be verified.");
                    if (fuckedstructure)
                    {
                        //s = sr.ReadLine();
                        m = GLogReg.r94.Match(s ?? emstm);//APT電荷タイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r94.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find APT charge information.");
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);//APT電荷情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find APT charge information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect APT charge information format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (APT charge) : Can not parse atom index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (APT charge) : Can not verify atom index.");
                            if (ivf > an) throw new ArgumentOutOfRangeException("an/ivf", "GLogRead (APT charge) : Redundant atom detected.");
                            if (gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect APT charge information format.");
                            if (!na.fthLfP(als[cnt]).Equals(gc[2].Captures[0].Value)) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (APT charge) : Can not verify atom lable.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out APTc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (APT charge) : Can not parse charge to double.");
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of APT charge information.");
                        if (cnt != an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead (APT charge) : Can not verify atom number.");
                        //Console.WriteLine("SU : APTc[0]={0}", APTc[0]);//debug用
                        m = GLogReg.r95.Match(s ?? emstm);//APT総電荷情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r95.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of APT charge information.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect sum of APT charge information format.");
                        if (gc[1].Captures.Count != 1 || !double.TryParse(gc[1].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (sum of APT charge) : Can not parse charge to double.");
                        if (Math.Abs(dtemp) > 0.0001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Sum of APT charge is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r96.Match(s ?? emstm);//APT重原子電荷タイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r96.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of heavy atom APT charge information.");
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);//APT重原子電荷情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom APT charge information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect heavy atom APT charge information format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (heavy atom APT charge) : Can not parse atom index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (heavy atom APT charge) : Can not verify atom index.");
                            if (ivf > han) throw new ArgumentOutOfRangeException("han/ivf", "GLogRead (heavy atom APT charge) : Redundant atom detected.");
                            if (gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect heavy atom APT charge information format.");
                            if (!na.fthLfP(als[cnt]).Equals(gc[2].Captures[0].Value)) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (heavy atom APT charge) : Can not verify atom lable.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out APThc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (heavy atom APT charge) : Can not parse charge to double.");
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find exact/approx polarizability information.");
                        if (cnt != han) throw new ArgumentOutOfRangeException("cnt/han", "GLogRead (heavy atom APT charge) : Can not verify atom number.");
                        //Console.WriteLine("E : APThc[0]={0}", APThc[0]);//debug用
                    }
                    m = GLogReg.r27.Match(s);//ESE情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r27.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electronic spatial extent information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect electronic spatial extent information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("cc.Count", "GLogRead : Incorrect electronic spatial extent information format.");
                    if (!double.TryParse(cc[0].Value.Trim(), out ese)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (electronic spatial extent) : Can not parse electronic spatial extent to double.");
                    //Console.WriteLine("KI : ese={0}", ese);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r28.Match(s ?? emstm);//双極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r28.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole moment title.");
                    s = sr.ReadLine();
                    m = GLogReg.r29.Match(s ?? emstm);//双極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect dipole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect dipole moment information format.");
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "X":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipmm[0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse dipole moment X to double.");
                                        break;
                                    }
                                case "Y":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipmm[1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse dipole moment Y to double.");
                                        break;
                                    }
                                case "Z":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipmm[2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse dipole moment Z to double.");
                                        break;
                                    }
                                case "TOT":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dipm)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse total dipole moment to double.");
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown dipole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find quadrupole moment title.");
                    //Console.WriteLine("E : cnt3(行数)={0}\tcnt2(マッチ数)={1}\r\nX={2}\tY={3}\tZ={4}\tTOT={5}", cnt3, cnt2, dipmm[0], dipmm[1], dipmm[2], dipm);//debug用
                    m = GLogReg.r30.Match(s);//四極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r30.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find quadrupole moment title.");
                    s = sr.ReadLine();
                    m = GLogReg.r29.Match(s ?? emstm);//四極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find quadrupole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect quadrupole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect quadrupole moment information format.");
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out qdpmt[0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment XX to double.");
                                        break;
                                    }
                                case "YY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out qdpmt[1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment YY to double.");
                                        break;
                                    }
                                case "ZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out qdpmt[2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment ZZ to double.");
                                        break;
                                    }
                                case "XY":
                                case "YX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment XY to double.");
                                        qdpmt[0, 1] = dtemp;
                                        qdpmt[1, 0] = dtemp;
                                        break;
                                    }
                                case "XZ":
                                case "ZX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment XZ to double.");
                                        qdpmt[0, 2] = dtemp;
                                        qdpmt[2, 0] = dtemp;
                                        break;
                                    }
                                case "YZ":
                                case "ZY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse quadrupole moment YZ to double.");
                                        qdpmt[1, 2] = dtemp;
                                        qdpmt[2, 1] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown quadrupole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find traceless quadrupole moment title.");
                    //Console.WriteLine("SU : cnt3(行数)={0}\tcnt2(マッチ数)={1}\r\nXX={2}\tYY={3}\tZZ={4}", cnt3, cnt2, qdpmt[0, 0], qdpmt[1, 1], qdpmt[2, 2]);//debug用
                    m = GLogReg.r31.Match(s);//跡無し四極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r31.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find traceless quadrupole moment title.");
                    s = sr.ReadLine();
                    m = GLogReg.r29.Match(s ?? emstm);//跡無し四極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find traceless quadrupole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect traceless quadrupole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect traceless quadrupole moment information format.");
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out tlqmt[0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment XX to double.");
                                        break;
                                    }
                                case "YY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out tlqmt[1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment YY to double.");
                                        break;
                                    }
                                case "ZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out tlqmt[2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment ZZ to double.");
                                        break;
                                    }
                                case "XY":
                                case "YX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment XY to double.");
                                        tlqmt[0, 1] = dtemp;
                                        tlqmt[1, 0] = dtemp;
                                        break;
                                    }
                                case "XZ":
                                case "ZX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment XZ to double.");
                                        tlqmt[0, 2] = dtemp;
                                        tlqmt[2, 0] = dtemp;
                                        break;
                                    }
                                case "YZ":
                                case "ZY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse traceless quadrupole moment YZ to double.");
                                        tlqmt[1, 2] = dtemp;
                                        tlqmt[2, 1] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown traceless quadrupole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find octapole moment title.");
                    //Console.WriteLine("KI : cnt3(行数)={0}\tcnt2(マッチ数)={1}\r\nXX={2}\tYY={3}\tZZ={4}", cnt3, cnt2, tlqmt[0, 0], tlqmt[1, 1], tlqmt[2, 2]);//debug用
                    m = GLogReg.r32.Match(s);//八極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r32.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find octapole moment title.");
                    m = GLogReg.r29.Match(s);//八極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find octapole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect octapole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect octapole moment information format.");
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out ocpmt[0, 0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XXX to double.");
                                        break;
                                    }
                                case "YYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out ocpmt[1, 1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment YYY to double.");
                                        break;
                                    }
                                case "ZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out ocpmt[2, 2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment ZZZ to double.");
                                        break;
                                    }
                                case "XYY":
                                case "YXY":
                                case "YYX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XYY to double.");
                                        ocpmt[0, 1, 1] = dtemp;
                                        ocpmt[1, 0, 1] = dtemp;
                                        ocpmt[1, 1, 0] = dtemp;
                                        break;
                                    }
                                case "XXY":
                                case "XYX":
                                case "YXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XXY to double.");
                                        ocpmt[0, 0, 1] = dtemp;
                                        ocpmt[0, 1, 0] = dtemp;
                                        ocpmt[1, 0, 0] = dtemp;
                                        break;
                                    }
                                case "XXZ":
                                case "XZX":
                                case "ZXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XXZ to double.");
                                        ocpmt[0, 0, 2] = dtemp;
                                        ocpmt[0, 2, 0] = dtemp;
                                        ocpmt[2, 0, 0] = dtemp;
                                        break;
                                    }
                                case "XZZ":
                                case "ZXZ":
                                case "ZZX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XZZ to double.");
                                        ocpmt[0, 2, 2] = dtemp;
                                        ocpmt[2, 0, 2] = dtemp;
                                        ocpmt[2, 2, 0] = dtemp;
                                        break;
                                    }
                                case "YZZ":
                                case "ZYZ":
                                case "ZZY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment YZZ to double.");
                                        ocpmt[1, 2, 2] = dtemp;
                                        ocpmt[2, 1, 2] = dtemp;
                                        ocpmt[2, 2, 1] = dtemp;
                                        break;
                                    }
                                case "YYZ":
                                case "YZY":
                                case "ZYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment YYZ to double.");
                                        ocpmt[1, 1, 2] = dtemp;
                                        ocpmt[1, 2, 1] = dtemp;
                                        ocpmt[2, 1, 1] = dtemp;
                                        break;
                                    }
                                case "XYZ":
                                case "XZY":
                                case "YXZ":
                                case "YZX":
                                case "ZXY":
                                case "ZYX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse octapole moment XYZ to double.");
                                        ocpmt[0, 1, 2] = dtemp;
                                        ocpmt[0, 2, 1] = dtemp;
                                        ocpmt[1, 0, 2] = dtemp;
                                        ocpmt[1, 2, 0] = dtemp;
                                        ocpmt[2, 0, 1] = dtemp;
                                        ocpmt[2, 1, 0] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown octapole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find hexadecapole moment information.");
                    //Console.WriteLine("A : cnt3(行数)={0}\tcnt2(マッチ数)={1}\r\nXXX={2}\tYYY={3}\tZZZ={4}", cnt3, cnt2, ocpmt[0, 0, 0], ocpmt[1, 1, 1], ocpmt[2, 2, 2]);//debug用
                    m = GLogReg.r33.Match(s);//十六極子モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r33.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find hexadecapole moment title.");
                    m = GLogReg.r29.Match(s);//十六極子モーメント情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find hexadecapole moment information.");
                    //cnt3 = 0; cnt2 = 0;//debug用
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc.Count", "GLogRead : Incorrect hexadecapole moment information format.");
                        cc = gc[1].Captures;
                        cc2 = gc[2].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect hexadecapole moment information format.");
                        for (cnt = 0; cnt < cc.Count; cnt++)
                        {
                            switch (cc[cnt].Value.Trim().ToUpperInvariant())
                            {
                                case "XXXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out hdpmt[0, 0, 0, 0])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXXX to double.");
                                        break;
                                    }
                                case "YYYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out hdpmt[1, 1, 1, 1])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYYY to double.");
                                        break;
                                    }
                                case "ZZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out hdpmt[2, 2, 2, 2])) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZZZ to double.");
                                        break;
                                    }
                                case "XXXY":
                                case "XXYX":
                                case "XYXX":
                                case "YXXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXXY to double.");
                                        hdpmt[0, 0, 0, 1] = dtemp;
                                        hdpmt[0, 0, 1, 0] = dtemp;
                                        hdpmt[0, 1, 0, 0] = dtemp;
                                        hdpmt[1, 0, 0, 0] = dtemp;
                                        break;
                                    }
                                case "XXXZ":
                                case "XXZX":
                                case "XZXX":
                                case "ZXXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXXZ to double.");
                                        hdpmt[0, 0, 0, 2] = dtemp;
                                        hdpmt[0, 0, 2, 0] = dtemp;
                                        hdpmt[0, 2, 0, 0] = dtemp;
                                        hdpmt[2, 0, 0, 0] = dtemp;
                                        break;
                                    }
                                case "YYYX":
                                case "YYXY":
                                case "YXYY":
                                case "XYYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYYX to double.");
                                        hdpmt[1, 1, 1, 0] = dtemp;
                                        hdpmt[1, 1, 0, 1] = dtemp;
                                        hdpmt[1, 0, 1, 1] = dtemp;
                                        hdpmt[0, 1, 1, 1] = dtemp;
                                        break;
                                    }
                                case "YYYZ":
                                case "YYZY":
                                case "YZYY":
                                case "ZYYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYYZ to double.");
                                        hdpmt[1, 1, 1, 2] = dtemp;
                                        hdpmt[1, 1, 2, 1] = dtemp;
                                        hdpmt[1, 2, 1, 1] = dtemp;
                                        hdpmt[2, 1, 1, 1] = dtemp;
                                        break;
                                    }
                                case "ZZZX":
                                case "ZZXZ":
                                case "ZXZZ":
                                case "XZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZZX to double.");
                                        hdpmt[2, 2, 2, 0] = dtemp;
                                        hdpmt[2, 2, 0, 2] = dtemp;
                                        hdpmt[2, 0, 2, 2] = dtemp;
                                        hdpmt[0, 2, 2, 2] = dtemp;
                                        break;
                                    }
                                case "ZZZY":
                                case "ZZYZ":
                                case "ZYZZ":
                                case "YZZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZZY to double.");
                                        hdpmt[2, 2, 2, 1] = dtemp;
                                        hdpmt[2, 2, 1, 2] = dtemp;
                                        hdpmt[2, 1, 2, 2] = dtemp;
                                        hdpmt[1, 2, 2, 2] = dtemp;
                                        break;
                                    }
                                case "XXYY":
                                case "XYXY":
                                case "XYYX":
                                case "YYXX":
                                case "YXYX":
                                case "YXXY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXYY to double.");
                                        hdpmt[0, 0, 1, 1] = dtemp;
                                        hdpmt[0, 1, 0, 1] = dtemp;
                                        hdpmt[0, 1, 1, 0] = dtemp;
                                        hdpmt[1, 1, 0, 0] = dtemp;
                                        hdpmt[1, 0, 1, 0] = dtemp;
                                        hdpmt[1, 0, 0, 1] = dtemp;
                                        break;
                                    }
                                case "XXZZ":
                                case "XZXZ":
                                case "XZZX":
                                case "ZZXX":
                                case "ZXZX":
                                case "ZXXZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXZZ to double.");
                                        hdpmt[0, 0, 2, 2] = dtemp;
                                        hdpmt[0, 2, 0, 2] = dtemp;
                                        hdpmt[0, 2, 2, 0] = dtemp;
                                        hdpmt[2, 2, 0, 0] = dtemp;
                                        hdpmt[2, 0, 2, 0] = dtemp;
                                        hdpmt[2, 0, 0, 2] = dtemp;
                                        break;
                                    }
                                case "YYZZ":
                                case "YZYZ":
                                case "YZZY":
                                case "ZZYY":
                                case "ZYZY":
                                case "ZYYZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYZZ to double.");
                                        hdpmt[1, 1, 2, 2] = dtemp;
                                        hdpmt[1, 2, 1, 2] = dtemp;
                                        hdpmt[1, 2, 2, 1] = dtemp;
                                        hdpmt[2, 2, 1, 1] = dtemp;
                                        hdpmt[2, 1, 2, 1] = dtemp;
                                        hdpmt[2, 1, 1, 2] = dtemp;
                                        break;
                                    }
                                case "XXYZ":
                                case "XXZY":
                                case "XYXZ":
                                case "XYZX":
                                case "XZXY":
                                case "XZYX":
                                case "YXXZ":
                                case "YXZX":
                                case "YZXX":
                                case "ZXXY":
                                case "ZXYX":
                                case "ZYXX":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment XXYZ to double.");
                                        hdpmt[0, 0, 1, 2] = dtemp;
                                        hdpmt[0, 0, 2, 1] = dtemp;
                                        hdpmt[0, 1, 0, 2] = dtemp;
                                        hdpmt[0, 1, 2, 0] = dtemp;
                                        hdpmt[0, 2, 0, 1] = dtemp;
                                        hdpmt[0, 2, 1, 0] = dtemp;
                                        hdpmt[1, 0, 0, 2] = dtemp;
                                        hdpmt[1, 0, 2, 0] = dtemp;
                                        hdpmt[1, 2, 0, 0] = dtemp;
                                        hdpmt[2, 0, 0, 1] = dtemp;
                                        hdpmt[2, 0, 1, 0] = dtemp;
                                        hdpmt[2, 1, 0, 0] = dtemp;
                                        break;
                                    }
                                case "YYXZ":
                                case "YYZX":
                                case "YXYZ":
                                case "YXZY":
                                case "YZXY":
                                case "YZYX":
                                case "XYYZ":
                                case "XYZY":
                                case "XZYY":
                                case "ZYYX":
                                case "ZYXY":
                                case "ZXYY":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment YYXZ to double.");
                                        hdpmt[1, 1, 0, 2] = dtemp;
                                        hdpmt[1, 1, 2, 0] = dtemp;
                                        hdpmt[1, 0, 1, 2] = dtemp;
                                        hdpmt[1, 0, 2, 1] = dtemp;
                                        hdpmt[1, 2, 0, 1] = dtemp;
                                        hdpmt[1, 2, 1, 0] = dtemp;
                                        hdpmt[0, 1, 1, 2] = dtemp;
                                        hdpmt[0, 1, 2, 1] = dtemp;
                                        hdpmt[0, 2, 1, 1] = dtemp;
                                        hdpmt[2, 1, 1, 0] = dtemp;
                                        hdpmt[2, 1, 0, 1] = dtemp;
                                        hdpmt[2, 0, 1, 1] = dtemp;
                                        break;
                                    }
                                case "ZZXY":
                                case "ZZYX":
                                case "ZXZY":
                                case "ZXYZ":
                                case "ZYXZ":
                                case "ZYZX":
                                case "XZZY":
                                case "XZYZ":
                                case "XYZZ":
                                case "YZZX":
                                case "YZXZ":
                                case "YXZZ":
                                    {
                                        if (!double.TryParse(cc2[cnt].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException(string.Format("cc2[{0}]", cnt), "GLogRead : Can not parse hexadecapole moment ZZXY to double.");
                                        hdpmt[2, 2, 0, 1] = dtemp;
                                        hdpmt[2, 2, 1, 0] = dtemp;
                                        hdpmt[2, 0, 2, 1] = dtemp;
                                        hdpmt[2, 0, 1, 2] = dtemp;
                                        hdpmt[2, 1, 0, 2] = dtemp;
                                        hdpmt[2, 1, 2, 0] = dtemp;
                                        hdpmt[0, 2, 2, 1] = dtemp;
                                        hdpmt[0, 2, 1, 2] = dtemp;
                                        hdpmt[0, 1, 2, 2] = dtemp;
                                        hdpmt[1, 2, 2, 0] = dtemp;
                                        hdpmt[1, 2, 0, 2] = dtemp;
                                        hdpmt[1, 0, 2, 2] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException(string.Format("cc[{0}]", cnt), "GLogRead : Unknown hexadecapole moment information.");
                            }
                            //cnt2++;//debug用
                        }
                        //cnt3++;//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r29.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find repulsion/attraction/kinetic energy information.");
                    //Console.WriteLine("A : cnt3(行数)={0}\tcnt2(マッチ数)={1}\r\nXXXX={2}\tYYYY={3}\tZZZZ={4}", cnt3, cnt2, hdpmt[0, 0, 0, 0], hdpmt[1, 1, 1, 1], hdpmt[2, 2, 2, 2]);//debug用
                    m = GLogReg.r34.Match(s);//反発/吸引/運動エネルギー情報
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r34.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find repulsion/attraction/kinetic energy information.");
                    gc = m.Groups;
                    if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect repulsion/attraction/kinetic energy information format.");
                    if (gc[1].Captures.Count != 1 || gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]/gc[2]", "GLogRead : Incorrect repulsion energy information format.");
                    if (gc[3].Captures.Count != 1 || gc[4].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]/gc[2]", "GLogRead : Incorrect attraction energy information format.");
                    if (gc[5].Captures.Count != 1 || gc[6].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]/gc[2]", "GLogRead : Incorrect kinetic energy information format.");
                    sb.Clear();
                    sb.Append(gc[1].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[2].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out nnrepe)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse repulsion energy to double.");
                    sb.Clear();
                    sb.Append(gc[3].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[4].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out enatre)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse attraction energy to double.");
                    sb.Clear();
                    sb.Append(gc[5].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[6].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out keknte)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse kinetic energy to double.");
                    //Console.WriteLine("E : nnrepe={0}\tenatre={1}\tkeknte={2}", nnrepe, enatre, keknte);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r35.Match(s ?? emstm);//EISum情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r35.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find EISum information.");
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect EISum information format.");
                        cc = gc[1].Captures;
                        if (cc.Count == 1)
                        {
                            cc = gc[2].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect atomic densities EISum information format.");
                            if (!double.TryParse(cc[0].Value, out eisad)) throw new ArgumentOutOfRangeException("cc", "GLogRead : Can not parse atomic densities EISum to double.");
                        }
                        else if (cc.Count == 0)
                        {
                            cc = gc[2].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect density EISum information format.");
                            if (!double.TryParse(cc[0].Value, out eisd)) throw new ArgumentOutOfRangeException("cc", "GLogRead : Can not parse density EISum to double.");
                        }
                        else throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect EISum information format.");
                        s = sr.ReadLine();
                        m = GLogReg.r35.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld populations title.");
                    //Console.WriteLine("SU : eisad={0}\teisd={1}", eisad, eisd);//debug用
                    m = GLogReg.r36.Match(s);//Hirshfeld電荷密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r36.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld populations title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//Hirshfeld電荷密度インデックスを探す
                    if (!m.Success) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld populations index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld populations index format.");
                    cc = gc[1].Captures;
                    itemp = cc.Count;
                    cnt = 0;
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//Hirshfeld電荷密度情報を探す
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentNullException("gc", "GLogRead : Incorrect Hirshfeld populations format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentNullException("gc[1]", "GLogRead (Hirshfeld populations): Incorrect atom index format.");
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld populations) : Can not parse atom index to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (Hirshfeld populations) : Can not verify atom index.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentNullException("gc[2]/gc[3]", "GLogRead : Incorrect Hirshfeld populations format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentNullException("gc[4]", "GLogRead (Hirshfeld populations): Incorrect atom index format.");
                        if (!na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (Hirshfeld populations) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != itemp) throw new ArgumentOutOfRangeException("itemp/gc[5]", "GLogRead (Hirshfeld populations) : Can not verify colomn number.");
                        if (itemp == 5)
                        {
                            if (!double.TryParse(cc[0].Value.Trim(), out HCAB[cnt])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld populations) : Can not parse CA to double.");
                            if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld populations) : Can not parse CB to double.");
                            if (Math.Abs(HCAB[cnt] - dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("HCAB[{0}]/dtemp", cnt), "GLogRead (Hirshfeld populations) : Can not verify CA & CB.");
                            if (!double.TryParse(cc[2].Value.Trim(), out HDXYZ[cnt, 0])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld populations) : Can not parse DipX to double.");
                            if (!double.TryParse(cc[3].Value.Trim(), out HDXYZ[cnt, 1])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (Hirshfeld populations) : Can not parse DipY to double.");
                            if (!double.TryParse(cc[4].Value.Trim(), out HDXYZ[cnt, 2])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (Hirshfeld populations) : Can not parse DipZ to double.");
                        }
                        else if (itemp == 6)
                        {
                            if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld populations) : Can not parse CX to double.");
                            if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("dtemp", cnt), "GLogRead (Hirshfeld populations) : CX is not 0.");
                            if (!double.TryParse(cc[1].Value.Trim(), out HCAB[cnt])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld populations) : Can not parse CA to double.");
                            if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld populations) : Can not parse CB to double.");
                            if (Math.Abs(HCAB[cnt] - dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("HCAB[{0}]/dtemp", cnt), "GLogRead (Hirshfeld populations) : Can not verify CA & CB.");
                            if (!double.TryParse(cc[3].Value.Trim(), out HDXYZ[cnt, 0])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (Hirshfeld populations) : Can not parse DipX to double.");
                            if (!double.TryParse(cc[4].Value.Trim(), out HDXYZ[cnt, 1])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (Hirshfeld populations) : Can not parse DipY to double.");
                            if (!double.TryParse(cc[5].Value.Trim(), out HDXYZ[cnt, 2])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (Hirshfeld populations) : Can not parse DipZ to double.");
                        }
                        else throw new ArgumentOutOfRangeException("ivf", "GLogRead : Unknown Hirshfeld populations format (colomn number).");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld populations information.");
                    //Console.WriteLine("I : itemp={0}\tivf={1}\tHCAB[0]={2}\r\nHDXYZ[0,0]={3}\tHDXYZ[0,1]={4}\tHDXYZ[0,2]={5}", itemp, ivf, HCAB[0], HDXYZ[0, 0], HDXYZ[0, 1], HDXYZ[0, 2]);//debug用
                    m = GLogReg.r37.Match(s ?? emstm);//total Hirshfeld populations を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r37.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld populations information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentNullException("gc", "GLogRead : Incorrect total Hirshfeld populations format.");
                    cc = gc[1].Captures;
                    if (cc.Count != itemp) throw new ArgumentOutOfRangeException("itemp/gc[1]", "GLogRead (total Hirshfeld populations) : Can not verify colomn number.");
                    if (itemp == 5)
                    {
                        if (!double.TryParse(cc[0].Value.Trim(), out HCABt)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (total Hirshfeld populations) : Can not parse CA to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (total Hirshfeld populations) : Can not parse CB to double.");
                        if (Math.Abs(HCABt - dtemp) > 0.00001) throw new ArgumentOutOfRangeException("HCABt/dtemp", "GLogRead (total Hirshfeld populations) : Can not verify CA & CB.");
                        if (!double.TryParse(cc[2].Value.Trim(), out HDXYZt[0])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (total Hirshfeld populations) : Can not parse DipX to double.");
                        if (!double.TryParse(cc[3].Value.Trim(), out HDXYZt[1])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (total Hirshfeld populations) : Can not parse DipY to double.");
                        if (!double.TryParse(cc[4].Value.Trim(), out HDXYZt[2])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (total Hirshfeld populations) : Can not parse DipZ to double.");
                    }
                    else if (itemp == 6)
                    {
                        if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (total Hirshfeld populations) : Can not parse CX to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException(string.Format("dtemp", cnt), "GLogRead (total Hirshfeld populations) : CX is not 0.");
                        if (!double.TryParse(cc[1].Value.Trim(), out HCABt)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (total Hirshfeld populations) : Can not parse CA to double.");
                        if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (total Hirshfeld populations) : Can not parse CB to double.");
                        if (Math.Abs(HCABt - dtemp) > 0.00001) throw new ArgumentOutOfRangeException("HCABt/dtemp", "GLogRead (total Hirshfeld populations) : Can not verify CA & CB.");
                        if (!double.TryParse(cc[3].Value.Trim(), out HDXYZt[0])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (total Hirshfeld populations) : Can not parse DipX to double.");
                        if (!double.TryParse(cc[4].Value.Trim(), out HDXYZt[1])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (total Hirshfeld populations) : Can not parse DipY to double.");
                        if (!double.TryParse(cc[5].Value.Trim(), out HDXYZt[2])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (total Hirshfeld populations) : Can not parse DipZ to double.");
                    }
                    else throw new ArgumentOutOfRangeException("itemp", "GLogRead : Unknown Hirshfeld populations format (colomn number).");
                    //Console.WriteLine("KO : HCABt={0}\tHDipx={1}\r\nHDipy={2}\tHDipz={3}", HCABt, HDXYZt[0], HDXYZt[1], HDXYZt[2]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r38.Match(s ?? emstm);//Hirshfeld双極子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r38.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld Dip from chg information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentNullException("gc", "GLogRead : Incorrect Hirshfeld Dip from chg format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld Dip from chg) : Can not verify Dip number.");
                    if (!double.TryParse(cc[0].Value.Trim(), out HDipc[0])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld Dip from chg) : Can not parse DipX to double.");
                    if (!double.TryParse(cc[1].Value.Trim(), out HDipc[1])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld Dip from chg) : Can not parse DipY to double.");
                    if (!double.TryParse(cc[2].Value.Trim(), out HDipc[2])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld Dip from chg) : Can not parse DipZ to double.");
                    //Console.WriteLine("SU : HDipc[0]={0}\tHDipc[1]={1}\tHDipc[2]={2}", HDipc[0], HDipc[1], HDipc[2]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r39.Match(s ?? emstm);//total Hirshfeld双極子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r39.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld Dip information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentNullException("gc", "GLogRead : Incorrect total Hirshfeld Dip format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (total Hirshfeld Dip) : Can not verify Dip number.");
                    if (!double.TryParse(cc[0].Value.Trim(), out HDipt[0])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (total Hirshfeld Dip) : Can not parse DipX to double.");
                    if (!double.TryParse(cc[1].Value.Trim(), out HDipt[1])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (total Hirshfeld Dip) : Can not parse DipY to double.");
                    if (!double.TryParse(cc[2].Value.Trim(), out HDipt[2])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (total Hirshfeld Dip) : Can not parse DipZ to double.");
                    //Console.WriteLine("KI : HDipt[0]={0}\tHDipt[1]={1}\tHDipt[2]={2}", HDipt[0], HDipt[1], HDipt[2]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r40.Match(s ?? emstm);//Hirshfeld原子情報タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r40.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld atom information.");
                    s = sr.ReadLine();
                    m = GLogReg.r41.Match(s ?? emstm);//Hirshfeld原子情報インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r41.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld atom index.");
                    gc = m.Groups;
                    if (gc.Count != 7 || gc[1].Captures.Count != 1 || gc[2].Captures.Count != 1 || gc[3].Captures.Count != 1 || gc[4].Captures.Count != 1 || gc[5].Captures.Count != 1 || gc[6].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld atom information format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//Hirshfeld原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld atom information.");
                    cnt = 0;
                    ivf = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld atom information format.");
                        cc = gc[1].Captures;
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld atom information) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (Hirshfeld atom information) : can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect Hirshfeld atom information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Incorrect Hirshfeld atom information format.");
                        if (!na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (Hirshfeld atom information) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != 6) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect Hirshfeld atom information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out Hachg[cnt])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld atom information) : Can not parse Q-H to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (Hirshfeld atom information) : Can not parse S-H to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("dtemp", "GLogRead (Hirshfeld atom information) : S-H is not 0.");
                        if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (Hirshfeld atom information) : Can not parse Dx to double.");
                        if (dtemp != HDXYZ[cnt, 0]) throw new ArgumentOutOfRangeException("dtemp/HDXYZ", "GLogRead (Hirshfeld atom information) : Can not verify Dipx.");
                        if (!double.TryParse(cc[3].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (Hirshfeld atom information) : Can not parse Dy to double.");
                        if (dtemp != HDXYZ[cnt, 1]) throw new ArgumentOutOfRangeException("dtemp/HDXYZ", "GLogRead (Hirshfeld atom information) : Can not verify Dipy.");
                        if (!double.TryParse(cc[4].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (Hirshfeld atom information) : Can not parse Dz to double.");
                        if (dtemp != HDXYZ[cnt, 2]) throw new ArgumentOutOfRangeException("dtemp/HDXYZ", "GLogRead (Hirshfeld atom information) : Can not verify Dipz.");
                        if (!double.TryParse(cc[5].Value.Trim(), out Hacm5chg[cnt])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (Hirshfeld atom information) : Can not parse Q-CM5 to double.");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld atom information.");
                    if (ivf != an || cnt != an) throw new ArgumentOutOfRangeException("ivf/cnt/an", "Can not verify atom number.");
                    //Console.WriteLine("E : Hachg[0]={0}\tHacm5chg[0]={1}", Hachg[0], Hacm5chg[0]);//debug用
                    m = GLogReg.r37.Match(s);//total Hirshfeld原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r37.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld atom information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect total Hirshfeld atom information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 6) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect total Hirshfeld atom information format.");
                    if (!double.TryParse(cc[0].Value.Trim(), out Hchgt)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead : Can not parse total Hirshfeld charge to double.");
                    if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead : Can not parse total Hirshfeld spin density to double.");
                    if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead : total Hirshfeld spin density is not 0.");
                    if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead : Can not parse total Hirshfeld Dx to double.");
                    if (dtemp != HDXYZt[0]) throw new ArgumentOutOfRangeException("dtemp/HDXYZt", "GLogRead : Can not verify total Hirshfeld Dx.");
                    if (!double.TryParse(cc[3].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead : Can not parse total Hirshfeld Dy to double.");
                    if (dtemp != HDXYZt[1]) throw new ArgumentOutOfRangeException("dtemp/HDXYZt", "GLogRead : Can not verify total Hirshfeld Dy.");
                    if (!double.TryParse(cc[4].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead : Can not parse total Hirshfeld Dz to double.");
                    if (dtemp != HDXYZt[2]) throw new ArgumentOutOfRangeException("dtemp/HDXYZt", "GLogRead : Can not verify total Hirshfeld Dz.");
                    if (!double.TryParse(cc[5].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead : Can not parse total Hirshfeld CM5 charge to double.");
                    if (Hchgt != dtemp) throw new ArgumentOutOfRangeException("Hchgt/dtemp", "GLogRead : Can not verify total Hirshfeld charge.");
                    s = sr.ReadLine();
                    //Console.WriteLine("I : Hchgt={0}\tHDXYZtx={1}\r\nHDXYZty={2}\tHDXYZtz={3}", Hchgt, HDXYZt[0], HDXYZt[1], HDXYZt[2]);//debug用
                    m = GLogReg.r42.Match(s ?? emstm);//total Hirshfeld重原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r42.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld heavy atom information.");
                    s = sr.ReadLine();
                    m = GLogReg.r41.Match(s ?? emstm);//total Hirshfeld重原子情報インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r41.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld heavy atom information.");
                    gc = m.Groups;
                    if (gc.Count != 7 || gc[1].Captures.Count != 1 || gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0 || gc[4].Captures.Count != 0 || gc[5].Captures.Count != 0 || gc[6].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//Hirshfeld重原子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find Hirshfeld heavy atom information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        cc = gc[1].Captures;
                        if (!int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (Hirshfeld heavy atom information) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (Hirshfeld heavy atom information) : can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        if (!na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (Hirshfeld heavy atom information) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect Hirshfeld heavy atom information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out Hhachg[cnt])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (Hirshfeld heavy atom information) : Can not parse Q-H to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out Hhacm5chg[cnt])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (Hirshfeld heavy atom information) : Can not parse Q-CM5 to double.");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total Hirshfeld atom information.");
                    if (ivf != han) throw new ArgumentOutOfRangeException("ivf/an", "Can not verify heavy atom number.");
                    //Console.WriteLine("KI : Hhachg[0]={0}\tHhacm5chg[0]={1}", Hhachg[0], Hhacm5chg[0]);//debug用
                    m = GLogReg.r43.Match(s);//EQQ/EQD/EDD情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r43.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find EQQ/EQD/EDD information.");
                    gc = m.Groups;
                    if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect EQQ/EQD/EDD information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (EQQ/EQD/EDD) : Can not parse EQQ to double.");
                    if (Math.Abs(dtemp) > 0.0000000001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (EQQ/EQD/EDD) : EQQ is not 0.");
                    cc = gc[2].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (EQQ/EQD/EDD) : Can not parse EQD to double.");
                    if (Math.Abs(dtemp) > 0.0000000001) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (EQQ/EQD/EDD) : EQD is not 0.");
                    cc = gc[3].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out EDD)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (EQQ/EQD/EDD) : Can not parse EDD to double.");
                    //Console.WriteLine("A : dtemp={0}\tEDD={1}", dtemp, EDD);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r44.Match(s ?? emstm);//EQQ+QD+DD情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r44.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find EQQ+QD+DD information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect EQQ+QD+DD information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (EQQ+QD+DD) : Can not parse EQQ+QD+DD to double.");
                    if (Math.Abs(EDD - dtemp) > 0.0000000001) throw new ArgumentOutOfRangeException("EDD/dtemp", "GLogRead (EQQ+QD+DD) : Can not verify EDD.");
                    //Console.WriteLine("SU : EDD={0}\tdtemp={0}", EDD, dtemp);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r45.Match(s ?? emstm);//軌道エネルギーと運動エネルギータイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r45.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//軌道エネルギーと運動エネルギー情報インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    if (m.Groups.Count != 2 || m.Groups[1].Captures.Count != 2) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect orbital energy & kinetic energy information.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//軌道エネルギーと運動エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect orbital energy & kinetic energy information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (orbital energy & kinetic energy) : Can not parse orbital number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (orbital energy & kinetic energy) : Can not verify orbital number.");
                        if (ivf > bfn) throw new ArgumentOutOfRangeException("ivf/bfn", "GLogRead (orbital energy & kinetic energy) : Redundant orbital detected.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect orbital energy & kinetic energy information format.");
                        cc = gc[4].Captures;
                        s = cc[0].Value.Trim();
                        if (moevo)
                        {
                            if (s != (cnt < occmo ? "O" : "V")) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (orbital energy & kinetic energy) : Can not verify orbital type.");
                        }
                        else
                        {
                            if (s != (cnt < vrtmo ? "V" : "O")) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (orbital energy & kinetic energy) : Can not verify orbital type.");
                        }
                        cc = gc[5].Captures;
                        if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect orbital energy & kinetic energy information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (orbital energy & kinetic energy) : Can not parse energy to double.");
                        if (Math.Abs(dtemp - moev[cnt]) > 0.00001) throw new ArgumentOutOfRangeException("dtemp/moev", "GLogRead (orbital energy & kinetic energy) : Can not verify energy.");
                        moev[cnt] = dtemp;
                        if (!double.TryParse(cc[1].Value.Trim(), out oke[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (orbital energy & kinetic energy) : Can not parse kinetic energy to double.");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total kinetic energy information.");
                    if (ivf != bfn) throw new ArgumentOutOfRangeException("ivf/bfn", "GLogRead (orbital energy & kinetic energy): Can not verify orbital number.");
                    //Console.WriteLine("A : oke[0]={0}", oke[0]);//debug用
                    s2lmke = oke[s2lmei];
                    slmke = oke[slmei];
                    lmke = oke[lmei];
                    hmke = oke[hmei];
                    shmke = oke[shmei];
                    s2hmke = oke[s2hmei];
                    //Console.WriteLine("KO : s2lmke={0}\tslmke={1}\tlmke={2}\r\nhmke={3}\tshmke={4}\ts2hmke={5}", s2lmke, slmke, lmke, hmke, shmke, s2hmke);//debug用
                    m = GLogReg.r46.Match(s);//総軌道エネルギーと運動エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r46.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find orbital energy & kinetic energy information.");
                    gc = m.Groups;
                    if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect total orbital kinetic energy information format.");
                    sb.Clear();
                    sb.Append(gc[1].Captures[0].Value);
                    sb.Append("E");
                    sb.Append(gc[2].Captures[0].Value);
                    if (!double.TryParse(sb.ToString(), out toke)) throw new ArgumentOutOfRangeException("sb", "GLogRead : Can not parse total orbital kinetic energy to double.");
                    //Console.WriteLine("E : toke={0}", toke);//debug用
                    if (fuckedstructure)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r97.Match(s ?? emstm);//精確/近似分極率情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r97.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find exact/approx polarizability information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            if (cnt >= 2) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Unexpected polarizability information.");
                            gc = m.Groups;
                            if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect exact/approx polarizability information format.");
                            if (gc[1].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect exact/approx polarizability information format.");
                            cc = gc[2].Captures;
                            if (cc.Count != 6) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect exact/approx polarizability information format.");
                            switch (gc[1].Captures[0].Value.ToUpperInvariant())
                            {
                                case "EXACT":
                                    {
                                        Epol = new double[3, 3];
                                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[0, 0] = dtemp;
                                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[0, 1] = dtemp;
                                        Epol[1, 0] = dtemp;
                                        if (!double.TryParse(cc[2].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[1, 1] = dtemp;
                                        if (!double.TryParse(cc[3].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[0, 2] = dtemp;
                                        Epol[2, 0] = dtemp;
                                        if (!double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[1, 2] = dtemp;
                                        Epol[2, 1] = dtemp;
                                        if (!double.TryParse(cc[5].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[2, 2] = dtemp;
                                        break;
                                    }
                                case "APPROX":
                                    {
                                        Apol = new double[3, 3];
                                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[0, 0] = dtemp;
                                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[0, 1] = dtemp;
                                        Apol[1, 0] = dtemp;
                                        if (!double.TryParse(cc[2].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[1, 1] = dtemp;
                                        if (!double.TryParse(cc[3].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[0, 2] = dtemp;
                                        Apol[2, 0] = dtemp;
                                        if (!double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[1, 2] = dtemp;
                                        Apol[2, 1] = dtemp;
                                        if (!double.TryParse(cc[5].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[2, 2] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Unknown polarizability type.");
                            }
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r97.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full mass-weighted force constant matrix: information.");
                        if (cnt != 2) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Can not verify exact/approx polarizability information number.");
                        //Console.WriteLine("KI : Epol[0,0]={0}\tEpol[1,1]={1}\tEpol[2,2]={2}\r\nApol[0,0]={3}\tApol[1,1]={4}\tApol[2,2]={5}", Epol[0, 0], Epol[1, 1], Epol[2, 2], Apol[0, 0], Apol[1, 1], Apol[2, 2]);//debug用
                    }
                    s = sr.ReadLine();
                    m = GLogReg.r12.Match(s ?? emstm);//ESP(Merz-Kollman)分割線を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r12.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP information.");
                    s = sr.ReadLine();
                    m = GLogReg.r47.Match(s ?? emstm);//ESP(Merz-Kollman)タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r47.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP title.");
                    s = sr.ReadLine();
                    m = GLogReg.r48.Match(s ?? emstm);//ESP電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r48.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//ESP電荷インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP charge index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect ESP charge index format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect ESP charge index format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//ESP電荷情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP charge information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect ESP charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (ESP charge) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (ESP charge) : Can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect ESP charge information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1 || !cc[0].Value.Trim().Equals(na.fthLfP(als[cnt]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]/als", "GLogRead (ESP charge) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect ESP charge information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out ESPc[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse ESP charge to double.");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge title.");
                    if (ivf != an) throw new ArgumentOutOfRangeException("ivf/an", "GLogRead (ESP charge) : Can not verify atom number.");
                    //Console.WriteLine("KO : ESPc[0]={0}", ESPc[0]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r49.Match(s ?? emstm);//ESP重原子電荷タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r49.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge title.");
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//ESP重原子電荷インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge index.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect heavy atom ESP charge index format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect heavy atom ESP charge index format.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//ESP重原子電荷情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom ESP charge information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect heavy atom ESP charge information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (heavy atom ESP charge) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (heavy atom ESP charge) : Can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect heavy atom ESP charge information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1 || !cc[0].Value.Trim().Equals(na.fthLfP(als[cnt]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]/als", "GLogRead (heavy atom ESP charge) : Can not verify atom lable.");
                        cc = gc[5].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect heavy atom ESP charge information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out ESPch[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse heavy atom ESP charge to double.");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP total charge & dipole information.");
                    if (ivf != han) throw new ArgumentOutOfRangeException("ivf/han", "GLogRead (heavy atom ESP charge) : Can not verify heavy atom number.");
                    //Console.WriteLine("A : ESPch[0]={0}", ESPch[0]);//debug用
                    m = GLogReg.r50.Match(s);//ESP総電荷＆双極子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r50.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find ESP total charge & dipole information.");
                    gc = m.Groups;
                    if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect ESP total charge & dipole information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse ESP total charge to double.");
                    if (Math.Abs(dtemp) > 0.0001) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : ESP total charge is not 0.");
                    ESPdip = new double[3];
                    cc = gc[2].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdip[0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse ESP dipole X to double.");
                    cc = gc[3].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdip[1])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Can not parse ESP dipole Y to double.");
                    cc = gc[4].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdip[2])) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Can not parse ESP dipole Z to double.");
                    cc = gc[5].Captures;
                    if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ESPdipt)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse ESP dipole to double.");
                    //Console.WriteLine("KI : dtemp={0}\tESPdipx={1}\r\nESPdipy{2}\tESPdipz{3}\tESPdipt{4}", dtemp, ESPdip[0], ESPdip[1], ESPdip[2], ESPdipt);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r51.Match(s ?? emstm);//原子電位タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r51.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric potential title.");
                    s = sr.ReadLine();
                    m = GLogReg.r18.Match(s ?? emstm);//原子電位情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric potential information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 6) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect electric potential information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (electric potential) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (electric potential) : Can not verify atom number.");
                        if (gc[2].Captures.Count != 0 || gc[3].Captures.Count != 0) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect electric potential information format.");
                        cc = gc[4].Captures;
                        if (cc.Count != 1 || !cc[0].Value.Trim().Equals("Atom", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead : Incorrect electric potential information format.");
                        cc = gc[5].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Incorrect electric potential information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out aep[cnt])) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead : Can not parse electric potential to double.");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r18.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO information.");
                    if (ivf != an) throw new ArgumentOutOfRangeException("ivf/an", "GLogRead (electric potential) : Can not verify atom number.");
                    //Console.WriteLine("SU : aep[0]={0}", aep[0]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r52.Match(s ?? emstm);//NBOタイトル1を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r52.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO title1.");
                    s = sr.ReadLine();
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO title2.");
                    m = GLogReg.r53.Match(s);
                    if (!m.Success) throw new ArgumentNullException("m", "GLogRead : Can not find NBO title2.");
                    s = sr.ReadLine();
                    m = GLogReg.r54.Match(s ?? emstm);//NAOタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r54.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NAO title.");
                    s = sr.ReadLine();
                    m = GLogReg.r55.Match(s ?? emstm);//NAOインデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r55.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NAO index.");
                    s = sr.ReadLine();
                    m = GLogReg.r56.Match(s ?? emstm);//NAO情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r56.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NAO information.");
                    cnt = 0;
                    cnt2 = 0;
                    itemp2 = 1;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 8) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NAO information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse NAO number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead : Can not verify NAO number.");
                        cc = gc[2].Captures;
                        cc2 = gc[3].Captures;
                        if (cc2.Count != 1 || !int.TryParse(cc2[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (NAO) : Can not parse atom number to int.");
                        if (itemp2 != itemp)
                        {
                            cnt2++;
                            if (aobl[cnt2] != cnt) throw new ArgumentOutOfRangeException("aobl/cnt", "GLogRead (NAO) : Can not verify atom orbital boundary.");
                        }
                        if (cc.Count != 1 || !na.fthLfP(als[cnt2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (NAO) : Can not verify atom lable.");
                        itemp2 = itemp;
                        if (cnt >= (itemp == an ? bfn : aobl[itemp]) || cnt < aobl[cnt2]) throw new ArgumentOutOfRangeException("aobl/cnt", "GLogRead (NAO) : Can not verify NAO number.");
                        if (gc[4].Captures.Count != 1 || gc[5].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[4]/gc[5]", "GLogRead : Incorrect NAO information format.");
                        cc = gc[6].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead : Incorrect NAO information format.");
                        switch (cc[0].Value.ToUpperInvariant())
                        {
                            case "COR":
                                {
                                    if (naot[cnt] != true) throw new ArgumentOutOfRangeException("gc[6]/naot", "GLogRead (NAO) : Can not verify NAO type.");
                                    break;
                                }
                            case "VAL":
                                {
                                    if (naot[cnt] != false) throw new ArgumentOutOfRangeException("gc[6]/naot", "GLogRead (NAO) : Can not verify NAO type.");
                                    break;
                                }
                            case "RYD":
                                {
                                    if (naot[cnt] != null) throw new ArgumentOutOfRangeException("gc[6]/naot", "GLogRead (NAO) : Can not verify NAO type.");
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[6]", "GLogRead (NAO) : Unknown NAO type.");
                        }
                        cc = gc[7].Captures;
                        if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead : Incorrect NAO information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out naooc[cnt])) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead (NAO) : Can not parse occupancy to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out naoen[cnt])) throw new ArgumentOutOfRangeException("gc[6]", "GLogRead (NAO) : Can not parse energy to double.");
                        cnt++;
                        s = sr.ReadLine();
                        if (s.Trim() == emstm) s = sr.ReadLine();
                        m = GLogReg.r56.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis title.");
                    //Console.WriteLine("SU : naooc[0]={0}\tnaoen[0]={1}\tnaot[0]={2}", naooc[0], naoen[0], naot[0]);//debug用
                    m = GLogReg.r57.Match(s);//自然電子密度まとめタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r57.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis title.");
                    s = sr.ReadLine();
                    m = GLogReg.r58.Match(s ?? emstm);//自然電子密度まとめインデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r58.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis index.");
                    s = sr.ReadLine();
                    m = GLogReg.r59.Match(s ?? emstm);//自然電子密度まとめ情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r59.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find summary of natural population analysis information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect summary of natural population analysis information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !na.fthLfP(als[cnt]).Equals(cc[0].Value.Trim(), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[1]/als", "GLogRead (summary of natural population analysis) : Can not verify atom lable.");
                        cc = gc[2].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (summary of natural population analysis) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[2]/cnt", "GLogRead (summary of natural population analysis) : Can not verify atom number.");
                        cc = gc[3].Captures;
                        if (cc.Count != 5) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Incorrect summary of natural population analysis information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out nch[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural charge to double.");
                        if (!double.TryParse(cc[1].Value.Trim(), out npc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural population of core to double.");
                        if (!double.TryParse(cc[2].Value.Trim(), out npv[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural population of valence to double.");
                        if (!double.TryParse(cc[3].Value.Trim(), out npr[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse natural population of Rydberg to double.");
                        if (!double.TryParse(cc[4].Value.Trim(), out npt[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (summary of natural population analysis) : Can not parse total natural population to double.");
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r59.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total natural population analysis information.");
                    if (ivf != an) throw new ArgumentOutOfRangeException("ivf/an", "GLogRead (summary of natural population analysis) : Can not verify atom number.");
                    //Console.WriteLine("E : nch[0]={0}\tnpc[0]={1}\r\nnpv[0]={2}\tnpr[0]={3}\tnpt[0]={4}", nch[0], npc[0], npv[0], npr[0], npt[0]);//debug用
                    m = GLogReg.r60.Match(s);//総自然電子密度タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r60.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total natural population analysis title.");
                    s = sr.ReadLine();
                    m = GLogReg.r61.Match(s ?? emstm);//総自然電子密度情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r61.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find total natural population analysis information.");
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect total natural population analysis information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect total natural population analysis information format.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (total natural population analysis) : Can not parse natural population to double.");
                        if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (total natural population analysis) : Can not parse natural population ratio to double.");
                        if (gc[4].Captures.Count != 1 || !(int.TryParse(gc[4].Captures[0].Value, out itemp) || gc[4].Captures[0].Value.Equals("***", StringComparison.InvariantCultureIgnoreCase))) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (total natural population analysis) : Can not parse electron summation to int.");
                        dtemp /= 100;
                        switch (cc[0].Value.Trim().ToUpperInvariant())
                        {
                            case "CORE":
                                {
                                    npcr = dtemp;
                                    break;
                                }
                            case "VALENCE":
                                {
                                    npvr = dtemp;
                                    break;
                                }
                            case "NATURAL MINIMAL BASIS":
                                {
                                    nmbr = dtemp;
                                    break;
                                }
                            case "NATURAL RYDBERG BASIS":
                                {
                                    nrbr = dtemp;
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (total natural population analysis) : Unknown information.");
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r61.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find natural electron configuration information.");
                    if (npcr == 0 || npvr == 0 || nmbr == 0 || nrbr == 0) throw new ArgumentOutOfRangeException("npcr/npvr/nmbr/nrbr", "GLogRead (total natural population analysis) : Incorrect ratio.");
                    //Console.WriteLine("KO : npcr={0}\tnpvr={1}\r\nnpbr={2}\tnrbr={3}", npcr, npvr, nmbr, nrbr);//debug用
                    m = GLogReg.r62.Match(s ?? emstm);//自然電子配置タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r62.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find natural electron configuration title.");
                    s = sr.ReadLine();
                    m = GLogReg.r63.Match(s ?? emstm);//自然電子配置情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r63.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find natural electron configuration information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect natural electron configuration information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !na.fthLfP(als[cnt]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (natural electron configuration information) : Can not verify atom lable.");
                        cc = gc[2].Captures;
                        if (cc.Count != 1 || !int.TryParse(cc[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (natural electron configuration information) : Can not parse atom number to int.");
                        if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("ivf/cnt", "GLogRead (natural electron configuration information) : Can not verify atom number.");
                        cc = gc[3].Captures;
                        cc2 = gc[4].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead : Incorrect natural electron configuration information format.");
                        if (cc[0].Value.Equals("2S", StringComparison.InvariantCultureIgnoreCase))
                        {
                            necns[cnt] = 0;
                            if (!double.TryParse(cc2[0].Value, out nec2s[cnt])) throw new ArgumentOutOfRangeException("cc2", "GLogRead (natural electron configuration information) : Can not parse 2S electron to double.");
                        }
                        else if (cc[0].Value.Equals("3S", StringComparison.InvariantCultureIgnoreCase) || cc[0].Value.Equals("4S", StringComparison.InvariantCultureIgnoreCase) || cc[0].Value.Equals("5S", StringComparison.InvariantCultureIgnoreCase) || cc[0].Value.Equals("6S", StringComparison.InvariantCultureIgnoreCase))
                        {
                            nec2s[cnt] = 0;
                            if (!double.TryParse(cc2[0].Value, out necns[cnt])) throw new ArgumentOutOfRangeException("cc2", "GLogRead (natural electron configuration information) : Can not parse nS electron to double.");
                        }
                        else
                        {
                            nec2s[cnt] = 0;
                            necns[cnt] = 0;
                        }
                        if (cc[1].Value.Equals("2p", StringComparison.InvariantCultureIgnoreCase))
                        {
                            necnp[cnt] = 0;
                            if (!double.TryParse(cc2[1].Value, out nec2p[cnt])) throw new ArgumentOutOfRangeException("cc2", "GLogRead (natural electron configuration information) : Can not parse 2p electron to double.");
                        }
                        else if (cc[1].Value.Equals("3p", StringComparison.InvariantCultureIgnoreCase) || cc[1].Value.Equals("4p", StringComparison.InvariantCultureIgnoreCase) || cc[1].Value.Equals("5p", StringComparison.InvariantCultureIgnoreCase) || cc[1].Value.Equals("6p", StringComparison.InvariantCultureIgnoreCase))
                        {
                            nec2p[cnt] = 0;
                            if (!double.TryParse(cc2[1].Value, out necnp[cnt])) throw new ArgumentOutOfRangeException("cc2", "GLogRead (natural electron configuration information) : Can not parse np electron to double.");
                        }
                        else
                        {
                            nec2p[cnt] = 0;
                            necnp[cnt] = 0;
                        }
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r63.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis information.");
                    if (ivf != han) throw new ArgumentOutOfRangeException("ivf/han", "GLogRead (natural electron configuration information) : Can not verify atom number.");
                    //Console.WriteLine("I : nec2s[0]={0}\tnec2p[0]={1}", nec2s[0], nec2p[0]);//debug用
                    m = GLogReg.r64.Match(s ?? emstm);//自然結合軌道分析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r64.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis title.");
                    cnt = 0;
                    s = sr.ReadLine();
                    m = GLogReg.r61.Match(s ?? emstm);//（非）ルイス電子情報を探す
                    m2 = GLogReg.r65.Match(s ?? emstm);//自然結合テーブルタイトルを探す
                    while (s != null && !m2.Success)
                    {
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect (non-)Lewis electron information format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect (non-)Lewis electron information format.");
                            if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead ((non-)Lewis electron) : Can not parse electron to double.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead ((non-)Lewis electron) : Can not parse electron ratio to double.");
                            if (gc[4].Captures.Count != 1 || !(int.TryParse(gc[4].Captures[0].Value, out itemp) || gc[4].Captures[0].Value.Equals("***", StringComparison.InvariantCultureIgnoreCase))) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead ((non-)Lewis electron) : Can not parse electron summation to int.");
                            dtemp /= 100;
                            switch (cc[0].Value.Trim().ToUpperInvariant())
                            {
                                case "CORE":
                                    {
                                        cnt++;
                                        break;
                                    }
                                case "VALENCE LEWIS":
                                    {
                                        cnt++;
                                        nbvl = dtemp;
                                        break;
                                    }
                                case "TOTAL LEWIS":
                                    {
                                        cnt++;
                                        nbtl = dtemp;
                                        break;
                                    }
                                case "VALENCE NON-LEWIS":
                                    {
                                        cnt++;
                                        nbvnl = dtemp;
                                        break;
                                    }
                                case "RYDBERG NON-LEWIS":
                                    {
                                        cnt++;
                                        nbrnl = dtemp;
                                        break;
                                    }
                                case "TOTAL NON-LEWIS":
                                    {
                                        cnt++;
                                        nbtnl = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException("gc[3]", "GLogRead ((non-)Lewis electron) : Unknown information.");
                            }
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r61.Match(s ?? emstm);
                        m2 = GLogReg.r65.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis table.");
                    if (nbvl == 0 || nbtl == 0 || nbvnl == 0 || nbrnl == 0 || nbtnl == 0) throw new ArgumentOutOfRangeException("npcr/npvr/nmbr/nrbr", "GLogRead ((non-)Lewis electron) : Incorrect ratio.");
                    if (cnt != 6) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Incorrect (non-)Lewis electron information format.");
                    //Console.WriteLine("SU : nbvl={0}\tnbtl={1}\r\nnbvnl={2}\tnbrnl={3}\tnbtnl={4}", nbvl, nbtl, nbvnl, nbrnl, nbtnl);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r66.Match(s ?? emstm);//自然結合軌道テーブル情報1を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r66.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO analysis title.");
                    m2 = GLogReg.r68.Match(s);//NHO方向＆結合曲がりタイトルを探す
                    cnt = 0;//一中心NBOカウンター
                    cnt2 = 0;//二中心NBOカウンター
                    scnt = 0;//NBOインデックス
                    nboi1l = new List<short>();//一中心NBOインデックス一時リスト
                    nboi2l = new List<short>();//二中心NBOインデックス一時リスト
                    List<double> nboo1l = new List<double>();//一中心NBO占有数一時リスト
                    List<double> nboo2l = new List<double>();//二中心NBO占有数一時リスト
                    nbot1l = new List<string>();//一中心NBOタイプ一時リスト
                    nbot2l = new List<string>();//二中心NBOタイプ一時リスト
                    nbok1l = new List<byte>();//一中心NBO数え一時リスト
                    nbok2l = new List<byte>();//二中心NBO数え一時リスト
                    nbon1l = new List<int>();//一中心NBO原子インデックス一時リスト
                    nbon21l = new List<int>();//二中心NBO原子インデックス1一時リスト
                    nbon22l = new List<int>();//二中心NBO原子インデックス2一時リスト
                    List<double> nbos1l = new List<double>();//一中心NBOs軌道混合率一時リスト
                    List<double> nbop1l = new List<double>();//一中心NBOp軌道混合率一時リスト
                    List<double> nbod1l = new List<double>();//一中心NBOd軌道混合率一時リスト
                    List<double> nbos21l = new List<double>();//二中心NBOs軌道混合率1一時リスト
                    List<double> nbos22l = new List<double>();//二中心NBOs軌道混合率2一時リスト
                    List<double> nbop21l = new List<double>();//二中心NBOp軌道混合率1一時リスト
                    List<double> nbop22l = new List<double>();//二中心NBOp軌道混合率2一時リスト
                    List<double> nbod21l = new List<double>();//二中心NBOd軌道混合率1一時リスト
                    List<double> nbod22l = new List<double>();//二中心NBOd軌道混合率2一時リスト
                    List<double> nbor21l = new List<double>();//二中心NBO原子混合率1一時リスト
                    List<double> nbor22l = new List<double>();//二中心NBO原子混合率2一時リスト
                    while (s != null && !m2.Success)
                    {
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 12) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NBO table format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 1 || !short.TryParse(cc[0].Value, out stemp)) throw new ArgumentNullException("gc[1]", "GLogRead (NBO table) : Can not parse NBO index to short.");
                            if (stemp != scnt + 1) throw new ArgumentOutOfRangeException("stemp/scnt", "GLogRead (NBO table) : Can not verify NBO index.");
                            if (gc[7].Captures.Count == 1 && gc[8].Captures.Count == 1 && gc[9].Captures.Count == 0 && gc[10].Captures.Count == 0 && gc[11].Captures.Count == 0)//二中心
                            {
                                nboi2l.Add(stemp);
                                if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse occupancy to double.", stemp));
                                nboo2l.Add(dtemp);
                                if (gc[3].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (NBO table)([{0}]) : Incorrect NBO type format.", stemp));
                                nbot2l.Add(gc[3].Captures[0].Value);
                                if (gc[4].Captures.Count != 1 || !byte.TryParse(gc[4].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse kazoe to byte.", stemp));
                                nbok2l.Add(btemp);
                                if (gc[5].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead ([{0}]) : Incorrect NBO atom lable format.", stemp));
                                if (gc[6].Captures.Count != 1 || !int.TryParse(gc[6].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                itemp--;
                                if (!na.fthLfP(als[itemp]).Equals(gc[5].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                nbon21l.Add(itemp);
                                if (!int.TryParse(gc[8].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[8]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                itemp--;
                                if (!na.fthLfP(als[itemp]).Equals(gc[7].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[7]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                nbon22l.Add(itemp);
                                cnt3 = 0;
                                while (s != null && cnt3 < 2)
                                {
                                    s = sr.ReadLine();
                                    m2 = GLogReg.r67.Match(s ?? emstm);//初期自然結合軌道テーブル情報2を探す
                                    if (m2.Success)
                                    {
                                        cnt3++;
                                        gc = m2.Groups;
                                        if (gc.Count != 7) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NBO table format.");
                                        if (gc[1].Captures.Count != 1 || !double.TryParse(gc[1].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom ratio to double.", stemp));
                                        if (gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead ([{0}]) : Incorrect NBO atom lable format.", stemp));
                                        if (gc[3].Captures.Count != 1 || !int.TryParse(gc[3].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                        itemp--;
                                        dtemp /= 100;
                                        if (na.fthLfP(als[itemp]).Equals(gc[5].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                        if (cnt3 == 1)
                                        {
                                            if (itemp != nbon21l[cnt2]) throw new ArgumentOutOfRangeException("itemp/nbon21", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                            nbor21l.Add(dtemp);
                                            if (gc[4].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[4].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse s hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbos21l.Add(dtemp);
                                            }
                                            else nbos21l.Add(0);
                                            if (gc[5].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[5].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse p hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbop21l.Add(dtemp);
                                            }
                                            else nbop21l.Add(0);
                                            if (gc[6].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[6].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse d hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbod21l.Add(dtemp);
                                            }
                                            else nbod21l.Add(0);
                                        }
                                        else if (cnt3 == 2)
                                        {
                                            if (itemp != nbon22l[cnt2]) throw new ArgumentOutOfRangeException("itemp/nbon22", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                            nbor22l.Add(dtemp);
                                            if (gc[4].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[4].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse s hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbos22l.Add(dtemp);
                                            }
                                            else nbos22l.Add(0);
                                            if (gc[5].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[5].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse p hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbop22l.Add(dtemp);
                                            }
                                            else nbop22l.Add(0);
                                            if (gc[6].Captures.Count == 1)
                                            {
                                                if (!double.TryParse(gc[6].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse d hybrid ratio to double.", stemp));
                                                dtemp /= 100;
                                                nbod22l.Add(dtemp);
                                            }
                                            else nbod22l.Add(0);
                                        }
                                    }
                                }
                                if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO table subinformation.");
                                cnt2++;
                            }
                            else if (gc[7].Captures.Count == 0 && gc[8].Captures.Count == 0)//一中心
                            {
                                nboi1l.Add(stemp);
                                if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse occupancy to double.", stemp));
                                nboo1l.Add(dtemp);
                                if (gc[3].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[3]", string.Format("GLogRead ([{0}]) : Incorrect NBO type format.", stemp));
                                nbot1l.Add(gc[3].Captures[0].Value);
                                if (gc[4].Captures.Count != 1 || !byte.TryParse(gc[4].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[4]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse kazoe to byte.", stemp));
                                nbok1l.Add(btemp);
                                if (gc[5].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[5]", string.Format("GLogRead ([{0}]) : Incorrect NBO atom lable format.", stemp));
                                if (gc[6].Captures.Count != 1 || !int.TryParse(gc[6].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[6]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse atom number to int.", stemp));
                                itemp--;
                                if (!na.fthLfP(als[itemp]).Equals(gc[5].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[5]", string.Format("GLogRead (NBO table)([{0}]) : Can not verify atom.", stemp));
                                nbon1l.Add(itemp);
                                if (gc[9].Captures.Count == 1)
                                {
                                    if (!double.TryParse(gc[9].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[9]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse s hybrid ratio to double.", stemp));
                                    dtemp /= 100;
                                    nbos1l.Add(dtemp);
                                }
                                else nbos1l.Add(0);
                                if (gc[10].Captures.Count == 1)
                                {
                                    if (!double.TryParse(gc[10].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[10]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse p hybrid ratio to double.", stemp));
                                    dtemp /= 100;
                                    nbop1l.Add(dtemp);
                                }
                                else nbop1l.Add(0);
                                if (gc[11].Captures.Count == 1)
                                {
                                    if (!double.TryParse(gc[11].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[11]", string.Format("GLogRead (NBO table)([{0}]) : Can not parse d hybrid ratio to double.", stemp));
                                    dtemp /= 100;
                                    nbod1l.Add(dtemp);
                                }
                                else nbod1l.Add(0);
                                cnt++;
                            }
                            else throw new ArgumentOutOfRangeException("gc[7/8/9/10/11]", string.Format("GLogRead ([{0}]): Incorrect NBO table format.", stemp));
                            scnt++;
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r66.Match(s ?? emstm);
                        m2 = GLogReg.r68.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO & bond bending information.");
                    if (cnt + cnt2 != bfn || scnt != bfn) throw new ArgumentOutOfRangeException("cnt/cnt2/scnt/bfn", "GLogRead (NBO table) : Can not verify NBO number.");
                    nbo1n = cnt;
                    nbo2n = cnt2;
                    if (nboi1l.Count != nbo1n || nbot1l.Count != nbo1n || nbok1l.Count != nbo1n || nbon1l.Count != nbo1n) throw new ArgumentOutOfRangeException("nbo1n/nboi1l/nbot1l/nbok1l/nbon1l", "GLogRead (NBO table) : Can not verify 1 center NBO number.");
                    nboi1 = nboi1l.ToArray();
                    nbot1 = nbot1l.ToArray();
                    nbok1 = nbok1l.ToArray();
                    nbon1 = nbon1l.ToArray();
                    if (nboi2l.Count != nbo2n || nbot2l.Count != nbo2n || nbok2l.Count != nbo2n || nbon21l.Count != nbo2n || nbon22l.Count != nbo2n) throw new ArgumentOutOfRangeException("nbo2n/nboi2l/nbot2l/nbok2l/nbon21l/nbon22l", "GLogRead (NBO table) : Can not verify 2 center NBO number.");
                    nboi2 = nboi2l.ToArray();
                    nbot2 = nbot2l.ToArray();
                    nbok2 = nbok2l.ToArray();
                    nbon21 = nbon21l.ToArray();
                    nbon22 = nbon22l.ToArray();
                    nbor21 = nbor21l.ToArray();
                    nbor22 = nbor22l.ToArray();
                    nboo1 = nboo1l.ToArray();
                    nboo2 = nboo2l.ToArray();
                    nbos1 = nbos1l.ToArray();
                    nbop1 = nbop1l.ToArray();
                    nbod1 = nbod1l.ToArray();
                    nbos21 = nbos21l.ToArray();
                    nbos22 = nbos22l.ToArray();
                    nbop21 = nbop21l.ToArray();
                    nbop22 = nbop22l.ToArray();
                    nbod21 = nbod21l.ToArray();
                    nbod22 = nbod22l.ToArray();
                    //Console.WriteLine("A : nboo1[0]={0}\tnboo2[0]={1}\r\nnbos1[0]={2}\tnbop1[0]={3}\tnbod1[0]={4}\r\nnbos21[0]={5}\tnbop21[0]={6}\tnbod21[0]={7}\r\nnbos22[0]={8}\tnbop22[0]={9}\tnbod22[0]={10}\r\nnbor21[0]={11}\tnbor22[0]={12}", nboo1[0], nboo2[0], nbos1[0], nbop1[0], nbod1[0], nbos21[0], nbop21[0], nbod21[0], nbos22[0], nbop22[0], nbod22[0], nbor21[0], nbor22[0]);//debug用
                    //Console.WriteLine("A : nboi1[0]={0}\tnboi2[0]={1}\r\nnbot1[0]={2}\tnbot2[0]={3}\r\nnbok1[0]={4}\tnbok2[0]={5}\r\nnbon1[0]={6}\tnbon21[0]={7}\r\nnbon22[0]={8}", nboi1[0], nboi2[0], nbot1[0], nbot2[0], nbok1[0], nbok2[0], nbon1[0], nbon21[0], nbon22[0]);//debug用
                    nboi1l = null;
                    nboi2l = null;
                    nbot1l = null;
                    nbot2l = null;
                    nbok1l = null;
                    nbok2l = null;
                    nbon1l = null;
                    nbon21l = null;
                    nbon22l = null;
                    nboo1l = null;
                    nboo2l = null;
                    nbos1l = null;
                    nbop1l = null;
                    nbod1l = null;
                    nbos21l = null;
                    nbos22l = null;
                    nbop21l = null;
                    nbop22l = null;
                    nbod21l = null;
                    nbod22l = null;
                    nbor21l = null;
                    nbor22l = null;
                    nboe1 = new double[nbo1n];
                    nboe2 = new double[nbo2n];
                    s = sr.ReadLine();
                    m = GLogReg.r69.Match(s ?? emstm);//NHO方向＆結合曲がりインデックス1を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r69.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO/bond bending index 1.");
                    s = sr.ReadLine();
                    m = GLogReg.r70.Match(s ?? emstm);//NHO方向＆結合曲がりインデックス2を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r70.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO/bond bending index 2.");
                    s = sr.ReadLine();
                    m = GLogReg.r71.Match(s ?? emstm);//NHO方向＆結合曲がり情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r71.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NHO/bond bending information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 9) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NHO/bond bending information format.");
                        cc = gc[6].Captures;
                        cc2 = gc[7].Captures;
                        if (cc.Count != cc2.Count) throw new ArgumentOutOfRangeException("gc[6]/gc[7]", "GLogRead : Incorrect NHO/bond bending information format.");
                        if (cc.Count == 0)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r71.Match(s ?? emstm);
                            continue;
                        }
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !short.TryParse(cc[0].Value, out stemp)) throw new ArgumentNullException("gc[1]", "GLogRead (NHO/bond bending) : Can not parse NHO index to short.");
                        nhonl.Add(stemp);
                        cc = gc[2].Captures;
                        itemp = Array.FindIndex(nboi2, (short n) => { return n == stemp; });
                        if (itemp == -1) throw new ArgumentOutOfRangeException("gc[2]", string.Format("GLogRead (NHO/bond bending) : Can not find NHO[{0}] in nboi2.", stemp));
                        if (cc.Count != 1 || !nbot2[itemp].Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentNullException("gc[2]/nbot2", "GLogRead (NHO/bond bending) : Can not verify NHO type.");
                        cc = gc[3].Captures;
                        if (cc.Count != 1 || !byte.TryParse(cc[0].Value, out btemp)) throw new ArgumentNullException("gc[3]", "GLogRead (NHO/bond bending) : Can not parse NHO kazoe to short.");
                        if (nbok2[itemp] != btemp) throw new ArgumentNullException("gc[3]/nbok2", "GLogRead (NHO/bond bending) : Can not verify NHO kazoe.");
                        cc = gc[4].Captures;
                        cc2 = gc[5].Captures;
                        itemp2 = nbon21[itemp];
                        if (cc2.Count != 1 || !int.TryParse(cc2[0].Value, out itemp3)) throw new ArgumentNullException("gc[5]", "GLogRead (NHO/bond bending) : Can not parse NHO atom number 1 to int.");
                        if (itemp2 != itemp3 - 1) throw new ArgumentOutOfRangeException("gc[5]/nbon21", "GLogRead (NHO/bond bending) : Can not verify NHO atom number 1.");
                        if (cc.Count != 1 || !na.fthLfP(als[itemp2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[4]/als", "GLogRead (NHO/bond bending) : Can not verify NHO atom lable 1.");
                        cc = gc[6].Captures;
                        cc2 = gc[7].Captures;
                        itemp2 = nbon22[itemp];
                        if (cc2.Count != 1 || !int.TryParse(cc2[0].Value, out itemp3)) throw new ArgumentNullException("gc[7]", "GLogRead (NHO/bond bending) : Can not parse NHO atom number 2 to int.");
                        if (itemp2 != itemp3 - 1) throw new ArgumentOutOfRangeException("gc[7]/nbon22", "GLogRead (NHO/bond bending) : Can not verify NHO atom number 2.");
                        if (cc.Count != 1 || !na.fthLfP(als[itemp2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[6]/als", "GLogRead (NHO/bond bending) : Can not verify NHO atom lable 2.");
                        cc = gc[8].Captures;
                        if (cc.Count != 8) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead : Incorrect NHO/bond bending information format.");
                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentNullException("cc[0]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] LoC Theta to double.", stemp));
                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentNullException("cc[1]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] LoC Phi to double.", stemp));
                        if (double.TryParse(cc[2].Value, out dtemp))
                        {
                            if (!double.TryParse(cc[3].Value, out dtemp)) throw new ArgumentNullException("cc[3]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid1 Phi to double.", stemp));
                            if (!double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentNullException("cc[4]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid1 Dev to double.", stemp));
                            nhod1l.Add(dtemp);
                        }
                        else if (double.TryParse(cc[3].Value, out dtemp) || double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentNullException("cc[2]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid1 Theta to double.", stemp));
                        else
                        {
                            if (btemp == 1) nhod1l.Add(0);
                            else nhod1l.Add(90);
                        }
                        if (double.TryParse(cc[5].Value, out dtemp))
                        {
                            if (!double.TryParse(cc[6].Value, out dtemp)) throw new ArgumentNullException("cc[6]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid2 Phi to double.", stemp));
                            if (!double.TryParse(cc[7].Value, out dtemp)) throw new ArgumentNullException("cc[7]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid2 Dev to double.", stemp));
                            nhod2l.Add(dtemp);
                        }
                        else if (double.TryParse(cc[6].Value, out dtemp) || double.TryParse(cc[7].Value, out dtemp)) throw new ArgumentNullException("cc[5]", string.Format("GLogRead (NHO/bond bending) : Can not parse NHO[{0}] Hybrid2 Theta to double.", stemp));
                        else
                        {
                            if (btemp == 1) nhod2l.Add(0);
                            else nhod2l.Add(90);
                        }
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r71.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find second order perturbation theory analysis information.");
                    if (nhonl.Count != cnt || nhod1l.Count != cnt || nhod2l.Count != cnt) throw new ArgumentOutOfRangeException("nhonl/nhod1l/nhod2l/cnt", "GLogRead (NHO/bond bending) : Can not verify NHO number.");
                    nhon = nhonl.ToArray();
                    nhod1 = nhod1l.ToArray();
                    nhod2 = nhod2l.ToArray();
                    //Console.WriteLine("E : cnt={0}\tnhon[0]={1}\r\nnhod1[0]={2}\tnhod2[0]={3}", cnt, nhon[0], nhod1[0], nhod2[0]);//debug用
                    nhonl = null;
                    nhod1l = null;
                    nhod2l = null;
                    s = sr.ReadLine();
                    m = GLogReg.r72.Match(s ?? emstm);//二次摂動理論分析タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r72.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find second order perturbation theory analysis title.");
                    s = sr.ReadLine();
                    m = GLogReg.r73.Match(s ?? emstm);//二次摂動理論分析情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r73.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find second order perturbation theory analysis information.");
                    m2 = GLogReg.r74.Match(s);//NBOまとめタイトルを探す
                    cnt = 0;
                    while (s != null && !m2.Success)
                    {
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 9) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 2) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            if (cc[0].Value == "***")
                            {
                                flg = null;
                                itemp2 = 0;
                                if (!byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO kazoe to byte.");
                                if (!int.TryParse(gc[5].Captures[0].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                itemp--;
                                if (gc[6].Captures[0].Value == emstm && gc[7].Captures[0].Value == emstm)
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon1, itemp2, (int i) => { return i == itemp; });
                                        if (itemp2 == -1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO information.");
                                        if (nbok1[itemp2] == btemp)
                                        {
                                            if (nbot1[itemp2].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase))
                                            {
                                                stemp = nboi1[itemp2];
                                                flg = true;
                                                break;
                                            }
                                        }
                                        itemp2++;
                                    }
                                }
                                else
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon21, itemp2, (int i) => { return i == itemp; });
                                        if (itemp2 == -1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO information.");
                                        if (!int.TryParse(gc[7].Captures[0].Value, out itemp3)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                        itemp3--;
                                        if (itemp3 == nbon22[itemp2])
                                        {
                                            if (nbok2[itemp2] == btemp)
                                            {
                                                if (nbot2[itemp2].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase))
                                                {
                                                    stemp = nboi2[itemp2];
                                                    flg = true;
                                                    break;
                                                }
                                            }
                                        }
                                        itemp2++;
                                    }
                                }
                                if (flg == null) throw new ArgumentNullException("flg", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO information.");
                            }
                            else if (!short.TryParse(cc[0].Value, out stemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO index to short.");
                            sopdl.Add(stemp);
                            if (cc[1].Value == "***")
                            {
                                flg = null;
                                itemp2 = 0;
                                if (!byte.TryParse(gc[3].Captures[1].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO kazoe to byte.");
                                if (!int.TryParse(gc[5].Captures[1].Value, out itemp)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom number to int.");
                                itemp--;
                                if (gc[6].Captures[1].Value == emstm && gc[7].Captures[1].Value == emstm)
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon1, itemp2, (int i) => { return i == itemp; });
                                        if (itemp2 == -1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO information.");
                                        if (nbok1[itemp2] == btemp)
                                        {
                                            if (nbot1[itemp2].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase))
                                            {
                                                scnt = nboi1[itemp2];
                                                flg = true;
                                                break;
                                            }
                                        }
                                        itemp2++;
                                    }
                                }
                                else
                                {
                                    while (flg == null)
                                    {
                                        itemp2 = Array.FindIndex(nbon21, itemp2, (int i) => { return i == itemp; });
                                        if (itemp2 == -1) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO information.");
                                        if (!int.TryParse(gc[7].Captures[1].Value, out itemp3)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom number to int.");
                                        itemp3--;
                                        if (itemp3 == nbon22[itemp2])
                                        {
                                            if (nbok2[itemp2] == btemp)
                                            {
                                                if (nbot2[itemp2].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase))
                                                {
                                                    scnt = nboi2[itemp2];
                                                    flg = true;
                                                    break;
                                                }
                                            }
                                        }
                                        itemp2++;
                                    }
                                }
                                if (flg == null) throw new ArgumentNullException("flg", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO information.");
                            }
                            else if (!short.TryParse(cc[1].Value, out scnt)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO index to short.");
                            sopal.Add(scnt);
                            if (gc[2].Captures.Count != 2 || gc[3].Captures.Count != 2 || gc[4].Captures.Count != 2 || gc[5].Captures.Count != 2 || gc[6].Captures.Count != 2 || gc[7].Captures.Count != 2) throw new ArgumentOutOfRangeException("gc[2/3/4/5/6/7]", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            cc = gc[6].Captures;
                            cc2 = gc[7].Captures;
                            if (cc[0].Value == emstm && cc2[0].Value == emstm)
                            {
                                itemp = Array.FindIndex(nboi1, (short n) => { return n == stemp; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi1/stemp", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO index.");
                                if (!nbot1[itemp].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot1/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO kazoe to byte.");
                                if (nbok1[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok1/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[0].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom number to int.");
                                itemp2--;
                                if (nbon1[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon1/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom lable.");
                            }
                            else
                            {
                                itemp = Array.FindIndex(nboi2, (short n) => { return n == stemp; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi2/stemp", "GLogRead (second order perturbation theory analysis) : Can not find donor NBO index.");
                                if (!nbot2[itemp].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot2/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO kazoe to byte.");
                                if (nbok2[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok2/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[0].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom 1 number to int.");
                                itemp2--;
                                if (nbon21[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon21/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 1 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 1 lable.");
                                if (!int.TryParse(cc2[0].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[7]", "GLogRead (second order perturbation theory analysis) : Can not parse donor NBO atom 2 number to int.");
                                itemp2--;
                                if (nbon22[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon22/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 2 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[6]", "GLogRead (second order perturbation theory analysis) : Can not verify donor NBO atom 2 lable.");
                            }
                            if (cc[1].Value == emstm && cc2[1].Value == emstm)
                            {
                                itemp = Array.FindIndex(nboi1, (short n) => { return n == scnt; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi1/stemp", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO index.");
                                if (!nbot1[itemp].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot1/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[1].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO kazoe to byte.");
                                if (nbok1[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok1/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[1].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom number to int.");
                                itemp2--;
                                if (nbon1[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon1/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom lable.");
                            }
                            else
                            {
                                itemp = Array.FindIndex(nboi2, (short n) => { return n == scnt; });
                                if (itemp == -1) throw new ArgumentOutOfRangeException("nboi2/stemp", "GLogRead (second order perturbation theory analysis) : Can not find acceptor NBO index.");
                                if (!nbot2[itemp].Equals(gc[2].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot2/gc[2]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO type.");
                                if (!byte.TryParse(gc[3].Captures[1].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO kazoe to byte.");
                                if (nbok2[itemp] != btemp) throw new ArgumentOutOfRangeException("nbok2/btemp", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO kazoe.");
                                if (!int.TryParse(gc[5].Captures[1].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom 1 number to int.");
                                itemp2--;
                                if (nbon21[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon21/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 1 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(gc[4].Captures[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 1 lable.");
                                if (!int.TryParse(cc2[1].Value, out itemp2)) throw new ArgumentOutOfRangeException("gc[7]", "GLogRead (second order perturbation theory analysis) : Can not parse acceptor NBO atom 2 number to int.");
                                itemp2--;
                                if (nbon22[itemp] != itemp2) throw new ArgumentOutOfRangeException("nbon22/itemp2", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 2 number.");
                                if (!na.fthLfP(als[itemp2]).Equals(cc[1].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[6]", "GLogRead (second order perturbation theory analysis) : Can not verify acceptor NBO atom 2 lable.");
                            }
                            cc = gc[8].Captures;
                            if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead : Incorrect second order perturbation theory analysis information format.");
                            if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (second order perturbation theory analysis) : Can not parse E(2) to double.");
                            sopel.Add(dtemp);
                            if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (second order perturbation theory analysis) : Can not parse E(j)-E(i) to double.");
                            if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (second order perturbation theory analysis) : Can not parse F(i,j) to double.");
                            cnt++;
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r73.Match(s ?? emstm);
                        m2 = GLogReg.r74.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO summary information.");
                    if (sopdl.Count != cnt || sopal.Count != cnt || sopel.Count != cnt) throw new ArgumentOutOfRangeException("sopdl/sopal/sopel/cnt", "GLogRead (second order perturbation theory analysis) : Can not verify amount.");
                    sopd = sopdl.ToArray();
                    sopa = sopal.ToArray();
                    sope = sopel.ToArray();
                    //Console.WriteLine("E : cnt={0}\tsopd[0]={1}\r\nsopa[0]={2}\tsope[0]={3}", cnt, sopd[0], sopa[0], sope[0]);//debug用
                    sopdl = null;
                    sopal = null;
                    sopel = null;
                    s = sr.ReadLine();
                    m = GLogReg.r75.Match(s ?? emstm);//NBOまとめインデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r75.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO summary index.");
                    s = sr.ReadLine();
                    m = GLogReg.r76.Match(s ?? emstm);//NBOまとめ情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r76.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find NBO summary information.");
                    cnt = 0;//一中心
                    cnt2 = 0;//二中心
                    scnt = 0;//トータル
                    if (!fuckedstructure) m2 = GLogReg.r3.Match(s);//分割線を探す
                    else m2 = GLogReg.r98.Match(s);
                    while (s != null && !m2.Success)
                    {
                        if (m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 10) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect NBO summary information format.");
                            cc = gc[6].Captures;
                            cc2 = gc[7].Captures;
                            if (cc.Count == 0 && cc2.Count == 0)
                            {
                                if (gc[1].Captures.Count != 1 || !short.TryParse(gc[1].Captures[0].Value, out svf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (NBO summary) : Can not parse NBO index to short.");
                                cnt4 = Array.FindIndex(nboi1, (i) => { return i == svf; });
                                if (gc[2].Captures.Count != 1 || !nbot1[cnt4].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot1/gc[2]", "GLogRead (NBO summary) : Can not verify NBO type.");
                                if (gc[3].Captures.Count != 1 || !byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (NBO summary) : Can not parse NBO kazoe to byte.");
                                if (nbok1[cnt4] != btemp) throw new ArgumentOutOfRangeException("nbok1/btemp", "GLogRead (NBO summary) : Can not verify NBO kazoe.");
                                if (gc[5].Captures.Count != 1 || !int.TryParse(gc[5].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (NBO summary) : Can not parse NBO atom number to int.");
                                ivf--;
                                if (nbon1[cnt4] != ivf) throw new ArgumentOutOfRangeException("nbon1/gc[5]", "GLogRead (NBO summary) : Can not verify NBO atom number.");
                                if (!na.fthLfP(als[ivf]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (NBO summary) : Can not verify NBO atom lable.");
                                if (gc[8].Captures.Count != 1 || !double.TryParse(gc[8].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (NBO summary) : Can not parse NBO occupancy to double.");
                                if (dtemp != nboo1[cnt4]) throw new ArgumentOutOfRangeException("gc[8]/nboo1", "GLogRead (NBO summary) : Can not verify NBO occupancy.");
                                if (gc[9].Captures.Count != 1 || !double.TryParse(gc[9].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[9]", "GLogRead (NBO summary) : Can not parse NBO energy to double.");
                                nboe1[cnt4] = dtemp;
                                cnt++;
                            }
                            else if (cc.Count == 1 && cc2.Count == 1)
                            {
                                if (gc[1].Captures.Count != 1 || !short.TryParse(gc[1].Captures[0].Value, out svf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (NBO summary) : Can not parse NBO index to short.");
                                cnt4 = Array.FindIndex(nboi2, (i) => { return i == svf; });
                                if (gc[2].Captures.Count != 1 || !nbot2[cnt4].Equals(gc[2].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("nbot2/gc[2]", "GLogRead (NBO summary) : Can not verify NBO type.");
                                if (gc[3].Captures.Count != 1 || !byte.TryParse(gc[3].Captures[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (NBO summary) : Can not parse NBO kazoe to byte.");
                                if (nbok2[cnt4] != btemp) throw new ArgumentOutOfRangeException("nbok2/btemp", "GLogRead (NBO summary) : Can not verify NBO kazoe.");
                                if (gc[5].Captures.Count != 1 || !int.TryParse(gc[5].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[5]", "GLogRead (NBO summary) : Can not parse NBO atom 1 number to int.");
                                ivf--;
                                if (nbon21[cnt4] != ivf) throw new ArgumentOutOfRangeException("nbon21/gc[5]", "GLogRead (NBO summary) : Can not verify NBO atom 1 number.");
                                if (!na.fthLfP(als[ivf]).Equals(gc[4].Captures[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[4]", "GLogRead (NBO summary) : Can not verify NBO atom 1 lable.");
                                if (!int.TryParse(cc2[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[7]", "GLogRead (NBO summary) : Can not parse NBO atom 2 number to int.");
                                ivf--;
                                if (nbon22[cnt4] != ivf) throw new ArgumentOutOfRangeException("nbon22/gc[7]", "GLogRead (NBO summary) : Can not verify NBO atom 2 number.");
                                if (!na.fthLfP(als[ivf]).Equals(cc[0].Value, StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("als/gc[6]", "GLogRead (NBO summary) : Can not verify NBO atom 2 lable.");
                                if (gc[8].Captures.Count != 1 || !double.TryParse(gc[8].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[8]", "GLogRead (NBO summary) : Can not parse NBO occupancy to double.");
                                if (dtemp != nboo2[cnt4]) throw new ArgumentOutOfRangeException("gc[8]/nboo2", "GLogRead (NBO summary) : Can not verify NBO occupancy.");
                                if (gc[9].Captures.Count != 1 || !double.TryParse(gc[9].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[9]", "GLogRead (NBO summary) : Can not parse NBO energy to double.");
                                nboe2[cnt4] = dtemp;
                                cnt2++;
                            }
                            else throw new ArgumentOutOfRangeException("gc[6]/gc[7]", "GLogRead : Incorrect NBO summary information format.");
                            scnt++;
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r76.Match(s ?? emstm);
                        if (!fuckedstructure) m2 = GLogReg.r3.Match(s ?? emstm);
                        else m2 = GLogReg.r98.Match(s);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optimization information or full mass-weighted force constant matrix information.");
                    if (cnt != nbo1n || cnt2 != nbo2n || scnt != bfn) throw new ArgumentOutOfRangeException("cnt/nbo1n//cnt2/nbo2n//scnt/bfn", "GLogRead (NBO summary) : Can not verify NBO number.");
                    //Console.WriteLine("SU : cnt={0}\tcnt2={1}\tscnt={2}\r\nnboe1[0]={3}\tnboe2[0]={4}", cnt, cnt2, scnt, nboe1[0], nboe2[0]);//debug用
                    if (!fuckedstructure)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r9.Match(s ?? emstm);//標準配座情報タイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r9.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find standard orientation title.");
                        s = sr.ReadLine();
                        m = GLogReg.r11.Match(s ?? emstm);//回転定数情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r11.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find rotational constants information.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (rotational constants) : Incorrect rotational constants information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (rotational constants) : Incorrect rotational constants information format.");
                        if (!double.TryParse(cc[0].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (rotational constants) : Can not parse rotational constants.");
                        if (dtemp != rc[0]) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (rotational constants) : Can not verify rotational constants.");
                        if (!double.TryParse(cc[1].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (rotational constants) : Can not parse rotational constants.");
                        if (dtemp != rc[1]) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (rotational constants) : Can not verify rotational constants.");
                        if (!double.TryParse(cc[2].Value.Trim(), out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (rotational constants) : Can not parse rotational constants.");
                        if (dtemp != rc[2]) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (rotational constants) : Can not verify rotational constants.");
                        //Console.WriteLine("E : rc[0]={0}\trc[1]={1}\trc[2]={2}", rc[0], rc[1], rc[2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r79.Match(s ?? emstm);//核反発エネルギー情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r79.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find nuclear repulsion energy information.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect nuclear repulsion energy information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out nre)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse nuclear repulsion energy to double.");
                        //Console.WriteLine("KI : nre={0}", nre);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r80.Match(s ?? emstm);//自己無撞着場エネルギー情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r80.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find SCF energy information.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect SCF energy information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out scfe)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse SCF energy to double.");
                        //Console.WriteLine("KO : scfe={0}", scfe);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r81.Match(s ?? emstm);//GIAO磁気遮蔽テンソルタイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r81.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find GIAO Magnetic shielding tensor information.");
                        s = sr.ReadLine();
                        m = GLogReg.r82.Match(s ?? emstm);//GIAO等方/異方磁気遮蔽情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r82.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find GIAO Magnetic shielding tensor information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 5) throw new ArgumentOutOfRangeException("gc", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor information format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse atom index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]/ivf", "GLogRead (GIAO) : Can not verify atom index.");
                            if (cnt >= an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead (GIAO) : Redundant atom detected.");
                            if (gc[2].Captures.Count != 1 || !gc[2].Captures[0].Value.Equals(na.fthLfP(als[cnt]), StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not verify atom lable.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out gmsi[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (GIAO) : Can not parse isotropic to double.");
                            if (gc[4].Captures.Count != 1 || !double.TryParse(gc[4].Captures[0].Value, out gmsa[cnt])) throw new ArgumentOutOfRangeException("gc[4]", "GLogRead (GIAO) : Can not parse anisotropic to double.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                s = sr.ReadLine();
                                if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead (GIAO) ({0}) : GIAO Magnetic shielding tensor information is not sufficient.", cnt));
                                m = GLogReg.r83.Match(s);//GIAO磁気遮蔽テンソル情報を探す
                                if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                                gc = m.Groups;
                                if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                                cc = gc[1].Captures;
                                cc2 = gc[2].Captures;
                                if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("cc/cc2", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                                for (cnt3 = 0; cnt3 < 3; cnt3++)
                                {
                                    switch (cc[cnt3].Value)
                                    {
                                        case "XX":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 0, 0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor XX to double.");
                                                break;
                                            }
                                        case "XY":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 0, 1])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor XY to double.");
                                                break;
                                            }
                                        case "XZ":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 0, 2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor XZ to double.");
                                                break;
                                            }
                                        case "YX":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 1, 0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor YX to double.");
                                                break;
                                            }
                                        case "YY":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 1, 1])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor YY to double.");
                                                break;
                                            }
                                        case "YZ":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 1, 2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor YZ to double.");
                                                break;
                                            }
                                        case "ZX":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 2, 0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor ZX to double.");
                                                break;
                                            }
                                        case "ZY":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 2, 1])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor ZY to double.");
                                                break;
                                            }
                                        case "ZZ":
                                            {
                                                if (!double.TryParse(cc2[cnt3].Value, out gmst[cnt, 2, 2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding tensor ZZ to double.");
                                                break;
                                            }
                                    }
                                }
                            }
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead (GIAO) ({0}) : GIAO Magnetic shielding tensor information is not sufficient.", cnt));
                            m = GLogReg.r84.Match(s);//GIAO磁気遮蔽固有値情報を探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Incorrect GIAO magnetic shielding tensor format.");
                            if (!double.TryParse(cc[0].Value, out gmse[cnt, 0])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding eigenvalue 1 to double.");
                            if (!double.TryParse(cc[1].Value, out gmse[cnt, 1])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding eigenvalue 2 to double.");
                            if (!double.TryParse(cc[2].Value, out gmse[cnt, 2])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (GIAO) : Can not parse GIAO magnetic shielding eigenvalue 3 to double.");
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r82.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find GIAO Magnetic shielding tensor information.");
                        if (cnt != an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead (GIAO) : Can not verify atom number.");
                        //Console.WriteLine("KO : gmsi[0]={0}\tgmsa[0]={1}\r\ngmst[0,0,0]={2}\tgmst[0,1,2]={3}\r\ngmse[0,0]={4}\tgmse[0,1]={5}\tgmse[0,2]={6}", gmsi[0], gmsa[0], gmst[0, 0, 0], gmst[0, 1, 2], gmse[0, 0], gmse[0, 1], gmse[0, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r85.Match(s ?? emstm);//等方性分極率情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r85.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find isotropic polarizability information.");
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect isotropic polarizability information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : W is not 0.");
                        cc = gc[2].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out ispo)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (isotropic polarizability) : Can not parse isotropic polarizability to double.");
                        //Console.WriteLine("I : ispo={0}", ispo);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r86.Match(s ?? emstm);//磁気双極子分極率タイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r86.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole-magnetic dipole polarizability title.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect isotropic polarizability title format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (isotropic polarizability) : W is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r87.Match(s ?? emstm);//磁気双極子分極率インデックスを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r87.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole-magnetic dipole polarizability index.");
                        dmdp = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead ({0}) : Dipole-magnetic dipole polarizability tensor information is not sufficient.", cnt));
                            m = GLogReg.r88.Match(s);//磁気双極子分極率テンソルを探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect dipole-magnetic dipole polarizability tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect dipole-magnetic dipole polarizability tensor format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (dipole-magnetic dipole polarizability tensor) : Can not parse row index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (dipole-magnetic dipole polarizability tensor) : Can not verify row index.");
                            cc = gc[2].Captures;
                            cc2 = gc[3].Captures;
                            if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect dipole-magnetic dipole polarizability tensor format.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                sb.Clear();
                                sb.Append(cc[cnt2].Value);
                                sb.Append("E");
                                sb.Append(cc2[cnt2].Value);
                                if (!double.TryParse(sb.ToString(), out dmdp[cnt, cnt2])) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead (dipole-magnetic dipole polarizability tensor) : Can not parse coefficient to double.");
                            }
                        }
                        //Console.WriteLine("SU : dmdp[0,0]={0}\tdmdp[1,1]={1}\tdmdp[2,2]={2}", dmdp[0, 0], dmdp[1, 1], dmdp[2, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r89.Match(s ?? emstm);//DQタイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r89.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find DQ title.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect DQtitle format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ) : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ) : W is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r87.Match(s ?? emstm);//DQインデックスを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r87.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find DQ index.");
                        dqct = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead ({0}) : DQ tensor information is not sufficient.", cnt));
                            m = GLogReg.r88.Match(s);//DQテンソルを探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect DQ tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect DQ tensor format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ tensor) : Can not parse row index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (DQ tensor) : Can not verify row index.");
                            cc = gc[2].Captures;
                            cc2 = gc[3].Captures;
                            if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect DQ tensor format.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                sb.Clear();
                                sb.Append(cc[cnt2].Value);
                                sb.Append("E");
                                sb.Append(cc2[cnt2].Value);
                                if (!double.TryParse(sb.ToString(), out dqct[cnt, cnt2])) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead (DQ tensor) : Can not parse coefficient to double.");
                            }
                        }
                        //Console.WriteLine("I : dqct[0,0]={0}\tdqct[1,1]={1}\tdqct[2,2]={2}", dqct[0, 0], dqct[1, 1], dqct[2, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r90.Match(s ?? emstm);//旋光Gタイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r90.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' title.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' title format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G') : Can not parse W to double.");
                        if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G') : W is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r87.Match(s ?? emstm);//DQインデックスを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r87.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' index.");
                        orgt = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentOutOfRangeException("s", string.Format("GLogRead ({0}) : Optical rotation G' tensor information is not sufficient.", cnt));
                            m = GLogReg.r88.Match(s);//DQテンソルを探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect optical rotation G' tensor format.");
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' tensor format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G' tensor) : Can not parse row index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (optical rotation G' tensor) : Can not verify row index.");
                            cc = gc[2].Captures;
                            cc2 = gc[3].Captures;
                            if (cc.Count != 3 || cc2.Count != 3) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead : Incorrect optical rotation G' tensor format.");
                            for (cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                sb.Clear();
                                sb.Append(cc[cnt2].Value);
                                sb.Append("E");
                                sb.Append(cc2[cnt2].Value);
                                if (!double.TryParse(sb.ToString(), out orgt[cnt, cnt2])) throw new ArgumentOutOfRangeException("gc[2]/gc[3]", "GLogRead (optical rotation G' tensor) : Can not parse coefficient to double.");
                            }
                        }
                        //Console.WriteLine("A : orgt[0,0]={0}\torgt[1,1]={1}\torgt[2,2]={2}", orgt[0, 0], orgt[1, 1], orgt[2, 2]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r91.Match(s ?? emstm);//旋光G固有値とiso旋光G情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r91.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' eigenvalue and iso.");
                        orge = new double[3];
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' eigenvalue and iso format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect optical rotation G' eigenvalue format.");
                        if (!double.TryParse(cc[0].Value, out orge[0])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvalue 1 to double.");
                        if (!double.TryParse(cc[1].Value, out orge[1])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvalue 2 to double.");
                        if (!double.TryParse(cc[2].Value, out orge[2])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvalue 3 to double.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out orgi)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse iso optical rotation G' to double.");
                        //Console.WriteLine("A : orge[0]={0}\torge[1]={1}\torge[2]={2}\r\norgi={3}", orge[0], orge[1], orge[2], orgi);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r92.Match(s ?? emstm);//旋光G固有ベクトル情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r92.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find optical rotation G' eigenvector information.");
                        orgev = new double[3, 3];
                        for (cnt = 0; cnt < 3; cnt++)
                        {
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Optical rotation G' eigenvector information is insufficient.");
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect optical rotation G' eigenvector information format.");
                            gc = m.Groups;
                            if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect optical rotation G' eigenvector information format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect optical rotation G' eigenvector information format.");
                            if (!double.TryParse(cc[0].Value, out orgev[0, cnt])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvector 1 to double.");
                            if (!double.TryParse(cc[1].Value, out orgev[1, cnt])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvector 2 to double.");
                            if (!double.TryParse(cc[2].Value, out orgev[2, cnt])) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse optical rotation G' eigenvector 3 to double.");
                            s = sr.ReadLine();
                            m = GLogReg.r92.Match(s ?? emstm);
                        }
                        //Console.WriteLine("KI : orgev[0,0]={0}\torgev[1,2]={1}\torgev[2,2]={2}", orgev[0, 0], orgev[1, 2], orgev[2, 2]);//debug用
                        m = GLogReg.r93.Match(s ?? emstm);//分子量とalpha D情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r93.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find molar mass and alpha D information.");
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect molar mass and alpha D information format.");
                        if (gc[1].Captures.Count != 1 || !double.TryParse(gc[1].Captures[0].Value, out Mmass)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse molar mass to double.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out AlphaD)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse alpha D to double.");
                        s = sr.ReadLine();
                        m = GLogReg.r94.Match(s ?? emstm);//APT電荷タイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r94.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find APT charge information.");
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);//APT電荷情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find APT charge information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect APT charge information format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (APT charge) : Can not parse atom index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (APT charge) : Can not verify atom index.");
                            if (ivf > an) throw new ArgumentOutOfRangeException("an/ivf", "GLogRead (APT charge) : Redundant atom detected.");
                            if (gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect APT charge information format.");
                            if (!na.fthLfP(als[cnt]).Equals(gc[2].Captures[0].Value)) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (APT charge) : Can not verify atom lable.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out APTc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (APT charge) : Can not parse charge to double.");
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of APT charge information.");
                        if (cnt != an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead (APT charge) : Can not verify atom number.");
                        //Console.WriteLine("SU : APTc[0]={0}", APTc[0]);//debug用
                        m = GLogReg.r95.Match(s ?? emstm);//APT総電荷情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r95.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of APT charge information.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect sum of APT charge information format.");
                        if (gc[1].Captures.Count != 1 || !double.TryParse(gc[1].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (sum of APT charge) : Can not parse charge to double.");
                        if (Math.Abs(dtemp) > 0.0001) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Sum of APT charge is not 0.");
                        s = sr.ReadLine();
                        m = GLogReg.r96.Match(s ?? emstm);//APT重原子電荷タイトルを探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r96.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of heavy atom APT charge information.");
                        s = sr.ReadLine();
                        m = GLogReg.r24.Match(s ?? emstm);//APT重原子電荷情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find heavy atom APT charge information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            gc = m.Groups;
                            if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect heavy atom APT charge information format.");
                            if (gc[1].Captures.Count != 1 || !int.TryParse(gc[1].Captures[0].Value, out ivf)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (heavy atom APT charge) : Can not parse atom index to int.");
                            if (ivf != cnt + 1) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (heavy atom APT charge) : Can not verify atom index.");
                            if (ivf > han) throw new ArgumentOutOfRangeException("han/ivf", "GLogRead (heavy atom APT charge) : Redundant atom detected.");
                            if (gc[2].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect heavy atom APT charge information format.");
                            if (!na.fthLfP(als[cnt]).Equals(gc[2].Captures[0].Value)) throw new ArgumentOutOfRangeException("cnt/ivf", "GLogRead (heavy atom APT charge) : Can not verify atom lable.");
                            if (gc[3].Captures.Count != 1 || !double.TryParse(gc[3].Captures[0].Value, out APThc[cnt])) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead (heavy atom APT charge) : Can not parse charge to double.");
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r24.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find exact/approx polarizability information.");
                        if (cnt != han) throw new ArgumentOutOfRangeException("cnt/han", "GLogRead (heavy atom APT charge) : Can not verify atom number.");
                        //Console.WriteLine("E : APThc[0]={0}", APThc[0]);//debug用
                        s = sr.ReadLine();
                        m = GLogReg.r97.Match(s ?? emstm);//精確/近似分極率情報を探す
                        while (s != null && !m.Success)
                        {
                            s = sr.ReadLine();
                            m = GLogReg.r97.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find exact/approx polarizability information.");
                        cnt = 0;
                        while (s != null && m.Success)
                        {
                            if (cnt >= 2) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Unexpected polarizability information.");
                            gc = m.Groups;
                            if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect exact/approx polarizability information format.");
                            if (gc[1].Captures.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect exact/approx polarizability information format.");
                            cc = gc[2].Captures;
                            if (cc.Count != 6) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect exact/approx polarizability information format.");
                            switch (gc[1].Captures[0].Value.ToUpperInvariant())
                            {
                                case "EXACT":
                                    {
                                        Epol = new double[3, 3];
                                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[0, 0] = dtemp;
                                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[0, 1] = dtemp;
                                        Epol[1, 0] = dtemp;
                                        if (!double.TryParse(cc[2].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[1, 1] = dtemp;
                                        if (!double.TryParse(cc[3].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[0, 2] = dtemp;
                                        Epol[2, 0] = dtemp;
                                        if (!double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[1, 2] = dtemp;
                                        Epol[2, 1] = dtemp;
                                        if (!double.TryParse(cc[5].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (exact polarizability) : Can not parse polarizability to double.");
                                        Epol[2, 2] = dtemp;
                                        break;
                                    }
                                case "APPROX":
                                    {
                                        Apol = new double[3, 3];
                                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[0, 0] = dtemp;
                                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[0, 1] = dtemp;
                                        Apol[1, 0] = dtemp;
                                        if (!double.TryParse(cc[2].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[1, 1] = dtemp;
                                        if (!double.TryParse(cc[3].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[0, 2] = dtemp;
                                        Apol[2, 0] = dtemp;
                                        if (!double.TryParse(cc[4].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[1, 2] = dtemp;
                                        Apol[2, 1] = dtemp;
                                        if (!double.TryParse(cc[5].Value, out dtemp)) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (approx polarizability) : Can not parse polarizability to double.");
                                        Apol[2, 2] = dtemp;
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Unknown polarizability type.");
                            }
                            cnt++;
                            s = sr.ReadLine();
                            m = GLogReg.r97.Match(s ?? emstm);
                        }
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full mass-weighted force constant matrix: information.");
                        if (cnt != 2) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Can not verify exact/approx polarizability information number.");
                        //Console.WriteLine("KI : Epol[0,0]={0}\tEpol[1,1]={1}\tEpol[2,2]={2}\r\nApol[0,0]={3}\tApol[1,1]={4}\tApol[2,2]={5}", Epol[0, 0], Epol[1, 1], Epol[2, 2], Apol[0, 0], Apol[1, 1], Apol[2, 2]);//debug用
                    }
                    m = GLogReg.r98.Match(s ?? emstm);//弾力定数タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r98.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full mass-weighted force constant matrix information.");
                    s = sr.ReadLine();
                    m = GLogReg.r99.Match(s ?? emstm);//弾力定数行列情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r99.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find full mass-weighted force constant matrix information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect full mass-weighted force constant matrix information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 6) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect full mass-weighted force constant matrix information format.");
                    mwfc = new double[9];
                    if (!double.TryParse(cc[0].Value, out mwfc[0])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[1].Value, out mwfc[1])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[2].Value, out mwfc[2])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[3].Value, out mwfc[3])) throw new ArgumentOutOfRangeException("cc[3]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[4].Value, out mwfc[4])) throw new ArgumentOutOfRangeException("cc[4]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[5].Value, out mwfc[5])) throw new ArgumentOutOfRangeException("cc[5]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    s = sr.ReadLine();
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Full mass-weighted force constant matrix information is insufficient.");
                    m = GLogReg.r99.Match(s);
                    if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect full mass-weighted force constant matrix information format.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect full mass-weighted force constant matrix information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect full mass-weighted force constant matrix information format.");
                    if (!double.TryParse(cc[0].Value, out mwfc[6])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[1].Value, out mwfc[7])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[2].Value, out mwfc[8])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (full mass-weighted force constant matrix) : Can not parse frequency to double.");
                    //Console.WriteLine("KI : mwfc[2]={0}\tmwfc[5]={1}", mwfc[2], mwfc[5]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r100.Match(s ?? emstm);//対角振動分極率タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r100.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find diagonal vibrational polarizability information.");
                    s = sr.ReadLine();
                    m = GLogReg.r101.Match(s ?? emstm);//対角振動分極率情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r101.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find normal coordinate information.");
                    dvp = new double[3];
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect diagonal vibrational polarizability information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect diagonal vibrational polarizability information format.");
                    if (!double.TryParse(cc[0].Value, out dvp[0])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (diagonal vibrational polarizability) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[1].Value, out dvp[1])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (diagonal vibrational polarizability) : Can not parse frequency to double.");
                    if (!double.TryParse(cc[2].Value, out dvp[2])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (diagonal vibrational polarizability) : Can not parse frequency to double.");
                    //Console.WriteLine("I : dvp[0]={0}\tdvp[1]={1}\tdvp[2]={2}", dvp[0], dvp[1], dvp[2]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r17a.Match(s ?? emstm);//正規座標インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find normal coordinate information.");
                    noco = new double[dof, an, 3];
                    ncfrq = new double[dof];
                    ncrm = new double[dof];
                    ncfc = new double[dof];
                    ncii = new double[dof];
                    ncds = new double[dof];
                    ncrs = new double[dof];
                    ncema = new double[dof];
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        itemp = cnt + 1;
                        itemp2 = cnt + 2;
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect normal coordinate index format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect normal coordinate index format.");
                        if (!int.TryParse(cc[0].Value, out itemp3)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (normal coordinate index) : Can not parse 1st index to int.");
                        if (itemp3 != itemp) throw new ArgumentOutOfRangeException("itemp/itemp3", "GLogRead (normal coordinate index) : Can not verify 1st index.");
                        if (!int.TryParse(cc[1].Value, out itemp3)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (normal coordinate index) : Can not parse 2nd index to int.");
                        if (itemp3 != itemp2) throw new ArgumentOutOfRangeException("itemp2/itemp3", "GLogRead (normal coordinate index) : Can not verify 2nd index.");
                        if (!int.TryParse(cc[2].Value, out itemp3)) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (normal coordinate index) : Can not parse 3rd index to int.");
                        if (itemp3 != cnt + 3) throw new ArgumentOutOfRangeException("cnt+3/itemp3", "GLogRead (normal coordinate index) : Can not verify 3rd index.");
                        s = sr.ReadLine();
                        for (cnt2 = 0; cnt2 < 7; cnt2++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find normal coordinate information.");
                            m = GLogReg.r102.Match(s);//正規座標情報を探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect normal coordinate information format.");
                            gc = m.Groups;
                            if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect normal coordinate information format.");
                            cc = gc[1].Captures;
                            cc2 = gc[2].Captures;
                            if (cc.Count != 1 || cc2.Count != 3) throw new ArgumentOutOfRangeException("gc[1]/gc[2]", "GLogRead : Incorrect normal coordinate information format.");
                            switch (cc[0].Value.Trim().ToUpperInvariant())
                            {
                                case "FREQUENCIES":
                                    {
                                        if (!double.TryParse(cc2[0].Value, out ncfrq[cnt])) throw new ArgumentOutOfRangeException("cc2[0]", "GLogRead (normal coordinate) : Can not parse 1st frequency to double.");
                                        if (!double.TryParse(cc2[1].Value, out ncfrq[itemp])) throw new ArgumentOutOfRangeException("cc2[1]", "GLogRead (normal coordinate) : Can not parse 2nd frequency to double.");
                                        if (!double.TryParse(cc2[2].Value, out ncfrq[itemp2])) throw new ArgumentOutOfRangeException("cc2[2]", "GLogRead (normal coordinate) : Can not parse 3rd frequency to double.");
                                        break;
                                    }
                                case "RED. MASSES":
                                    {
                                        if (!double.TryParse(cc2[0].Value, out ncrm[cnt])) throw new ArgumentOutOfRangeException("cc2[0]", "GLogRead (normal coordinate) : Can not parse 1st reduced mass to double.");
                                        if (!double.TryParse(cc2[1].Value, out ncrm[itemp])) throw new ArgumentOutOfRangeException("cc2[1]", "GLogRead (normal coordinate) : Can not parse 2nd reduced mass to double.");
                                        if (!double.TryParse(cc2[2].Value, out ncrm[itemp2])) throw new ArgumentOutOfRangeException("cc2[2]", "GLogRead (normal coordinate) : Can not parse 3rd reduced mass to double.");
                                        break;
                                    }
                                case "FRC CONSTS":
                                    {
                                        if (!double.TryParse(cc2[0].Value, out ncfc[cnt])) throw new ArgumentOutOfRangeException("cc2[0]", "GLogRead (normal coordinate) : Can not parse 1st force constant to double.");
                                        if (!double.TryParse(cc2[1].Value, out ncfc[itemp])) throw new ArgumentOutOfRangeException("cc2[1]", "GLogRead (normal coordinate) : Can not parse 2nd force constant to double.");
                                        if (!double.TryParse(cc2[2].Value, out ncfc[itemp2])) throw new ArgumentOutOfRangeException("cc2[2]", "GLogRead (normal coordinate) : Can not parse 3rd force constant to double.");
                                        break;
                                    }
                                case "IR INTEN":
                                    {
                                        if (!double.TryParse(cc2[0].Value, out ncii[cnt])) throw new ArgumentOutOfRangeException("cc2[0]", "GLogRead (normal coordinate) : Can not parse 1st IR intensity to double.");
                                        if (!double.TryParse(cc2[1].Value, out ncii[itemp])) throw new ArgumentOutOfRangeException("cc2[1]", "GLogRead (normal coordinate) : Can not parse 2nd force constant to double.");
                                        if (!double.TryParse(cc2[2].Value, out ncii[itemp2])) throw new ArgumentOutOfRangeException("cc2[2]", "GLogRead (normal coordinate) : Can not parse 3rd force constant to double.");
                                        break;
                                    }
                                case "DIP. STR.":
                                    {
                                        if (!double.TryParse(cc2[0].Value, out ncds[cnt])) throw new ArgumentOutOfRangeException("cc2[0]", "GLogRead (normal coordinate) : Can not parse 1st dipole strength to double.");
                                        if (!double.TryParse(cc2[1].Value, out ncds[itemp])) throw new ArgumentOutOfRangeException("cc2[1]", "GLogRead (normal coordinate) : Can not parse 2nd dipole strength to double.");
                                        if (!double.TryParse(cc2[2].Value, out ncds[itemp2])) throw new ArgumentOutOfRangeException("cc2[2]", "GLogRead (normal coordinate) : Can not parse 3rd dipole strength to double.");
                                        break;
                                    }
                                case "ROT. STR.":
                                    {
                                        if (!double.TryParse(cc2[0].Value, out ncrs[cnt])) throw new ArgumentOutOfRangeException("cc2[0]", "GLogRead (normal coordinate) : Can not parse 1st rotational strength to double.");
                                        if (!double.TryParse(cc2[1].Value, out ncrs[itemp])) throw new ArgumentOutOfRangeException("cc2[1]", "GLogRead (normal coordinate) : Can not parse 2nd rotational strength to double.");
                                        if (!double.TryParse(cc2[2].Value, out ncrs[itemp2])) throw new ArgumentOutOfRangeException("cc2[2]", "GLogRead (normal coordinate) : Can not parse 3rd rotational strength to double.");
                                        break;
                                    }
                                case "E-M ANGLE":
                                    {
                                        if (!double.TryParse(cc2[0].Value, out ncema[cnt])) throw new ArgumentOutOfRangeException("cc2[0]", "GLogRead (normal coordinate) : Can not parse 1st E-M angle to double.");
                                        if (!double.TryParse(cc2[1].Value, out ncema[itemp])) throw new ArgumentOutOfRangeException("cc2[1]", "GLogRead (normal coordinate) : Can not parse 2nd E-M angle to double.");
                                        if (!double.TryParse(cc2[2].Value, out ncema[itemp2])) throw new ArgumentOutOfRangeException("cc2[2]", "GLogRead (normal coordinate) : Can not parse 3rd E-M angle to double.");
                                        break;
                                    }
                                default: throw new ArgumentOutOfRangeException("cc", "GLogRead (normal coordinate) : Unknown information type.");
                            }
                        }
                        s = sr.ReadLine();
                        if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find normal coordinate matrix index.");
                        m = GLogReg.r103.Match(s);//正規座標行列インデックスを探す
                        if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect normal coordinate index format.");
                        for (cnt2 = 0; cnt2 < an; cnt2++)
                        {
                            s = sr.ReadLine();
                            if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find normal coordinate matrix information.");
                            m = GLogReg.r104.Match(s);//正規座標行列情報を探す
                            if (!m.Success) throw new ArgumentOutOfRangeException("m", "GLogRead : Incorrect normal coordinate matrix information format.");
                            gc = m.Groups;
                            if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect normal coordinate matrix information format.");
                            cc = gc[1].Captures;
                            if (cc.Count != 2) throw new ArgumentOutOfRangeException("cc", "GLogRead : Incorrect normal coordinate matrix information format.");
                            if (!int.TryParse(cc[0].Value, out itemp3)) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (normal coordinate matrix) : Can not parse atom index to int.");
                            if (itemp3 != cnt2 + 1) throw new ArgumentOutOfRangeException("itemp3/cnt2", "GLogRead (normal coordinate matrix) : Can not verify atom index.");
                            if (!byte.TryParse(cc[1].Value, out btemp)) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (normal coordinate matrix) : Can not parse atom number to byte.");
                            if (btemp != als[cnt2]) throw new ArgumentOutOfRangeException("itemp3/cnt2", "GLogRead (normal coordinate matrix) : Can not verify atom number.");
                            cc = gc[2].Captures;
                            if (cc.Count != 9) throw new ArgumentOutOfRangeException("cc", "GLogRead : Incorrect normal coordinate matrix information format.");
                            if (!double.TryParse(cc[0].Value, out noco[cnt, cnt2, 0])) throw new ArgumentOutOfRangeException("cc[0]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 1st force constant to double.", cnt2));
                            if (!double.TryParse(cc[1].Value, out noco[cnt, cnt2, 1])) throw new ArgumentOutOfRangeException("cc[1]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 2nd force constant to double.", cnt2));
                            if (!double.TryParse(cc[2].Value, out noco[cnt, cnt2, 2])) throw new ArgumentOutOfRangeException("cc[2]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 3rd force constant to double.", cnt2));
                            if (!double.TryParse(cc[3].Value, out noco[itemp, cnt2, 0])) throw new ArgumentOutOfRangeException("cc[3]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 4th force constant to double.", cnt2));
                            if (!double.TryParse(cc[4].Value, out noco[itemp, cnt2, 1])) throw new ArgumentOutOfRangeException("cc[4]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 5th force constant to double.", cnt2));
                            if (!double.TryParse(cc[5].Value, out noco[itemp, cnt2, 2])) throw new ArgumentOutOfRangeException("cc[5]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 6th force constant to double.", cnt2));
                            if (!double.TryParse(cc[6].Value, out noco[itemp2, cnt2, 0])) throw new ArgumentOutOfRangeException("cc[6]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 7th force constant to double.", cnt2));
                            if (!double.TryParse(cc[7].Value, out noco[itemp2, cnt2, 1])) throw new ArgumentOutOfRangeException("cc[7]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 8th force constant to double.", cnt2));
                            if (!double.TryParse(cc[8].Value, out noco[itemp2, cnt2, 2])) throw new ArgumentOutOfRangeException("cc[8]", string.Format("GLogRead (normal coordinate matrix) ({0}) : Can not parse 9th force constant to double.", cnt2));
                        }
                        cnt += 3;
                        s = sr.ReadLine();
                        m = GLogReg.r17a.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find principal axes and moments of inertia information.");
                    if (cnt != dof) throw new ArgumentOutOfRangeException("cnt/dof", "GLogRead (normal coordinate) : Can not verify atom number.");
                    //Console.WriteLine("E : ncfrq[0]={0}\tncrm[1]={1}\tncfc[2]={2}\r\nncii[0]={3}\tncds[1]={4}\tncrs[2]={5}\r\nncema[0]={6}\tnoco[0,0,0]={7}\tnoco[1,0,2]={8}", ncfrq[0], ncrm[1], ncfc[2], ncii[0], ncds[1], ncrs[2], ncema[0], noco[0, 0, 0], noco[1, 0, 2]);//debug用
                    m = GLogReg.r105.Match(s);//慣性主軸と主慣性モーメントタイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r105.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find principal axes and moments of inertia title.");
                    m = GLogReg.r106.Match(s);//慣性主軸情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r106.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find principal axes information.");
                    pax = new double[3, 3];
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        if (cnt >= 3) throw new ArgumentOutOfRangeException("cnt", "GLogRead (principal axes) : Redundant dimension detected.");
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect principal axes information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("cc", "GLogRead : Incorrect principal axes information format.");
                        if (!double.TryParse(cc[0].Value, out pax[cnt, 0])) throw new ArgumentOutOfRangeException("cc[0]", string.Format("GLogRead (principal axes) ({0}) : Can not parse 1st coefficient to double.", cnt));
                        if (!double.TryParse(cc[1].Value, out pax[cnt, 1])) throw new ArgumentOutOfRangeException("cc[1]", string.Format("GLogRead (principal axes) ({0}) : Can not parse 2nd coefficient to double.", cnt));
                        if (!double.TryParse(cc[2].Value, out pax[cnt, 2])) throw new ArgumentOutOfRangeException("cc[2]", string.Format("GLogRead (principal axes) ({0}) : Can not parse 3rd coefficient to double.", cnt));
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r106.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find rotational temperatures information.");
                    //Console.WriteLine("A : pax[0,0]={0}\tpax[1,1]={1}\tpax[2,2]={2}", pax[0, 0], pax[1, 1], pax[2, 2]);//debug用
                    m = GLogReg.r107.Match(s);//回転温度情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r107.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find rotational temperatures information.");
                    rott = new double[3];
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect rotational temperatures information format.");
                    cc = gc[1].Captures;
                    if (cc.Count != 3) throw new ArgumentOutOfRangeException("cc", "GLogRead : Incorrect rotational temperatures information format.");
                    if (!double.TryParse(cc[0].Value, out rott[0])) throw new ArgumentOutOfRangeException("cc[0]", "GLogRead (rotational temperatures) : Can not parse 1st temperature to double.");
                    if (!double.TryParse(cc[1].Value, out rott[1])) throw new ArgumentOutOfRangeException("cc[1]", "GLogRead (rotational temperatures) : Can not parse 2nd temperature to double.");
                    if (!double.TryParse(cc[2].Value, out rott[2])) throw new ArgumentOutOfRangeException("cc[2]", "GLogRead (rotational temperatures) : Can not parse 3rd temperature to double.");
                    //Console.WriteLine("I : rott[0]={0}\trott[1]={1}\trott[2]={2}", rott[0], rott[1], rott[2]);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r108.Match(s ?? emstm);//零点エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r108.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find zero-point vibrational energy information.");
                    gc = m.Groups;
                    if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect zero-point vibrational energy information format.");
                    if (gc[1].Captures.Count != 1 || !double.TryParse(gc[1].Captures[0].Value, out zpve)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Can not parse zero-point vibrational energy to double.");
                    //Console.WriteLine("KO : zpve={0}", zpve);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r109.Match(s ?? emstm);//修正情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r109.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find thermal correction information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect thermal correction information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect thermal correction information format.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse thermal correction to double.");
                        switch (cc[0].Value.ToUpperInvariant())
                        {
                            case "ENERGY":
                                {
                                    tce = dtemp;
                                    break;
                                }
                            case "ENTHALPY":
                                {
                                    tcet = dtemp;
                                    break;
                                }
                            case "GIBBS FREE ENERGY":
                                {
                                    tcg = dtemp;
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Unknown thermal correction information .");
                        }
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r109.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of energies information.");
                    if (cnt != 3) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Can not verify thermal correction information number.");
                    //Console.WriteLine("SU : tce={0}\ttcet={1}\ttcg={2}", tce, tcet, tcg);//debug用
                    m = GLogReg.r110.Match(s);//修正電子エネルギー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r110.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find sum of energies information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect sum of energies information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect sum of energies information format.");
                        if (gc[2].Captures.Count != 1 || !double.TryParse(gc[2].Captures[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse sum of energies to double.");
                        switch (cc[0].Value.ToUpperInvariant())
                        {
                            case "ZERO-POINT ENERGIES":
                                {
                                    sezpe = dtemp;
                                    break;
                                }
                            case "THERMAL ENERGIES":
                                {
                                    sete = dtemp;
                                    break;
                                }
                            case "THERMAL ENTHALPIES":
                                {
                                    setet = dtemp;
                                    break;
                                }
                            case "THERMAL FREE ENERGIES":
                                {
                                    setfe = dtemp;
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Unknown sum of energies information .");
                        }
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r110.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find E/CV/S information.");
                    if (cnt != 4) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Can not verify sum of energies information number.");
                    //Console.WriteLine("SU : sezpe={0}\tsete={1}\tsetet={2}\tsetfe={3}", sezpe, sete, setet, setfe);//debug用
                    s = sr.ReadLine();
                    m = GLogReg.r111.Match(s ?? emstm);//内部エネルギー/等容比熱/エントロピーインデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r111.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find E/CV/S index.");
                    s = sr.ReadLine();
                    m = GLogReg.r112.Match(s ?? emstm);//内部エネルギー/等容比熱/エントロピー情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r112.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find E/CV/S information.");
                    cnt = 0;
                    flg = null;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect E/CV/S information format.");
                        cc2 = gc[1].Captures;
                        if (cc2.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect E/CV/S information format.");
                        cc = gc[2].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect E/CV/S information format.");
                        switch (cc2[0].Value.ToUpperInvariant())
                        {
                            case "TOTAL":
                                {
                                    if (!double.TryParse(cc[0].Value, out ett)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse total E(thermal) to double.");
                                    if (!double.TryParse(cc[1].Value, out cvt)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse total CV to double.");
                                    if (!double.TryParse(cc[2].Value, out stot)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse total S to double.");
                                    break;
                                }
                            case "ELECTRONIC":
                                {
                                    if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse electronic E(thermal) to double.");
                                    if (Math.Abs(dtemp) > 0.001) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electronic E(thermal) is not 0.");
                                    if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse electronic CV to double.");
                                    if (Math.Abs(dtemp) > 0.001) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electronic CV is not 0.");
                                    if (!double.TryParse(cc[2].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse electronic S to double.");
                                    if (Math.Abs(dtemp) > 0.001) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electronic S is not 0.");
                                    break;
                                }
                            case "TRANSLATIONAL":
                                {
                                    if (!double.TryParse(cc[2].Value, out sttr)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse translational S to double.");
                                    if (flg == null)
                                    {
                                        if (!double.TryParse(cc[0].Value, out ettr)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse translational E(thermal) to double.");
                                        if (!double.TryParse(cc[1].Value, out cvtr)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse translational CV to double.");
                                        flg = true;
                                    }
                                    else if (flg == true)
                                    {
                                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse translational E(thermal) to double.");
                                        if (dtemp != ettr) throw new ArgumentOutOfRangeException("dtemp/ettr", "GLogRead : Can not verify translational/rotational E(thermal).");
                                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse translational CV to double.");
                                        if (dtemp != cvtr) throw new ArgumentOutOfRangeException("dtemp/cvtr", "GLogRead : Can not verify translational/rotational CV.");
                                    }
                                    else throw new ArgumentOutOfRangeException("flg", "GLogRead : Unknown flag error.");
                                    break;
                                }
                            case "ROTATIONAL":
                                {
                                    if (!double.TryParse(cc[2].Value, out stro)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse rotational S to double.");
                                    if (flg == null)
                                    {
                                        if (!double.TryParse(cc[0].Value, out ettr)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse rotational E(thermal) to double.");
                                        if (!double.TryParse(cc[1].Value, out cvtr)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse rotational CV to double.");
                                        flg = true;
                                    }
                                    else if (flg == true)
                                    {
                                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse rotational E(thermal) to double.");
                                        if (dtemp != ettr) throw new ArgumentOutOfRangeException("dtemp/ettr", "GLogRead : Can not verify translational/rotational E(thermal).");
                                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse rotational CV to double.");
                                        if (dtemp != cvtr) throw new ArgumentOutOfRangeException("dtemp/cvtr", "GLogRead : Can not verify translational/rotational CV.");
                                    }
                                    else throw new ArgumentOutOfRangeException("flg", "GLogRead : Unknown flag error.");
                                    break;
                                }
                            case "VIBRATIONAL":
                                {
                                    if (!double.TryParse(cc[0].Value, out etv)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse vibrational E(thermal) to double.");
                                    if (!double.TryParse(cc[1].Value, out cvv)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse vibrational CV to double.");
                                    if (!double.TryParse(cc[2].Value, out svib)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Can not parse vibrational S to double.");
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Unknown E/CV/S information detected.");
                        }
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r112.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find low frequency vibration E/CV/S information.");
                    if (cnt != 5) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Can not verify E/CV/S information number.");
                    //Console.WriteLine("KI : ett={0}\tcvt={1}\tstot={2}\r\nettr={3}\tcvtr={4}\tsttr={5}\tstro={6}\r\netv={7}\tcvv={8}\tsvib={9}", ett, cvt, stot, ettr, cvtr, sttr, stro, etv, cvv, svib);//debug用
                    m = GLogReg.r113.Match(s);//低周波数振動E/CV/S情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r113.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find low frequency vibration E/CV/S information.");
                    List<double> lfvel = new List<double>();
                    List<double> lfvcvl = new List<double>();
                    List<double> lfvsl = new List<double>();
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 2) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect low frequency vibration E/CV/S information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect low frequency vibration E/CV/S information format.");
                        if (!double.TryParse(cc[0].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (low frequency vibration) : Can not parse E(thermal) to double.");
                        lfvel.Add(dtemp);
                        if (!double.TryParse(cc[1].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (low frequency vibration) : Can not parse CV to double.");
                        lfvcvl.Add(dtemp);
                        if (!double.TryParse(cc[2].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (low frequency vibration) : Can not parse S to double.");
                        lfvsl.Add(dtemp);
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r113.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find contribution q information.");
                    if (lfvel.Count != lfvcvl.Count || lfvcvl.Count != lfvsl.Count || lfvsl.Count != cnt) throw new ArgumentOutOfRangeException("lfvel/lfvcvl/lfvsl", "GLogRead (low frequency vibration) : Can not verify E/CV/S information number.");
                    lfve = lfvel.ToArray();
                    lfvcv = lfvcvl.ToArray();
                    lfvs = lfvsl.ToArray();
                    lfvn = cnt;
                    lfvel = null;
                    lfvcvl = null;
                    lfvsl = null;
                    //Console.WriteLine("E : lfve[0]={0}\tlfvcv[0]={1}\tlfvs[0]={2}\r\nlfvn={3}", lfve[0], lfvcv[0], lfvs[0], lfvn);//debug用
                    m = GLogReg.r114.Match(s);//分配関数インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r114.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find contribution q index.");
                    s = sr.ReadLine();
                    m = GLogReg.r115.Match(s ?? emstm);//分配関数情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r115.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find contribution q information.");
                    lnqvbs = new double[lfvn];
                    lnqvvs = new double[lfvn];
                    cnt = 0;
                    cnt2 = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect contribution q information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect contribution q information format.");
                        cc2 = gc[2].Captures;
                        itemp = cc2.Count;
                        itemp--;
                        if (itemp < 1) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect contribution q information format.");
                        switch (cc[0].Value.ToUpperInvariant().Trim())
                        {
                            case "TOTAL BOT":
                                {
                                    if (!double.TryParse(cc2[itemp].Value, out lnqtb)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse total BOT to double.");
                                    break;
                                }
                            case "TOTAL V=0":
                                {
                                    if (!double.TryParse(cc2[itemp].Value, out lnqtv)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse TOTAL V=0 to double.");
                                    break;
                                }
                            case "VIB (BOT)":
                                {
                                    if (!int.TryParse(cc2[0].Value, out itemp2))
                                    {
                                        if (!double.TryParse(cc2[itemp].Value, out lnqvb)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse VIB (BOT) to double.");
                                    }
                                    else
                                    {
                                        if (itemp2 != cnt + 1) throw new ArgumentOutOfRangeException("itemp2/cnt", "GLogRead (contribution q) : Can not verify VIB (BOT) index.");
                                        if (!double.TryParse(cc2[itemp].Value, out lnqvbs[cnt])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse low frequency VIB (BOT) to double.");
                                        cnt++;
                                    }
                                    break;
                                }
                            case "VIB (V=0)":
                                {
                                    if (!int.TryParse(cc2[0].Value, out itemp2))
                                    {
                                        if (!double.TryParse(cc2[itemp].Value, out lnqvv)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse VIB (V=0) to double.");
                                    }
                                    else
                                    {
                                        if (itemp2 != cnt2 + 1) throw new ArgumentOutOfRangeException("itemp2/cnt", "GLogRead (contribution q) : Can not verify VIB (V=0) index.");
                                        if (!double.TryParse(cc2[itemp].Value, out lnqvvs[cnt2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse low frequency VIB (V=0) to double.");
                                        cnt2++;
                                    }
                                    break;
                                }
                            case "ELECTRONIC":
                                {
                                    if (!double.TryParse(cc2[itemp].Value, out dtemp)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse electronic Q to double.");
                                    if (Math.Abs(dtemp) > 0.00001) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : electronic contribution Q is not 0.");
                                    break;
                                }
                            case "TRANSLATIONAL":
                                {
                                    if (!double.TryParse(cc2[itemp].Value, out lnqt)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse translational Q to double.");
                                    break;
                                }
                            case "ROTATIONAL":
                                {
                                    if (!double.TryParse(cc2[itemp].Value, out lnqr)) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (contribution q) : Can not parse rotational Q to double.");
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Unknown contribution q information type.");
                        }
                        s = sr.ReadLine();
                        m = GLogReg.r115.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole orientation information.");
                    if (cnt != lfvn || cnt2 != lfvn) throw new ArgumentOutOfRangeException("cnt/cnt2/lfvn", "GLogRead : Can not verify low frequency contribution q number.");
                    //Console.WriteLine("KO : lnqtb={0}\tlnqtv={1}\tlnqvb={2}\r\nlnqvbs[0]={3}\tlnqvv={4}\tlnqvvs[0]={5}\r\nlnqt={6}\tlnqr={7}", lnqtb, lnqtv, lnqvb, lnqvbs[0], lnqvv, lnqvvs[0], lnqt, lnqr);//debug用
                    m = GLogReg.r116.Match(s ?? emstm);//双極子配向タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r116.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole orientation title.");
                    s = sr.ReadLine();
                    m = GLogReg.r117.Match(s ?? emstm);//双極子配向情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r117.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole orientation information.");
                    dico = new double[an, 3];
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 3) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect dipole orientation information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1 || !byte.TryParse(cc[0].Value, out btemp)) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead (dipole orientation) : Can not parse atom number to byte.");
                        if (btemp != als[cnt]) throw new ArgumentOutOfRangeException("als/btemp", "GLogRead (dipole orientation) : Can not verify atom number.");
                        cc = gc[2].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect dipole orientation information format.");
                        if (!double.TryParse(cc[0].Value, out dico[cnt, 0])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (dipole orientation) : Can not parse x to double.");
                        if (!double.TryParse(cc[1].Value, out dico[cnt, 1])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (dipole orientation) : Can not parse y to double.");
                        if (!double.TryParse(cc[2].Value, out dico[cnt, 2])) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead (dipole orientation) : Can not parse z to double.");
                        cnt++;
                        if (cnt > an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead (dipole orientation) : Redundant atom detected.");
                        s = sr.ReadLine();
                        m = GLogReg.r117.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric dipole moment information.");
                    if (cnt != an) throw new ArgumentOutOfRangeException("cnt/an", "GLogRead : Can not verify atom number.");
                    //Console.WriteLine("I : dico[0,0]={0}\tdico[0,1]={1}\tdico[0,2]={2}", dico[0, 0], dico[0, 1], dico[0, 2]);//debug用
                    m = GLogReg.r118.Match(s ?? emstm);//電気双極子タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r118.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric dipole moment title.");
                    s = sr.ReadLine();
                    m = GLogReg.r119.Match(s ?? emstm);//電気双極子インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r119.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric dipole moment index.");
                    s = sr.ReadLine();
                    m = GLogReg.r120.Match(s ?? emstm);//電気双極子情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r120.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find electric dipole moment information.");
                    cnt = 0;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect electric dipole moment information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect electric dipole moment information format.");
                        s = cc[0].Value;
                        cc = gc[2].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect electric dipole moment information format.");
                        cc2 = gc[3].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Incorrect electric dipole moment information format.");
                        switch (s.ToUpperInvariant())
                        {
                            case "TOT":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment in Debye to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out edmdo)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment in SI units to double.");
                                    break;
                                }
                            case "X":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment x in au to double.");
                                    if (dtemp != 0) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electric dipole moment x is not 0.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment x in Debye to double.");
                                    if (dtemp != 0) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electric dipole moment x is not 0.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment x in SI units to double.");
                                    if (dtemp != 0) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electric dipole moment x is not 0.");
                                    break;
                                }
                            case "Y":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment y in au to double.");
                                    if (dtemp != 0) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electric dipole moment y is not 0.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment y in Debye to double.");
                                    if (dtemp != 0) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electric dipole moment y is not 0.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment y in SI units to double.");
                                    if (dtemp != 0) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Electric dipole moment y is not 0.");
                                    break;
                                }
                            case "Z":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment z in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment z in Debye to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse electric dipole moment z in SI units to double.");
                                    if (dtemp != edmdo) throw new ArgumentOutOfRangeException("dtemp/edmdo", "GLogRead : Can not verify electric dipole moment in SI units.");
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Unknown dipole orientation information type.");
                        }
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r120.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole polarizability information.");
                    if (cnt != 4) throw new ArgumentOutOfRangeException("cnt", "GLogRead : Can not verify dipole orientation information number.");
                    //Console.WriteLine("A : edmdo={0}", edmdo);//debug用
                    m = GLogReg.r121.Match(s ?? emstm);//電気双極子分極率タイトルを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r121.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole polarizability title.");
                    s = sr.ReadLine();
                    m = GLogReg.r122.Match(s ?? emstm);//電気双極子分極率インデックスを探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r122.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole polarizability index.");
                    s = sr.ReadLine();
                    m = GLogReg.r120.Match(s ?? emstm);//電気双極子分極率情報を探す
                    while (s != null && !m.Success)
                    {
                        s = sr.ReadLine();
                        m = GLogReg.r120.Match(s ?? emstm);
                    }
                    if (s == null) throw new ArgumentNullException("s", "GLogRead : Can not find dipole polarizability index.");
                    dpam = new double[3, 3];
                    cnt++;
                    while (s != null && m.Success)
                    {
                        gc = m.Groups;
                        if (gc.Count != 4) throw new ArgumentOutOfRangeException("gc", "GLogRead : Incorrect dipole polarizability information format.");
                        cc = gc[1].Captures;
                        if (cc.Count != 1) throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Incorrect dipole polarizability information format.");
                        s = cc[0].Value;
                        cc = gc[2].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[2]", "GLogRead : Incorrect dipole polarizability information format.");
                        cc2 = gc[3].Captures;
                        if (cc.Count != 3) throw new ArgumentOutOfRangeException("gc[3]", "GLogRead : Incorrect dipole polarizability information format.");
                        switch (s.ToUpperInvariant())
                        {
                            case "ISO":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse iso dipole polarizability in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse iso dipole polarizability in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dpiso)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse iso dipole polarizability in SI units to double.");
                                    break;
                                }
                            case "ANISO":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse aniso dipole polarizability in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse aniso dipole polarizability in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dpaniso)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse aniso dipole polarizability in SI units to double.");
                                    break;
                                }
                            case "XX":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability xx in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability xx in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dpam[0, 0])) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability xx in SI units to double.");
                                    break;
                                }
                            case "YX":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability yx in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability yx in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability yx in SI units to double.");
                                    dpam[0, 1] = dtemp;
                                    dpam[1, 0] = dtemp;
                                    break;
                                }
                            case "YY":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability yy in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability yy in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dpam[1, 1])) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability yy in SI units to double.");
                                    break;
                                }
                            case "ZX":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zx in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zx in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zx in SI units to double.");
                                    dpam[0, 2] = dtemp;
                                    dpam[2, 0] = dtemp;
                                    break;
                                }
                            case "ZY":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zy in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zy in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zy in SI units to double.");
                                    dpam[1, 2] = dtemp;
                                    dpam[2, 1] = dtemp;
                                    break;
                                }
                            case "ZZ":
                                {
                                    sb.Clear();
                                    sb.Append(cc[0]);
                                    sb.Append("E");
                                    sb.Append(cc2[0]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zz in au to double.");
                                    sb.Clear();
                                    sb.Append(cc[1]);
                                    sb.Append("E");
                                    sb.Append(cc2[1]);
                                    if (!double.TryParse(sb.ToString(), out dtemp)) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zz in esu to double.");
                                    sb.Clear();
                                    sb.Append(cc[2]);
                                    sb.Append("E");
                                    sb.Append(cc2[2]);
                                    if (!double.TryParse(sb.ToString(), out dpam[2, 2])) throw new ArgumentOutOfRangeException("dtemp", "GLogRead : Can not parse dipole polarizability zz in SI units to double.");
                                    break;
                                }
                            default: throw new ArgumentOutOfRangeException("gc[1]", "GLogRead : Unknown dipole polarizability information type.");
                        }
                        cnt++;
                        s = sr.ReadLine();
                        m = GLogReg.r120.Match(s ?? emstm);
                    }
                    //Console.WriteLine("KI : dpiso={0}\tdpaniso={1}\r\ndpam[0,0]={2}\tdpam[1,1]={3}\tdpam[2,2]={4}", dpiso, dpaniso, dpam[0, 0], dpam[1, 1], dpam[2, 2]);//debug用
                }
            }
        }
        static private class GLogReg
        {
            internal readonly static Regex r1 = new Regex(@"^\s*Charge\s*=\s*\d+\s*Multiplicity\s*=\s*\d+\s?$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電荷と多重度情報
            internal readonly static Regex r2 = new Regex(@"^\s*(\p{L}+)\s+([-.\d]+)\s+([-.\d]+)\s+([-.\d]+)\s*$", RegexOptions.None, CommonParam.ts);//原子座標情報
            internal readonly static Regex r3 = new Regex(@"^\s?(?:Grad)+\s?$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分割線
            internal readonly static Regex r4 = new Regex(@"\s+!\s+Initial\s+Parameters\s+!\s?", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//入力パラメータタイトル
            internal readonly static Regex r5 = new Regex(@"^\s+!\s+R(\d+)\s+R\((\d+),(\d+)\)\s+([.\d]+)[-.=\s\d\p{L}/]+!\s*$", RegexOptions.None, CommonParam.ts);//結合長情報
            internal readonly static Regex r6 = new Regex(@"^\s+!\s+A(\d+)\s+A\((\d+),(\d+),(\d+)\)\s+([.\d]+)[-.=\s\d\p{L}/]+!\s*$", RegexOptions.None, CommonParam.ts);//結合角情報
            internal readonly static Regex r7 = new Regex(@"^\s+!\s+D(\d+)\s+D\((\d+),(\d+),(\d+),(\d+)\)\s+([-.\d]+)[-.=\s\d\p{L}/]+!\s*$", RegexOptions.None, CommonParam.ts);//結合二面角情報
            internal readonly static Regex r8 = new Regex(@"^\s*Deg\.\sof\sfreedom\s*(\d+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自由度情報
            internal readonly static Regex r9 = new Regex(@"^\s+Standard\sorientation:\s+$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//標準配向タイトル
            internal readonly static Regex r10 = new Regex(@"^\s+(\d+)\s+(\d+)\s+(\d+)\s+([-.\d]+)\s+([-.\d]+)\s+([-.\d]+)\s*$", RegexOptions.None, CommonParam.ts);//標準配向情報
            internal readonly static Regex r11 = new Regex(@"^\s*Rotational\sconstants\s\(GHZ\):(\s+[\d.]+){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//回転定数情報
            internal readonly static Regex r11a = new Regex(@"^\s+(\d+)\sbasis\sfunctions[,\p{L}\d\s]+$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//基底関数個数情報
            internal readonly static Regex r11b = new Regex(@"^\s*NBasis=\s*(\d+)[-.,=\p{L}\d\s]+$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//基底関数個数情報2
            internal readonly static Regex r12 = new Regex(@"^\s*\*+\s*$", RegexOptions.None, CommonParam.ts);//分割線2
            internal readonly static Regex r13 = new Regex(@"^\s+Population\sanalysis\susing\sthe\sSCF\sDensity\.\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電子密度解析タイトル
            internal readonly static Regex r14 = new Regex(@"^\s*Orbital\ssymmetries:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//軌道対称性タイトル
            internal readonly static Regex r15 = new Regex(@"^\s+(Virtual|Occupied)?\s*(\([\p{L}\d]+\)\s*)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道カウント
            internal readonly static Regex r16 = new Regex(@"^\s*Alpha\s+(occ|virt)\.\s+eigenvalues\s+--(\s*-?[.\d]+)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道エネルギー情報
            internal readonly static Regex r17 = new Regex(@"^\s*Molecular\sOrbital\sCoefficients:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道係数タイトル
            internal readonly static Regex r17a = new Regex(@"^(\s+\d+)+\s*$", RegexOptions.None, CommonParam.ts);//分子軌道/原子軌道/縮約行列/Hirshfeld/ESP/正規座標インデクス
            internal readonly static Regex r17b = new Regex(@"^(?:\s+\(?[\p{L}\d]*\)?-*(\p{L}))+\s*$", RegexOptions.None, CommonParam.ts);//分子軌道タイプ情報
            internal readonly static Regex r17c = new Regex(@"^\s*Eigenvalues\s--(\s*-?[.\d]+)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子軌道固有値情報
            internal readonly static Regex r18 = new Regex(@"^\s*(\d+)\s(\d+\s+)?(\p{L}+\s)?\s*(\d*\p{L}[-+\d\p{L}]*(?:\s0)?\s)(\s+[-.\d]+)+\s*$", RegexOptions.None, CommonParam.ts);//分子軌道係数、原子軌道密度、縮約密度、Hirshfeld、軌道エネるギー/運動エネルギー、ESP電荷、原子電位、自然電子密度まとめ
            internal readonly static Regex r19 = new Regex(@"^\s+Density\sMatrix:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//密度行列タイトル
            internal readonly static Regex r20 = new Regex(@"^\s+Full\sMulliken\spopulation\sanalysis:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Mulliken密度解析タイトル
            internal readonly static Regex r21 = new Regex(@"^\s+Gross\sorbital\spopulations:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//総軌道密度タイトル
            internal readonly static Regex r22 = new Regex(@"^\s+Condensed\sto\satoms\s\(all\selectrons\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//縮約密度タイトル
            internal readonly static Regex r23 = new Regex(@"^\s*Mulliken\scharges:$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Mulliken電荷タイトル
            internal readonly static Regex r24 = new Regex(@"^\s+(\d+)\s+(\p{L}+)\s+([-.\d]+)\s*$", RegexOptions.None, CommonParam.ts);//Mulliken/APT電荷&重原子Mulliken/APT電荷情報
            internal readonly static Regex r25 = new Regex(@"925", RegexOptions.Compiled, Regex.InfiniteMatchTimeout);//戻らなむ 儚き夢の 菊月に
            internal readonly static Regex r26 = new Regex(@"^\s*Mulliken\scharges\swith\shydrogens\ssummed\sinto\sheavy\satoms:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//重原子Mulliken電荷タイトル
            internal readonly static Regex r27 = new Regex(@"^\s*Electronic\sspatial\sextent\s\(au\):\s*<R\*\*2>=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//ESE情報
            internal readonly static Regex r28 = new Regex(@"^\s*Dipole\smoment\s\(field-independent\sbasis,\sDebye\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//双極子モーメントタイトル
            internal readonly static Regex r29 = new Regex(@"^(?:\s+(\p{L}+)=\s+([-.\d]+))+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//極性モーメント情報
            internal readonly static Regex r30 = new Regex(@"^\s*Quadrupole\smoment\s\(field-independent\sbasis,\sDebye-Ang\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//四極子モーメントタイトル
            internal readonly static Regex r31 = new Regex(@"^\s*Traceless\sQuadrupole\smoment\s\(field-independent\sbasis,\sDebye-Ang\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//跡無し四極子モーメントタイトル
            internal readonly static Regex r32 = new Regex(@"^\s*Octapole\smoment\s\(field-independent\sbasis,\sDebye-Ang\*\*2\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//八極子モーメントタイトル
            internal readonly static Regex r33 = new Regex(@"^\s*Hexadecapole\smoment\s\(field-independent\sbasis,\sDebye-Ang\*\*3\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//十六極子モーメントタイトル
            internal readonly static Regex r34 = new Regex(@"^\s*N-N=\s*([-.\d]+)D([-+\d]+)\s+E-N=\s*([-.\d]+)D([-+\d]+)\s+KE=\s*([-.\d]+)D([-+\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//反発/吸引/運動エネルギー情報
            internal readonly static Regex r35 = new Regex(@"^\s*ElSum\sfrom\s(atomic)?\s+densit(?:y|ies)=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//EISum情報
            internal readonly static Regex r36 = new Regex(@"^\s*Hirshfeld\spopulations\sat\siteration\s+\d\s+\([\s\p{L},]+\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Hirshfeld電荷密度タイトル
            internal readonly static Regex r37 = new Regex(@"^\s+Tot(\s+[-.\d]+)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//total Hirshfeld
            internal readonly static Regex r38 = new Regex(@"^\s+Dip\sfrom\sAtomic\sChgs(\s+[-.\d]+){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Hirshfeld双極子情報
            internal readonly static Regex r39 = new Regex(@"^\s+Total\sDipole(\s+[-.\d]+){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);//total Hirshfeld双極子情報
            internal readonly static Regex r40 = new Regex(@"^\s+Hirshfeld\scharges,\sspin\sdensities,\sdipoles,\sand\sCM5\scharges\susing\sIRadAn=\s+\d+:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Hirshfeld原子情報タイトル
            internal readonly static Regex r41 = new Regex(@"^(\s+Q-H)(\s+S-H)?(\s+Dx)?(\s+Dy)?(\s+Dz)?(\s+Q-CM5)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Hirshfeld原子情報インデックス
            internal readonly static Regex r42 = new Regex(@"^\s*Hirshfeld\scharges\swith\shydrogens\ssummed\sinto\sheavy\satoms:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//Hirshfeld重原子情報タイトル
            internal readonly static Regex r43 = new Regex(@"^\s*EQQ=\s*([-+.\d]+)\s+EQD=\s*([-+.\d]+)\s+EDD=\s*([-+.\dE]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//EQQ/EQD/EDD情報
            internal readonly static Regex r44 = new Regex(@"^\s*EQQ\+QD\+DD=\s*([-+.\dE]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//EQQ+QD+DD情報
            internal readonly static Regex r45 = new Regex(@"^\s*Orbital\senergies\sand\skinetic\senergies\s\(alpha\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//軌道エネルギーと運動エネルギータイトル
            internal readonly static Regex r46 = new Regex(@"^\s*Total\skinetic\senergy\sfrom\sorbitals=\s+([-.\d]+)D([-+\d]+)+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//総軌道運動エネルギー情報
            internal readonly static Regex r47 = new Regex(@"^\s*Electrostatic\sProperties\sUsing\sThe\sSCF\sDensity\.\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//ESP(Merz-Kollman)タイトル
            internal readonly static Regex r48 = new Regex(@"^\s*ESP\scharges:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//ESP電荷タイトル
            internal readonly static Regex r49 = new Regex(@"^\s*ESP\scharges\swith\shydrogens\ssummed\sinto\sheavy\satoms:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//ESP重原子電荷タイトル
            internal readonly static Regex r50 = new Regex(@"^\s*Charge=\s+([-.\d]+)\s+Dipole=\s+([-.\d]+)\s+([-.\d]+)\s+([-.\d]+)\s+Tot=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//ESP総電荷＆双極子情報
            internal readonly static Regex r51 = new Regex(@"^\s+Electrostatic\sProperties\s\(Atomic\sUnits\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//原子電位タイトル
            internal readonly static Regex r52 = new Regex(@"^\s+N A T U R A L   A T O M I C   O R B I T A L   A N D\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然結合軌道(NBO)タイトル1
            internal readonly static Regex r53 = new Regex(@"^\s+N A T U R A L   B O N D   O R B I T A L   A N A L Y S I S\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然結合軌道(NBO)タイトル2
            internal readonly static Regex r54 = new Regex(@"^\s+NATURAL\sPOPULATIONS:\s+Natural\satomic\sorbital\soccupancies\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然原子軌道(NAO)タイトル
            internal readonly static Regex r55 = new Regex(@"^\s+NAO\s+Atom\s+No\s+lang\s+Type\(AO\)\s+Occupancy\s+Energy\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然原子軌道(NAO)インデックス
            internal readonly static Regex r56 = new Regex(@"^\s+(\d+)\s+(\p{L}+)\s+(\d+)\s+([\d\p{L}]+)\s+((\p{L}{3})\(.\d\p{L}\))(\s+[-.\d]+){2}\s*$", RegexOptions.None, CommonParam.ts);//自然原子軌道(NAO)情報
            internal readonly static Regex r57 = new Regex(@"^\s+Summary\sof\sNatural\sPopulation\sAnalysis:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然電子密度まとめタイトル
            internal readonly static Regex r58 = new Regex(@"^\s+Atom\s+No\s+Charge\s+Core\s+Valence\s+Rydberg\s+Total\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然電子密度まとめインデックス
            internal readonly static Regex r59 = new Regex(@"^\s+(\p{L}+)\s+(\d+)(\s+[-.\d]+)+\s*$", RegexOptions.None, CommonParam.ts);//自然電子密度まとめ情報
            internal readonly static Regex r60 = new Regex(@"^\s+Natural\sPopulation\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//総自然電子密度タイトル
            internal readonly static Regex r61 = new Regex(@"^\s+((?:[-\p{L}]+\s)+)\s+([.\d]+)\s*\(\s*([.\d]+)\s?%\s+of\s+([*\d]+)\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//総自然電子密度情報
            internal readonly static Regex r62 = new Regex(@"^\s+Atom\s+No\s+Natural\sElectron\sConfiguration\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然電子配置タイトル
            internal readonly static Regex r63 = new Regex(@"^\s+(\p{L}+)\s+(\d+)\s+\[core\]?(?:(\d+\p{L}+)\(\s?([.\d]+)\))+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然電子配置情報
            internal readonly static Regex r64 = new Regex(@"^\s+NATURAL\sBOND\sORBITAL\sANALYSIS:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然結合軌道分析タイトル
            internal readonly static Regex r65 = new Regex(@"^\s+\(Occupancy\)\s+Bond\sorbital/\sCoefficients/\sHybrids\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然結合テーブルタイトル
            internal readonly static Regex r66 = new Regex(@"^\s+(\d+)\.\s+\(([.\d]+)\)\s+(\p{L}{2}\*?)\s?\(\s?(\d+)\)\s*(\p{L}+)\s+(\d+)\s+(?:-\s*(\p{L}+)\s+(\d+)\s+)?(?:s\(\s*([.\d]+)%\))?(?:p[.\s\d]+\(\s*([.\d]+)%\))?(?:d[.\s\d]+\(\s*([.\d]+)%\))?\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然結合テーブル情報1
            internal readonly static Regex r67 = new Regex(@"^\s+\(\s*([.\d]+)%\)\s+(?:[-.\d]+\*?)\s*(\p{L}+)\s+(\d+)\s+(?:s\(\s*([.\d]+)%\))?(?:p[.\s\d]+\(\s*([.\d]+)%\))?(?:d[.\s\d]+\(\s*([.\d]+)%\))?\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自然結合テーブル情報2
            internal readonly static Regex r68 = new Regex(@"^\s*NHO\sDirectionality\sand\s\x22Bond\sBending\x22\s\(deviations\sfrom\sline\sof\snuclear\scenters\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//NHO方向＆結合曲がりタイトル
            internal readonly static Regex r69 = new Regex(@"^\s+Line\sof\sCenters\s+Hybrid\s1\s+Hybrid\s2\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//NHO方向＆結合曲がりインデックス1
            internal readonly static Regex r70 = new Regex(@"^\s+NBO\s+Theta\s+Phi\s+Theta\s+Phi\s+Dev\s+Theta\s+Phi\s+Dev\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//NHO方向＆結合曲がりインデックス2
            internal readonly static Regex r71 = new Regex(@"^\s+(\d+)\.\s(\p{L}{2}\*?)\s?\(\s*(\d+)\)\s?(\p{L}{1,2})\s+(\d+)\s(?:\s*-\s?(\p{L}{1,2})\s+(\d+))?(\s+[-.\d]+)+\s*$", RegexOptions.None, CommonParam.ts);//NHO方向＆結合曲がり情報
            internal readonly static Regex r72 = new Regex(@"^\s+Second\sOrder\sPerturbation\sTheory\sAnalysis\sof\sFock\sMatrix\sin\sNBO\sBasis\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//二次摂動理論分析タイトル
            internal readonly static Regex r73 = new Regex(@"^(?:\s+/?\s*([*\d]+)\.\s(\p{L}{2}\*?)\s?\(\s*(\d+)\)\s?(\p{L}{1,2})\s+(\d+)\s\s*-?\s*(\p{L}{0,2})\s+(\d*)){2}(\s+[.\d]+){3}\s*$", RegexOptions.None, CommonParam.ts);//二次摂動理論分析情報
            internal readonly static Regex r74 = new Regex(@"^\s*Natural\sBond\sOrbitals\s\(Summary\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//NBOまとめタイトル
            internal readonly static Regex r75 = new Regex(@"^\s+NBO\s+Occupancy\s+Energy\s+\(geminal,vicinal,remote\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//NBOまとめインデックス
            internal readonly static Regex r76 = new Regex(@"^\s+(\d+)\.\s(\p{L}{2}\*?)\s?\(\s*(\d+)\)\s?(\p{L}{1,2})\s+(\d+)\s\s*-?\s*(\p{L}{1,2})?\s+(\d+)?\s+([-.\d]+)\s+([-.\d]+)\s+(?:[\d()\p{L},])*\s*$", RegexOptions.None, CommonParam.ts);//NBOまとめ情報
            //internal readonly static Regex r77 = new Regex(@"^\s+Charge\sunit\s+(\d+)\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//NBO電荷まとめ情報
            internal readonly static Regex r78 = new Regex(@"^\s+!\s+Optimized\sParameters\s+!\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//最適化構造タイトル
            internal readonly static Regex r79 = new Regex(@"^\s+nuclear\srepulsion\senergy\s+([\d.]+)\s*Hartrees\.\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//核反発エネルギー情報
            internal readonly static Regex r80 = new Regex(@"^\s+SCF\sDone:\s+E\(RB3LYP\)\s=\s+([-.\d]+)\s+A\.U\.\safter\s+\d+\scycles\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//自己無撞着場エネルギー情報
            internal readonly static Regex r81 = new Regex(@"^\s+SCF\sGIAO\sMagnetic\sshielding\stensor\s\(ppm\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//GIAO磁気遮蔽テンソルタイトル
            internal readonly static Regex r82 = new Regex(@"^\s+(\d+)\s+(\p{L}+)\s+Isotropic\s=\s+([-.\d]+)\s+Anisotropy\s=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//GIAO等方/異方磁気遮蔽情報
            internal readonly static Regex r83 = new Regex(@"^(?:\s+(\p{L}{2})=\s+([-.\d]+)){3}\s*$", RegexOptions.None, CommonParam.ts);//GIAO磁気遮蔽テンソル情報
            internal readonly static Regex r84 = new Regex(@"^\s+Eigenvalues:(?:\s+([-.\d]+)){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//GIAO磁気遮蔽固有値情報
            internal readonly static Regex r85 = new Regex(@"^\s+Isotropic\spolarizability\sfor\sW=\s+([-.\d]+)\s+([-.\d]+)\s+Bohr\*\*3\.\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//等方性分極率情報
            internal readonly static Regex r86 = new Regex(@"^\s+Dipole-magnetic\sdipole\spolarizability\sfor\sW=\s+([-.\d]+):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//磁気双極子分極率タイトル
            internal readonly static Regex r87 = new Regex(@"^\s+1\s+2\s+3\s*$", RegexOptions.None, CommonParam.ts);//磁気双極子分極率/DQ/旋光Gインデックス
            internal readonly static Regex r88 = new Regex(@"^\s+([1-3])(?:\s+([-+.\d]+)D([-+\d]+)){3}\s*$", RegexOptions.None, CommonParam.ts);//磁気双極子分極率/DQ/旋光Gテンソル
            internal readonly static Regex r89 = new Regex(@"^\s+DQ\scontribution\sto\sOR\sG\sfor\sW=\s+([-.\d]+):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//DQタイトル
            internal readonly static Regex r90 = new Regex(@"^\s+Optical\sRotation\sG'\stensor\sfor\sW=\s+([-.\d]+):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//旋光Gタイトル
            internal readonly static Regex r91 = new Regex(@"^\s+OR\sG\sEigenvalues:(?:\s+([-.\d]+)){3}\s+Iso=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//旋光G固有値とiso旋光G情報
            internal readonly static Regex r92 = new Regex(@"^\s+\([1-3]\)(?:\s+([-.\d]+)){3}\s*$", RegexOptions.None, CommonParam.ts);//旋光G固有ベクトル情報
            internal readonly static Regex r93 = new Regex(@"^\s+Molar\sMass\s=\s+([-.\d]+)\s+grams/mole,\s\[Alpha\]D\s\(static\)\s=\s+([-.\d]+)\sdeg\.\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分子量とalpha D情報
            internal readonly static Regex r94 = new Regex(@"^\s+APT\scharges:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//APT電荷タイトル
            internal readonly static Regex r95 = new Regex(@"^\s+Sum\sof\sAPT\scharges\s=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//APT総電荷情報
            internal readonly static Regex r96 = new Regex(@"^\s+APT\scharges\swith\shydrogens\ssummed\sinto\sheavy\satoms:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//APT重原子電荷タイトル
            internal readonly static Regex r97 = new Regex(@"^\s+(Exact|Approx)\spolarizability:(?:\s+([-.\d]+)){6}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//精確/近似分極率情報
            internal readonly static Regex r98 = new Regex(@"^\s+Full\smass-weighted\sforce\sconstant\smatrix:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//弾力定数タイトル
            internal readonly static Regex r99 = new Regex(@"^\s+Low\sfrequencies\s-+(?:\s+([-.\d]+))+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//弾力定数行列低値情報
            internal readonly static Regex r100 = new Regex(@"^\s+Diagonal\svibrational\spolarizability:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//対角振動分極率タイトル
            internal readonly static Regex r101 = new Regex(@"^(?:\s+([-.\d]+))+\s*$", RegexOptions.None, CommonParam.ts);//対角振動分極率情報
            internal readonly static Regex r102 = new Regex(@"^(?:([-.\s\p{L}]+))--(?:\s+([-.\d]+)){3}\s*$", RegexOptions.None, CommonParam.ts);//正規座標情報
            internal readonly static Regex r103 = new Regex(@"^\s+Atom\s+AN(?:\s+X\s+Y\s+Z){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//正規座標行列インデックス
            internal readonly static Regex r104 = new Regex(@"^(?:\s+(\d+)){2}(?:\s+([-.\d]+)){9}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//正規座標行列情報
            internal readonly static Regex r105 = new Regex(@"^\s+Principal\saxes\sand\smoments\sof\sinertia\sin\satomic\sunits:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//慣性主軸と主慣性モーメントタイトル
            internal readonly static Regex r106 = new Regex(@"^\s+(?:\p{L})(?:\s+([-.\d]+)){3}\s*$", RegexOptions.None, CommonParam.ts);//慣性主軸情報
            internal readonly static Regex r107 = new Regex(@"^\s+Rotational\stemperatures\s\(Kelvin\)(?:\s+([-.\d]+)){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//回転温度情報
            internal readonly static Regex r108 = new Regex(@"^\s+Zero-point\svibrational\senergy\s+([-.\d]+)\s+\(Joules/Mol\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//零点エネルギー情報
            internal readonly static Regex r109 = new Regex(@"^\s+Thermal\scorrection\sto\s([\s\p{L}]+)=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//内部エネルギー/エンタルピー/ギブス自由エネルギー修正情報
            internal readonly static Regex r110 = new Regex(@"^\s+Sum\sof\selectronic\sand\s([-\s\p{L}]+)=\s+([-.\d]+)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//修正電子エネルギー情報
            internal readonly static Regex r111 = new Regex(@"^\s+E\s\(Thermal\)\s+CV\s+S\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//内部エネルギー/等容比熱/エントロピーインデックス
            internal readonly static Regex r112 = new Regex(@"^\s+(\p{L}+)(?:\s+([-.\d]+)){3}\s*$", RegexOptions.None, CommonParam.ts);//内部エネルギー/等容比熱/エントロピー情報
            internal readonly static Regex r113 = new Regex(@"^\s+Vibration\s+\d+(?:\s+([-.\d]+)){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//低周波数振動E/CV/S情報
            internal readonly static Regex r114 = new Regex(@"^\s+Q\s+Log10\(Q\)\s+Ln\(Q\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分配関数インデックス
            internal readonly static Regex r115 = new Regex(@"^\s+([=0\s\p{L}()]+)\s+(?:\s+([-+D.\d]+))+\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//分配関数情報
            internal readonly static Regex r116 = new Regex(@"^\s+Dipole\sorientation:\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//双極子配向タイトル
            internal readonly static Regex r117 = new Regex(@"^\s+(\d+)(?:\s+([-.\d]+)){3}\s*$", RegexOptions.None, CommonParam.ts);//双極子配向情報
            internal readonly static Regex r118 = new Regex(@"^\s+Electric\sdipole\smoment\s\(dipole\sorientation\):\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電気双極子モーメントタイトル
            internal readonly static Regex r119 = new Regex(@"^\s+\(au\)\s+\(Debye\)\s+\(10\*\*-30\sSI\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電気双極子モーメントインデックス
            internal readonly static Regex r120 = new Regex(@"^\s+(\p{L}+)(?:\s+([-.\d]+)D([-+\d]+)){3}\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電気双極子モーメント/双極子分極率情報
            internal readonly static Regex r121 = new Regex(@"^\s+Dipole\spolarizability,\sAlpha\s\(dipole\sorientation\)\.\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電気双極子分極率タイトル
            internal readonly static Regex r122 = new Regex(@"^\s+\(au\)\s+\(10\*\*-24\sesu\)\s+\(10\*\*-40\sSI\)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//電気双極子分極率インデックス
            internal readonly static Regex r123 = new Regex(@"^\s+!\s+Initial\sParameters\s+!\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, CommonParam.ts);//初期構造タイトル
        }
        public void Dispose()
        {
            als = null;
            acs = null;
            rdl = null;
            rdd = null;
            agl = null;
            agd = null;
            dhl = null;
            dhd = null;
            soco = null;
            rc = null;
            mlkc = null;
            mhsc = null;
            dipmm = null;
            qdpmt = null;
            tlqmt = null;
            ocpmt = null;
            hdpmt = null;
            moev = null;
            mocm = null;
            aobl = null;
            aol = null;
            dnsm = null;
            mpam = null;
            gop = null;
            cdnsm = null;
            HCAB = null;
            HDXYZ = null;
            HDXYZt = null;
            HDipc = null;
            HDipt = null;
            Hachg = null;
            Hacm5chg = null;
            Hhachg = null;
            Hhacm5chg = null;
            oke = null;
            ESPc = null;
            ESPch = null;
            ESPdip = null;
            aep = null;
            naooc = null;
            naoen = null;
            naot = null;
            nch = null;
            npc = null;
            npv = null;
            npr = null;
            npt = null;
            nec2s = null;
            nec2p = null;
            nboi1 = null;
            nboi2 = null;
            nboo1 = null;
            nboo2 = null;
            nbot1 = null;
            nbot2 = null;
            nbok1 = null;
            nbok2 = null;
            nbon1 = null;
            nbon21 = null;
            nbon22 = null;
            nbos1 = null;
            nbop1 = null;
            nbod1 = null;
            nbos21 = null;
            nbos22 = null;
            nbop21 = null;
            nbop22 = null;
            nbod21 = null;
            nbod22 = null;
            nbor21 = null;
            nbor22 = null;
            nhon = null;
            nhod1 = null;
            nhod2 = null;
            sopd = null;
            sopa = null;
            sope = null;
            nboe1 = null;
            nboe2 = null;
            gmsi = null;
            gmsa = null;
            gmst = null;
            gmse = null;
            dmdp = null;
            dqct = null;
            orgt = null;
            orge = null;
            orgev = null;
            APTc = null;
            APThc = null;
            Epol = null;
            Apol = null;
            mwfc = null;
            dvp = null;
            noco = null;
            ncfrq = null;
            ncrm = null;
            ncfc = null;
            ncii = null;
            ncds = null;
            ncrs = null;
            ncema = null;
            pax = null;
            rott = null;
            lfve = null;
            lfvcv = null;
            lfvs = null;
            lnqvbs = null;
            lnqvvs = null;
            dico = null;
            dpam = null;
        }
    }
    internal class GauDesc : IDisposable
    {
        private readonly string fpth;//ログファイルフルパス
        private readonly string fdir;//ログファイルディレクトリー
        private readonly GLogReader gl;//ガウシアンログファイル
        private readonly bool VldL = false;//ガウシアンログファイルの有効性
        private readonly bool VldC = false;//BINOLコア情報の有効性
        private readonly bool VldD = false;//BINOL記述子の有効性
        private bool? BINOLt;//null：フリーBINOL、false：BOAcBINOL、true：BOPhBINOL
        private int[] HydL;//水素原子リスト
        private int[] BorL;//硼素原子リスト
        private int[] CarL;//炭素原子リスト
        private int[] NitL;//窒素原子リスト
        private int[] OxyL;//酸素原子リスト
        private int[] FluL;//弗素原子リスト
        private int[] PhoL;//燐原子リスト
        private int[] SulL;//硫黄原子リスト
        private int[] ChlL;//塩素原子リスト
        private int[] BroL;//臭素原子リスト
        private int[] IodL;//沃素原子リスト
        private int[] CoC1;//コアPhC1 HighLow
        private int[] CoC2;//コアPhC2 HighLow
        private int[] CoC3;//コアPhC3 HighLow、NBO自然電荷の高いC3が先。他の原子がC3の順番に従い、同側のC3と同じ。
        private int[] CoC4;//コアPhC4 HighLow
        private int[] CoC5;//コアPhC5 HighLow
        private int[] CoC6;//コアPhC6 HighLow
        private int[] CoO;//コアO HighLow
        private int[] CoH;//コアH HighLow
        private int CoB;//コアB
        private int CoOb;//コアO on B
        private int CoCco;//コアC on CO
        private int CoOco;//コアO on CO
        private int CoCac;//コアC on Ac
        private int[] CoHac;//コアH on Ac
        private int[] CoFuRiH;//縮合共役環式構造High
        private int[] CoFuRiL;//縮合共役環式構造Low
        private int[] sub3H;//3位置換基High
        private int[] sub3L;//3位置換基Low
        private int CFRn;//縮合共役環式構造原子数
        private int sub3n;//3位置換基原子数
        private int[] Ri123456H;//結合長インデックス C1-C2 / C2-C3 / C3-C4 / C4-C5 / C5-C6 / C6-C1 (High)
        private double[] R123456H;//コアPh結合長 C1-C2 / C2-C3 / C3-C4 / C4-C5 / C5-C6 / C6-C1 (High)
        private double Ravg123456H;//コアPh High平均結合長
        private int[] Ri123456L;//結合長インデックス C1-C2 / C2-C3 / C3-C4 / C4-C5 / C5-C6 / C6-C1 (Low)
        private double[] R123456L;//コアPh結合長 C1-C2 / C2-C3 / C3-C4 / C4-C5 / C5-C6 / C6-C1 (Low)
        private double Ravg123456L;//コアPh Low平均結合長
        private double RavgCPh;////コアPh平均結合長(12個の平均)
        private int[] RiCFRH;//縮合共役環式構造High結合長インデックス
        private double[] RCFRH;//縮合共役環式構造High結合長
        private double RavgCFRH;//縮合共役環式構造High平均結合長
        private int[] RiCFRL;//縮合共役環式構造Low結合長インデックス
        private double[] RCFRL;//縮合共役環式構造Low結合長
        private double RavgCFRL;//縮合共役環式構造Low平均結合長
        private double RavgCFR;//縮合共役環式構造平均結合長
        private int[] RiC2O;//コアC2-O結合長インデックスHighLow
        private double[] RC2O;//コアC2-O結合長HighLow
        private double RavgC2O;//コアC2-O平均結合長
        private int RiC11;//コアC1-C1'結合長インデックス
        private double RC11;//コアC1-C1'結合長
        private int[] AiCPhH;//コアPh High結合角インデックス
        private double[] ACPhH;//コアPh High結合角
        private double cosACPhH;//cos(コアPh High結合角)の和
        private double cos2ACPhH;//cos2(コアPh High結合角)の和
        private double sinACPhHa;//sin(コアPh High結合角)の絶対値の和
        private double sin2ACPhH;//sin2(コアPh High結合角)の和
        private int[] AiCPhL;//コアPh Low結合角インデックス
        private double[] ACPhL;//コアPh Low結合角
        private double cosACPhL;//cos(コアPh Low結合角)の和
        private double cos2ACPhL;//cos2(コアPh Low結合角)の和
        private double sinACPhLa;//sin(コアPh Low結合角)の絶対値の和
        private double sin2ACPhL;//sin2(コアPh Low結合角)の和
        private double cosACPh;//cos(コアPh結合角)の和
        private double cos2ACPh;//cos2(コアPh結合角)の和
        private double sinACPha;//sin(コアPh結合角)の和の絶対値
        private double sin2ACPh;//sin2(コアPh結合角)の和
        private int[] AiCFRH;//縮合共役環式構造High結合角インデックス
        private double[] ACFRH;//縮合共役環式構造High結合角
        private double cosACFRH;//cos(縮合共役環式構造High結合角)の和
        private double cos2ACFRH;//cos2(縮合共役環式構造High結合角)の和
        private double sinACFRHa;//sin(縮合共役環式構造High結合角)の絶対値の和
        private double sin2ACFRH;//sin2(縮合共役環式構造High結合角)の和
        private int[] AiCFRL;//縮合共役環式構造Low結合角インデックス
        private double[] ACFRL;//縮合共役環式構造Low結合角
        private double cosACFRL;//cos(縮合共役環式構造Low結合角)の和
        private double cos2ACFRL;//cos2(縮合共役環式構造Low結合角)の和
        private double sinACFRLa;//sin(縮合共役環式構造Low結合角)の絶対値の和
        private double sin2ACFRL;//sin2(縮合共役環式構造Low結合角)の和
        private double cosACFR;//cos(縮合共役環式構造結合角)の和
        private double cos2ACFR;//cos2(縮合共役環式構造結合角)の和
        private double sinACFRa;//sin(縮合共役環式構造結合角)の絶対値の和
        private double sin2ACFR;//sin2(縮合共役環式構造結合角)の和
        private int[] Aico;//コア酸素結合角インデックスHighLow
        private double[] Aiko;//コア酸素結合角HighLow
        private double[] AiCOs;//cos(コア酸素結合角)HighLow
        private double[] AiCOs2;//cos2(コア酸素結合角)HighLow
        private double[] AicOS;//sin(コア酸素結合角)の絶対値HighLow
        private double[] AicOS2;//sin2(コア酸素結合角)HighLow
        private double AiKOs;//cos(コア酸素結合角)の和
        private double AiKOs2;//cos2(コア酸素結合角)の和
        private double AikOS;//sin(コア酸素結合角)の絶対値の和
        private double AikOS2;//sin2(コア酸素結合角)の和
        private int[] DiCPhH;//コアPh High二面角インデックス
        private double[] DCPhH;//コアPh High二面角
        private double cosDCPhHa;//cos(コアPh High二面角)の絶対値の和
        private double cos2DCPhH;//cos2(コアPh High二面角)の和
        private double sinDCPhHa;//sin(コアPh High二面角)の絶対値の和
        private double sin2DCPhH;//sin2(コアPh High二面角)の和
        private int[] DiCPhL;//コアPh Low二面角インデックス
        private double[] DCPhL;//コアPh Low二面角
        private double cosDCPhLa;//cos(コアPh Low二面角)の絶対値の和
        private double cos2DCPhL;//cos2(コアPh Low二面角)の和
        private double sinDCPhLa;//sin(コアPh Low二面角)の絶対値の和
        private double sin2DCPhL;//sin2(コアPh Low二面角)の和
        private double cosDCPha;//cos(コアPh二面角)の絶対値の和
        private double cos2DCPh;//cos2(コアPh二面角)の和
        private double sinDCPha;//sin(コアPh二面角)の絶対値の和
        private double sin2DCPh;//sin2(コアPh二面角)の和
        private int[] DiCFRH;//縮合共役環式構造High二面角インデックス
        private double[] DCFRH;//縮合共役環式構造High二面角
        private double cosDCFRHa;//cos(縮合共役環式構造High二面角)の絶対値の和
        private double cos2DCFRH;//cos2(縮合共役環式構造High二面角)の和
        private double sinDCFRHa;//sin(縮合共役環式構造High二面角)の絶対値の和
        private double sin2DCFRH;//sin2(縮合共役環式構造High二面角)の和
        private int[] DiCFRL;//縮合共役環式構造Low二面角インデックス
        private double[] DCFRL;//縮合共役環式構造Low二面角
        private double cosDCFRLa;//cos(縮合共役環式構造Low二面角)の絶対値の和
        private double cos2DCFRL;//cos2(縮合共役環式構造Low二面角)の和
        private double sinDCFRLa;//sin(縮合共役環式構造Low二面角)の絶対値の和
        private double sin2DCFRL;//sin2(縮合共役環式構造Low二面角)の和
        private double cosDCFRa;//cos(縮合共役環式構造二面角)の絶対値の和
        private double cos2DCFR;//cos2(縮合共役環式構造二面角)の和
        private double sinDCFRa;//sin(縮合共役環式構造二面角)の絶対値の和
        private double sin2DCFR;//sin2(縮合共役環式構造二面角)の和
        private int[] Di11s;//C211'2',C611'6',C211'6',C611'2'の二面角のインデックス
        private double[] D11s;//C211'2',C611'6',C211'6',C611'2'の二面角
        private double D11a;//BINOLの二面角
        private double cosD11a;//cos(BINOLの二面角)
        private double[] rcds;//回転定数の逆数、慣性モーメントと正比例する
        private double rcI;//回転定数の逆数の和
        private double rcH;//回転定数の和
        private double[,] OvIm;//重なり積分行列
        private double[] CPhhmLAB;//コアPh HOMO局在/異相/同相電子
        private double[] CPhlmLAB;//コアPh LUMO局在/異相/同相電子
        private double[] CPhshmLAB;//コアPh subHOMO局在/異相/同相電子
        private double[] CPhslmLAB;//コアPh superLUMO局在/異相/同相電子
        private double[] CFRhmLAB;//縮合共役環式構造HOMO局在/異相/同相電子
        private double[] CFRlmLAB;//縮合共役環式構造LUMO局在/異相/同相電子
        private double[] CFRshmLAB;//縮合共役環式構造subHOMO局在/異相/同相電子
        private double[] CFRslmLAB;//縮合共役環式構造superLUMO局在/異相/同相電子
        private double[] CFROhmLAB;//コアO-CFR HOMO局在/異相/同相電子
        private double[] CFROlmLAB;//コアO-CFR LUMO局在/異相/同相電子
        private double[] CFROshmLAB;//コアO-CFR subHOMO局在/異相/同相電子
        private double[] CFROslmLAB;//コアO-CFR superLUMO局在/異相/同相電子
        private double[] sub3hmLAB;//3位置換基HOMO局在/異相/同相電子
        private double[] sub3lmLAB;//3位置換基LUMO局在/異相/同相電子
        private double[] sub3shmLAB;//3位置換基subHOMO局在/異相/同相電子
        private double[] sub3slmLAB;//3位置換基superLUMO局在/異相/同相電子
        private double[] BINOLdDF;//密度行列跡/フロベニウス
        private double[] CPhdxDFzF;//コアPh密度疎行列跡/フロベニウス、小行列フロベニウス
        private double[] CFRdxDFzF;//縮合共役環式構造密度疎行列跡/フロベニウス、小行列フロベニウス
        private double[] CoOdxDF;//コアO密度疎行列跡/フロベニウス
        private double[] sub3dxDFzF;//3位置換基密度疎行列跡/フロベニウス、小行列フロベニウス
        private double[] BINOLpDF;//Mulliken電子解析行列跡/フロベニウス
        private double[] CPhpxDFzF;//コアPh Mulliken電子解析疎行列跡/フロベニウス、小行列フロベニウス
        private double[] CFRpxDFzF;//縮合共役環式構造Mulliken電子解析疎行列跡/フロベニウス、小行列フロベニウス
        private double[] CoOpxDF;//コアO Mulliken電子解析疎行列跡/フロベニウス
        private double[] sub3pxDFzF;//3位置換基Mulliken電子解析疎行列跡/フロベニウス、小行列フロベニウス
        private double[] BINOLgpCVR;//総軌道電子核/価/リュードベリ電子
        private double[] CPhgpCVR;//コアPh(総軌道電子)核/価/リュードベリ電子
        private double[] CFRgpCVR;//縮合共役環式構造(総軌道電子)核/価/リュードベリ電子
        private double[] CoOgpCVR;//コアO(総軌道電子)核/価/リュードベリ電子
        private double[] sub3gpCVR;//3位置換基(総軌道電子)核/価/リュードベリ電子
        private double[] CPhHgpCVR;//コアPh High(総軌道電子)核/価/リュードベリ電子
        private double[] CPhLgpCVR;//コアPh Low(総軌道電子)核/価/リュードベリ電子
        private double[] CFRHgpCVR;//縮合共役環式構造High(総軌道電子)核/価/リュードベリ電子
        private double[] CFRLgpCVR;//縮合共役環式構造Low(総軌道電子)核/価/リュードベリ電子
        private double[] CoOHgpCVR;//コアO High(総軌道電子)核/価/リュードベリ電子
        private double[] CoOLgpCVR;//コアO Low(総軌道電子)核/価/リュードベリ電子
        private double[] sub3HgpCVR;//3位置換基High(総軌道電子)核/価/リュードベリ電子
        private double[] sub3LgpCVR;//3位置換基Low(総軌道電子)核/価/リュードベリ電子
        private double[] CPhMcGDQ;//コアPh Mulliken電荷High/Low/Total
        private double[] CFRMcGDQ;//縮合共役環式構造Mulliken電荷High/Low/Total
        private double[] CoOMcGDQ;//コアO Mulliken電荷High/Low/Total
        private double[] sub3McGDQ;//3位置換基Mulliken電荷High/Low/Total
        private double[] C1McGDQ;//C1 Mulliken電荷High/Low/Total
        private double[] C2McGDQ;//C2 Mulliken電荷High/Low/Total
        private double[] C3McGDQ;//C3 Mulliken電荷High/Low/Total
        private double[] CFRMhcGDQ;//縮合共役環式構造Mulliken重原子電荷High/Low/Total
        private double DpMMh;//双極子p=1ノルム
        private double[] QdMSkMhFb;//四極子蹟/p=1ノルム/フロベニウスノルム
        private double[] TQdMMhFb;//跡無し四極子p=1ノルム/フロベニウスノルム
        private double[] OcMSkMhFb;//八極子蹟/p=1ノルム/フロベニウスノルム
        private double[] HxMSkMhFb;//十六極子蹟/p=1ノルム/フロベニウスノルム
        private double[] CPhHfP;//コアPh総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] CPhHHfP;//コアPh high総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] CPhLHfP;//コアPh low総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] CoOHfp;//コアO総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] CoOHHfp;//コアO high総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] CoOLHfp;//コアO low総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] sub3HfP;//3位置換基総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] CFRHfP;//縮合共役環式構造総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] C1HfP;//C1総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] C2HfP;//C2総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] C3HfP;//C3総Hirshfeld電子CAB/Hirshfeld双極子モーメント
        private double[] HDipN;//Hirshfeld Dip norm (charge/total)
        private double[] CPhHfC;//コアPh Hirshfeld原子電荷/CM5電荷
        private double[] CPhHHfC;//コアPh High Hirshfeld原子電荷/CM5電荷
        private double[] CPhLHfC;//コアPh Low Hirshfeld原子電荷/CM5電荷
        private double[] CoOHfC;//コアO Hirshfeld原子電荷/CM5電荷
        private double[] CoOHHfC;//コアO High Hirshfeld原子電荷/CM5電荷
        private double[] CoOLHfC;//コアO Low Hirshfeld原子電荷/CM5電荷
        private double[] sub3HfC;//3位置換基Hirshfeld原子電荷/CM5電荷
        private double[] sub3HHfC;//3位置換基High Hirshfeld原子電荷/CM5電荷
        private double[] sub3LHfC;//3位置換基Low Hirshfeld原子電荷/CM5電荷
        private double[] CFRHfC;//縮合共役環式構造Hirshfeld原子電荷/CM5電荷
        private double[] CFRHHfC;//縮合共役環式構造High Hirshfeld原子電荷/CM5電荷
        private double[] CFRLHfC;//縮合共役環式構造Low Hirshfeld原子電荷/CM5電荷
        private double[] C1HfC;//C1 Hirshfeld原子電荷/CM5電荷
        private double[] C2HfC;//C2 Hirshfeld原子電荷/CM5電荷
        private double[] C3HfC;//C3 Hirshfeld原子電荷/CM5電荷
        private double[] CFRHfhC;//縮合共役環式構造Hirshfeld重原子電荷/CM5電荷
        private double[] CFRHHfhC;//縮合共役環式構造High Hirshfeld重原子電荷/CM5電荷
        private double[] CFRLHfhC;//縮合共役環式構造Low Hirshfeld重原子電荷/CM5電荷
        private double[] moevov;//総軌道エネルギーO/V
        private double[] tokeov;//総軌道運動エネルギーO/V
        private double[] CPhEcKTZ;//コアPh ESP電荷 High/Low/total
        private double[] CoOEcKTZ;//コアO ESP電荷 High/Low/total
        private double[] sub3EcKTZ;//3位置換基ESP電荷 High/Low/total
        private double[] CFREcKTZ;//縮合共役環式構造ESP電荷 High/Low/total
        private double[] C123Ec;//C1/C2/C3 ESP電荷
        private double[] CFREhcKTZ;//縮合共役環式構造ESP重原子電荷 High/Low/total
        private double CPhEp;//コアPh原子電位
        private double CoOEp;//コアO原子電位
        private double CFREp;//縮合共役環式構造原子電位
        private double[] C123Ep;//C1/C2/C3原子電位
        private double[] CPhNAOOvrEvr;//コアPh自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] CPhHNAOOvrEvr;//コアPh High自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] CPhLNAOOvrEvr;//コアPh Low自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] CoONAOOvrEvr;//コアO自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] sub3NAOOvrEvr;//3位置換基自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] sub3HNAOOvrEvr;//3位置換基High自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] sub3LNAOOvrEvr;//3位置換基Low自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] CFRNAOOvrEvr;//縮合共役環式構造自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] CFRHNAOOvrEvr;//縮合共役環式構造High自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] CFRLNAOOvrEvr;//縮合共役環式構造Low自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] C1NAOOvrEvr;//C1自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] C2NAOOvrEvr;//C2自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] C3NAOOvrEvr;//C3自然価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        private double[] CoOHNAOEvr;//コアO High自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] CoOLNAOEvr;//コアO Low自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] C1HNAOEvr;//C1 High自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] C1LNAOEvr;//C1 Low自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] C2HNAOEvr;//C2 High自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] C2LNAOEvr;//C2 Low自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] C3HNAOEvr;//C3 High自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] C3LNAOEvr;//C3 Low自然価電子エネルギー/リュードベリ電子エネルギー
        private double[] CPhNAOcGDQ;//コアPh自然電荷High/Low/total
        private double CoONAOc;//コアO自然電荷total
        private double[] sub3NAOcGDQ;//3位置換基自然電荷High/Low/total
        private double[] CFRNAOcGDQ;//縮合共役環式構造自然電荷High/Low/total
        private double[] C123NAOc;//C1/C2/C3自然電荷
        private double[] sub3NAOtGDQ;//3位置換基自然全電子High/Low/total
        private double[] CPhN2s2p;//コアPh自然2s電子/2p電子
        private double[] sub3N2s2p;//3位置換基自然2s電子/2p電子
        private double[] sub3Nnsnp;//3位置換基自然ns電子/np電子
        private double[] CFRN2s2p;//縮合共役環式構造自然2s電子/2p電子
        private double[] C1N2s2p;//C1自然2s電子/2p電子
        private double[] C2N2s2p;//C2自然2s電子/2p電子
        private double[] C3N2s2p;//C3自然2s電子/2p電子
        private int[][] CPhBD1THL;//コアPh BD1インデックスtotal/High/Low
        private double[] CPhBD1espd;//コアPh BD1電子total/s/p/d
        private double[] CPhHBD1espd;//コアPh High BD1電子total/s/p/d
        private double[] CPhLBD1espd;//コアPh Low BD1電子total/s/p/d
        private int[][] CPhBD2THL;//コアPh BD2インデックスtotal/High/Low
        private double[] CPhBD2pd;//コアPh BD2電子p/d
        private double[] CPhHBD2pd;//コアPh High BD2電子p/d
        private double[] CPhLBD2pd;//コアPh Low BD2電子p/d
        private int[][] CPhBDs1THL;//コアPh BD*1インデックスtotal/High/Low
        private double[] CPhBDs1espd;//コアPh BD*1電子total/s/p/d
        private double[] CPhHBDs1espd;//コアPh High BD*1電子total/s/p/d
        private double[] CPhLBDs1espd;//コアPh Low BD*1電子total/s/p/d
        private int[][] CPhBDs2THL;//コアPh BD*2インデックスtotal/High/Low
        private double[] CPhBDs2pd;//コアPh BD*2電子p/d
        private double[] CPhHBDs2pd;//コアPh High BD*2電子p/d
        private double[] CPhLBDs2pd;//コアPh Low BD*2電子p/d
        private int[][] CFRBD1THL;//縮合共役環式構造BD1インデックスtotal/High/Low
        private double[] CFRBD1espd;//縮合共役環式構造BD1電子total/s/p/d
        private double[] CFRHBD1espd;//縮合共役環式構造High BD1電子total/s/p/d
        private double[] CFRLBD1espd;//縮合共役環式構造Low BD1電子total/s/p/d
        private int[][] CFRBD2THL;//縮合共役環式構造BD2インデックスtotal/High/Low
        private double[] CFRBD2pd;//縮合共役環式構造BD2電子p/d
        private double[] CFRHBD2pd;//縮合共役環式構造High BD2電子p/d
        private double[] CFRLBD2pd;//縮合共役環式構造Low BD2電子p/d
        private int[][] CFRBDs1THL;//縮合共役環式構造BD*1インデックスtotal/High/Low
        private double[] CFRBDs1espd;//縮合共役環式構造BD*1電子total/s/p/d
        private double[] CFRHBDs1espd;//縮合共役環式構造High BD*1電子total/s/p/d
        private double[] CFRLBDs1espd;//縮合共役環式構造Low BD*1電子total/s/p/d
        private int[][] CFRBDs2THL;//縮合共役環式構造BD*2インデックスtotal/High/Low
        private double[] CFRBDs2pd;//縮合共役環式構造BD*2電子p/d
        private double[] CFRHBDs2pd;//縮合共役環式構造High BD*2電子p/d
        private double[] CFRLBDs2pd;//縮合共役環式構造Low BD*2電子p/d
        private int[][] sub3BD2THL;//3位置換基BD2インデックスtotal/High/Low
        private double[] sub3BD2pd;//3位置換基BD2電子p/d
        private double[] sub3HBD2pd;//3位置換基High BD2電子p/d
        private double[] sub3LBD2pd;//3位置換基Low BD2電子p/d
        private int[][] sub3BDs2THL;//3位置換基BD*2インデックスtotal/High/Low
        private double[] sub3BDs2pd;//3位置換基BD*2電子p/d
        private double[] sub3HBDs2pd;//3位置換基High BD*2電子p/d
        private double[] sub3LBDs2pd;//3位置換基Low BD*2電子p/d
        private int[][] sub3L2THL;//3位置換基L層LPインデックスtotal/High/Low
        private double[] sub3L2espd;//3位置換基L層LP電子total/s/p/d
        private double[] sub3HL2espd;//3位置換基High L層LP電子total/s/p/d
        private double[] sub3LL2espd;//3位置換基Low L層LP電子total/s/p/d
        private int[][] sub3LnTHL;//3位置換基M+層LPインデックスtotal/High/Low
        private double[] sub3Lnespd;//3位置換基M+層LP電子total/s/p/d
        private double[] sub3HLnespd;//3位置換基High M+層LP電子total/s/p/d
        private double[] sub3LLnespd;//3位置換基Low M+層LP電子total/s/p/d
        private int[][] C11BDBDs;//C1-C1'BD/BD*インデックス
        private double[] C11BDespd;//C1-C1'BD電子total/s/p/d
        private double[] C11BDsespd;//C1-C1'BD*電子total/s/p/d
        private int[][] C2OBDTHL;//C2-O BDインデックス total/High/Low
        private double[] C2OBDespd;//C2-O BD電子total/s/p/d
        private double[] C2OHBDespd;//C2-O High BD電子total/s/p/d
        private double[] C2OLBDespd;//C2-O Low BD電子total/s/p/d
        private int[][] C2OBDsTHL;//C2-O BD*インデックス total/High/Low
        private double[] C2OBDsespd;//C2-O BD*電子total/s/p/d
        private double[] C2OHBDsespd;//C2-O High BD*電子total/s/p/d
        private double[] C2OLBDsespd;//C2-O Low BD*電子total/s/p/d
        private int[][] C3sBDTHL;//C3-sub BDインデックス total/High/Low
        private double[] C3sBDespd;//C3-sub BD電子total/s/p/d
        private double[] C3sHBDespd;//C3-sub High BD電子total/s/p/d
        private double[] C3sLBDespd;//C3-sub Low BD電子total/s/p/d
        private int[][] C3sBDsTHL;//C3-sub BD*インデックス total/High/Low
        private double[] C3sBDsespd;//C3-sub BD*電子total/s/p/d
        private double[] C3sHBDsespd;//C3-sub High BD*電子total/s/p/d
        private double[] C3sLBDsespd;//C3-sub Low BD*電子total/s/p/d
        private int[][] CoOLTHL;//コアO LPインデックス total/High/Low
        private double[] CoOLespd;//コアO LP電子total/s/p/d
        private double[] CoOHLespd;//コアO High LP電子total/s/p/d
        private double[] CoOLLespd;//コアO Low LP電子total/s/p/d
        private double[] NHOSk1sin2TCS;//NBHσ結合曲りsin2和total/縮合共役環式構造/3位置換基
        private double[] NHOSk1cosTCS;//NBHσ結合曲りcos和total/縮合共役環式構造/3位置換基
        private double[] NHOSk2cos2TCS;//NBHπ結合曲りcos2和total/縮合共役環式構造/3位置換基
        private double[] NHOSk2sinTCS;//NBHπ結合曲りsin和total/縮合共役環式構造/3位置換基
        private double[] CoPh1DonZGD;//コアPh σ結合ドナー安定化エネルギーtotal/High/Low
        private double[] CoPh2DonZGD;//コアPh π結合ドナー安定化エネルギーtotal/High/Low
        private double[] CoPhAccZGD;//コアPh アクセプター安定化エネルギーtotal/High/Low
        private double[] CFR1DonZGD;//縮合共役環式構造σ結合ドナー安定化エネルギーtotal/High/Low
        private double[] CFR2DonZGD;//縮合共役環式構造π結合ドナー安定化エネルギーtotal/High/Low
        private double[] CFRAccZGD;//縮合共役環式構造アクセプター安定化エネルギーtotal/High/Low
        private double[] sub32DonZGD;//3位置換基π結合ドナー安定化エネルギーtotal/High/Low
        private double[] sub3L2DonZGD;//3位置換基L層LPドナー安定化エネルギーtotal/High/Low
        private double[] sub3LnDonZGD;//3位置換基M+層LPドナー安定化エネルギーtotal/High/Low
        private double[] sub3AccZGD;//3位置換基アクセプター安定化エネルギーtotal/High/Low
        private double[] C11DonAcc;//C1-C1'ドナー/アクセプター安定化エネルギー
        private double[] C2ODonZGD;//C2-Oドナー安定化エネルギーtotal/High/Low
        private double[] C2OAccZGD;//C2-Oアクセプター安定化エネルギーtotal/High/Low
        private double[] C3sDonZGD;//C3-sub3ドナー安定化エネルギーtotal/High/Low
        private double[] C3sAccZGD;//C3-sub3アクセプター安定化エネルギーtotal/High/Low
        private double[] CoPh1BESKT;//コアPhσ結合NBOエネルギーtotal/High/Low
        private double[] CoPh2BESKT;//コアPhπ結合NBOエネルギーtotal/High/Low
        private double[] CFR1BESKT;//縮合共役環式構造σ結合NBOエネルギーtotal/High/Low
        private double[] CFR2BESKT;//縮合共役環式構造π結合NBOエネルギーtotal/High/Low
        private double[] sub32BESKT;//3位置換基π結合NBOエネルギーtotal/High/Low
        private double[] sub3L2ESKT;//3位置換基L層LP NBOエネルギーtotal/High/Low
        private double[] sub3LnESKT;//3位置換基M+層LP NBOエネルギーtotal/High/Low
        private double C11BE;//C1-C1' NBOエネルギーtotal/High/Low
        private double[] C2OBESKT;//C2-O NBOエネルギーtotal/High/Low
        private double[] C3sBESKT;//C3-sub NBOエネルギーtotal/High/Low
        private double[] CoOLESKT;//コアO LP NBOエネルギーtotal/High/Low
        private double CoPhRYE;//コアPhリュードベリ電子NBOエネルギー
        private double CFRRYE;//縮合共役環式構造リュードベリ電子NBOエネルギー
        private double sub3RYE;//3位置換基リュードベリ電子NBOエネルギー
        private double CoORYE;//コアOリュードベリ電子NBOエネルギー
        private double[] C1GiHGD;//コアC1 GIAO等方磁気遮蔽sum/High/Low
        private double[] C1GaHGD;//コアC1 GIAO異方磁気遮蔽sum/High/Low
        private double[] C1GtFHGD;//コアC1 GIAO磁気遮蔽テンソルフロベニウスsum/High/Low
        private double[] C1GenHGD;//コアC1 GIAO磁気遮蔽固有値ノルムsum/High/Low
        private double[] C2GiHGD;//コアC2 GIAO等方磁気遮蔽sum/High/Low
        private double[] C2GaHGD;//コアC2 GIAO異方磁気遮蔽sum/High/Low
        private double[] C2GtFHGD;//コアC2 GIAO磁気遮蔽テンソルフロベニウスsum/High/Low
        private double[] C2GenHGD;//コアC2 GIAO磁気遮蔽固有値ノルムsum/High/Low
        private double[] C3GiHGD;//コアC3 GIAO等方磁気遮蔽sum/High/Low
        private double[] C3GaHGD;//コアC3 GIAO異方磁気遮蔽sum/High/Low
        private double[] C3GtFHGD;//コアC3 GIAO磁気遮蔽テンソルフロベニウスsum/High/Low
        private double[] C3GenHGD;//コアC3 GIAO磁気遮蔽固有値ノルムsum/High/Low
        private double[] C4GiHGD;//コアC4 GIAO等方磁気遮蔽sum/High/Low
        private double[] C4GaHGD;//コアC4 GIAO異方磁気遮蔽sum/High/Low
        private double[] C4GtFHGD;//コアC4 GIAO磁気遮蔽テンソルフロベニウスsum/High/Low
        private double[] C4GenHGD;//コアC4 GIAO磁気遮蔽固有値ノルムsum/High/Low
        private double[] C5GiHGD;//コアC5 GIAO等方磁気遮蔽sum/High/Low
        private double[] C5GaHGD;//コアC5 GIAO異方磁気遮蔽sum/High/Low
        private double[] C5GtFHGD;//コアC5 GIAO磁気遮蔽テンソルフロベニウスsum/High/Low
        private double[] C5GenHGD;//コアC5 GIAO磁気遮蔽固有値ノルムsum/High/Low
        private double[] C6GiHGD;//コアC6 GIAO等方磁気遮蔽sum/High/Low
        private double[] C6GaHGD;//コアC6 GIAO異方磁気遮蔽sum/High/Low
        private double[] C6GtFHGD;//コアC6 GIAO磁気遮蔽テンソルフロベニウスsum/High/Low
        private double[] C6GenHGD;//コアC6 GIAO磁気遮蔽固有値ノルムsum/High/Low
        private double[] CoOGiHGD;//コアO GIAO等方磁気遮蔽sum/High/Low
        private double[] CoOGaHGD;//コアO GIAO異方磁気遮蔽sum/High/Low
        private double[] CoOGtFHGD;//コアO GIAO磁気遮蔽テンソルフロベニウスsum/High/Low
        private double[] CoOGenHGD;//コアO GIAO磁気遮蔽固有値ノルムsum/High/Low
        private double[] CoPhGiHGD;//コアPh GIAO等方磁気遮蔽総和total/High/Low
        private double[] CoPhGaHGD;//コアPh GIAO異方磁気遮蔽総和total/High/Low
        private double[] CoPhGtFHGD;//コアPh GIAO磁気遮蔽テンソルフロベニウス総和total/High/Low
        private double[] CoPhGenHGD;//コアPh GIAO磁気遮蔽固有値ノルム総和total/High/Low
        private double[] CFRGiHGD;//縮合共役環式構造GIAO等方磁気遮蔽総和total/High/Low
        private double[] CFRGaHGD;//縮合共役環式構造GIAO異方磁気遮蔽総和total/High/Low
        private double[] CFRGtFHGD;//縮合共役環式構造GIAO磁気遮蔽テンソルフロベニウス総和total/High/Low
        private double[] CFRGenHGD;//縮合共役環式構造GIAO磁気遮蔽固有値ノルム総和total/High/Low
        private double[] dmdpDFT;//磁気双極子分極率行列式/フロベニウスノルム/跡
        private double[] dqctDFT;//DQテンソル行列式/フロベニウスノルム/跡
        private double[] orgtDFT;//旋光Gテンソル行列式/フロベニウスノルム/跡
        private double[] orgeEW;//旋光G固有値ユークリッドノルム/和
        private double[] C123OAc;//コアC1/C2/C3/O APT電荷
        private double[] CoPhAcGDZ;//コアPh APT電荷High/Low/total
        private double[] CFRAcGDZ;//縮合共役環式構造APT電荷High/Low/total
        private double[] sub3AcGDZ;//3位置換基APT電荷High/Low/total
        private double[] CFRhAcGDZ;//縮合共役環式構造重原子APT電荷High/Low/total
        private double[] EPDFT;//精確分極率行列式/フロベニウスノルム/跡
        private double[] APDFT;//近似分極率行列式/フロベニウスノルム/跡
        private double mwfcS;//弾力定数行列低値の和
        private double dvpE;//対角振動分極率ユークリッドノルム
        private double[] TIRke;//総IR振動エネルギー(コアPh/縮合共役環式構造/3位置換基/コアO/コアC1/コアC2/コアC3)
        private double[] h2IRke;//[0-200)cm-1 IR振動エネルギー(コアPh/縮合共役環式構造/3位置換基/コアO/コアC1/コアC2/コアC3)
        private double[] h5IRke;//[200-500)cm-1 IR振動エネルギー(コアPh/縮合共役環式構造/3位置換基/コアO/コアC1/コアC2/コアC3)
        private double[] kIRke;//[500-1000)cm-1 IR振動エネルギー(コアPh/縮合共役環式構造/3位置換基/コアO/コアC1/コアC2/コアC3)
        private double[] khIRke;//[1000-1500)cm-1 IR振動エネルギー(コアPh/縮合共役環式構造/3位置換基/コアO/コアC1/コアC2/コアC3)
        private double[] k2IRke;//[1500-2000)cm-1 IR振動エネルギー(コアPh/縮合共役環式構造/3位置換基/コアO/コアC1/コアC2/コアC3)
        private double[] iIRke;//[2000-)cm-1 IR振動エネルギー(コアPh/縮合共役環式構造/3位置換基/コアO/コアC1/コアC2/コアC3)
        private double[] IRAF;//IR平均波数 ([0-200)/[200-500)/[500-1000)/[1000-1500)/[1500-2000)/[2000-)cm-1)
        private double[] paxDFT;//慣性主軸行列式/フロベニウスノルム/跡
        private double rotts;//回転温度和
        private double[] lfvS;//低周波数振動総内部エネルギー/総等容比熱/総エントロピー/総Bot分配関数(ln)/総V=0分配関数(ln)
        private double[] Vsub3vdWC32RKTS;//3位置換基-コアC3 2R(140*sqrt3) ファンデルワールス半径 占有体積 High/Low/total
        private double[] Vsub3vdWC34RKTS;//3位置換基-コアC3 4R(280*sqrt3) ファンデルワールス半径 占有体積 High/Low/total
        private double[] Vsub3vdWC36RKTS;//3位置換基-コアC3 6R(420*sqrt3) ファンデルワールス半径 占有体積 High/Low/total
        private double[] Vsub3vdWC38RKTS;//3位置換基-コアC3 8R(560*sqrt3) ファンデルワールス半径 占有体積 High/Low/total
        private double[] Vsub3ACC32RKTS;//3位置換基-コアC3 2R(140*sqrt3) 計算原子半径 占有体積 High/Low/total
        private double[] Vsub3ACC34RKTS;//3位置換基-コアC3 4R(280*sqrt3) 計算原子半径 占有体積 High/Low/total
        private double[] Vsub3ACC36RKTS;//3位置換基-コアC3 6R(420*sqrt3) 計算原子半径 占有体積 High/Low/total
        private double[] Vsub3ACC38RKTS;//3位置換基-コアC3 8R(560*sqrt3) 計算原子半径 占有体積 High/Low/total
        private double[] Vsub3AEC32RKTS;//3位置換基-コアC3 2R(140*sqrt3) 経験原子半径 占有体積 High/Low/total
        private double[] Vsub3AEC34RKTS;//3位置換基-コアC3 4R(280*sqrt3) 経験原子半径 占有体積 High/Low/total
        private double[] Vsub3AEC36RKTS;//3位置換基-コアC3 6R(420*sqrt3) 経験原子半径 占有体積 High/Low/total
        private double[] Vsub3AEC38RKTS;//3位置換基-コアC3 8R(560*sqrt3) 経験原子半径 占有体積 High/Low/total
        private double[] Vsub3IEC32RKTS;//3位置換基-コアC3 2R(140*sqrt3) イオン半径(空) 占有体積 High/Low/total
        private double[] Vsub3IEC34RKTS;//3位置換基-コアC3 4R(280*sqrt3) イオン半径(空) 占有体積 High/Low/total
        private double[] Vsub3IEC36RKTS;//3位置換基-コアC3 6R(420*sqrt3) イオン半径(空) 占有体積 High/Low/total
        private double[] Vsub3IEC38RKTS;//3位置換基-コアC3 8R(560*sqrt3) イオン半径(空) 占有体積 High/Low/total
        private double[] Vsub3IAC32RKTS;//3位置換基-コアC3 2R(140*sqrt3) イオン半径(満) 占有体積 High/Low/total
        private double[] Vsub3IAC34RKTS;//3位置換基-コアC3 4R(280*sqrt3) イオン半径(満) 占有体積 High/Low/total
        private double[] Vsub3IAC36RKTS;//3位置換基-コアC3 6R(420*sqrt3) イオン半径(満) 占有体積 High/Low/total
        private double[] Vsub3IAC38RKTS;//3位置換基-コアC3 8R(560*sqrt3) イオン半径(満) 占有体積 High/Low/total
        private double[] Vsub3vdWOc;//3位置換基-コアO中心 ファンデルワールス半径 占有体積 2R/4R/6R/8R
        private double[] Vsub3ACOc;//3位置換基-コアO中心 計算原子半径 占有体積 2R/4R/6R/8R
        private double[] Vsub3AEOc;//3位置換基-コアO中心 経験原子半径 占有体積 2R/4R/6R/8R
        private double[] Vsub3IEOc;//3位置換基-コアO中心 イオン半径(空) 占有体積 2R/4R/6R/8R
        private double[] Vsub3IAOc;//3位置換基-コアO中心 イオン半径(満) 占有体積 2R/4R/6R/8R
        private double[] EnPsub3Oc;//3位置換基-コアO中心 原子環境ポテンシャル(電子親和力(kJ/mol)/ポーリングの電気陰性度/アレンの電気陰性度/マリケンの電気陰性度/有効核電荷/第1イオン化エネルギー(kJ/mol))
        private double[] EnPsub3Oc2;//3位置換基-コアO中心 原子環境ポテンシャル(r二乗)(電子親和力(kJ/mol)/ポーリングの電気陰性度/アレンの電気陰性度/マリケンの電気陰性度/有効核電荷/第1イオン化エネルギー(kJ/mol))
        private double[] ElPsub3Oc;//3位置換基-コアO中心 電荷環境ポテンシャル(マリケン電荷/et1はHirshfeld原子電荷/et2はHirshfeld原子CM5電荷/et3はESP電荷/et4は自然電荷/et5はAPT電荷)
        private double[] ElPsub3Oc2;//3位置換基-コアO中心 電荷環境ポテンシャル(r二乗)(マリケン電荷/et1はHirshfeld原子電荷/et2はHirshfeld原子CM5電荷/et3はESP電荷/et4は自然電荷/et5はAPT電荷)
        private double[] EgoPsub3Oc;//3位置換基-コアO中心 総軌道密度環境ポテンシャル(L層価電子/L層リュードベリ電子/M+層価電子/M+層リュードベリ電子/π価電子/πリュードベリ電子)
        private double[] EgoPsub3Oc2;//3位置換基-コアO中心 総軌道密度環境ポテンシャル(r二乗)(L層価電子/L層リュードベリ電子/M+層価電子/M+層リュードベリ電子/π価電子/πリュードベリ電子)
        private double[] EnoPsub3Oc;//3位置換基-コアO中心 NBO環境ポテンシャル(L層/M+層/π/π*)
        private double[] EnoPsub3Oc2;//3位置換基-コアO中心 NBO環境ポテンシャル(r二乗)(L層/M+層/π/π*)
        private double[] EnoPwLsub3Oc;//3位置換基-コアO中心 重み付きNBO環境ポテンシャル(ロンペア)(ファンデルワールス半径(pm)/計算原子半径(pm)/経験原子半径(pm)/イオン半径(空)(pm)/イオン半径(満)(pm)/ポーリングの電気陰性度/アレンの電気陰性度/マリケンの電気陰性度)
        private double[] EnoPwLsub3Oc2;//3位置換基-コアO中心 重み付きNBO環境ポテンシャル(r二乗)(ロンペア)(ファンデルワールス半径(pm)/計算原子半径(pm)/経験原子半径(pm)/イオン半径(空)(pm)/イオン半径(満)(pm)/ポーリングの電気陰性度/アレンの電気陰性度/マリケンの電気陰性度)
        private double[] DipAcos;//双極子モーメント角度cos C1-C1'/C2-O high/C2-O low
        private double[] DipAsin;//双極子モーメント角度sin C1-C1'/C2-O high/C2-O low
        private double[] dpamDFT;//電気双極子分極率Alpha行列行列式/フロベニウスノルム/跡
        internal GauDesc(FileInfo fi)
        {
            fpth = fi.FullName;
            fdir = fi.DirectoryName;
            try
            {
                gl = new GLogReader(in fpth);
            }
            catch (FileNotFoundException fne)
            {
                Console.WriteLine("fne : {0}\r\nfpth : {1}", fne.Message, fne.FileName);
                return;
            }
            catch (ArgumentNullException ane)
            {
                Console.WriteLine("ane : {0}\r\nParamName : {1}", ane.Message, ane.ParamName);
                return;
            }
            catch (ArgumentOutOfRangeException aore)
            {
                Console.WriteLine("aore : {0}\r\nParamName : {1} -> {2}", aore.Message, aore.ParamName, aore.ActualValue);
                return;
            }
            catch (ArgumentException ae)
            {
                Console.WriteLine("ae : {0}\r\nParamName : {1}", ae.Message, ae.ParamName);
                return;
            }
            catch (Exception e)
            {
                Console.WriteLine("e : {0}\r\n{1}", e.GetType(), e.Message);
                return;
            }
            VldL = true;
            try
            {
                CorSrch();
            }
            catch (ArgumentOutOfRangeException aore)
            {
                Console.WriteLine("aore : {0}\r\nParamName : {1} -> {2}", aore.Message, aore.ParamName, aore.ActualValue);
                return;
            }
            catch (Exception e)
            {
                Console.WriteLine("e : {0}\r\n{1}", e.GetType(), e.Message);
                return;
            }
            VldC = true;
            try
            {
                DescC();
            }
            catch (ArgumentOutOfRangeException aore)
            {
                Console.WriteLine("aore : {0}\r\nParamName : {1} -> {2}", aore.Message, aore.ParamName, aore.ActualValue);
                return;
            }
            catch (Exception e)
            {
                Console.WriteLine("e : {0}\r\n{1}", e.GetType(), e.Message);
                return;
            }
            VldD = true;
        }
        static internal void GauDSRs(in DirectoryInfo di)//記述子を出力する
        {
            if (!di.Exists)
            {
                Console.WriteLine("GauDSRs : Invalid directory.");
                return;
            }
            FileInfo[] fia = di.GetFiles();
            if (fia.Length == 0)
            {
                Console.WriteLine("GauDSRs : No file exists.");
                return;
            }
            StringBuilder sb = new StringBuilder(di.FullName);
            sb.Append(di.FullName.EndsWith("\\", StringComparison.InvariantCultureIgnoreCase) ? "GauDesc" : "\\GauDesc");
            string dirx = GauDesc.NDirC(ref sb);
            GauDesc gd;
            foreach (FileInfo fi in fia)
            {
                if (!fi.Extension.Equals(".log", StringComparison.InvariantCultureIgnoreCase)) continue;
                gd = new GauDesc(fi);
                if (!gd.VldD)
                {
                    Console.WriteLine("GauDSRs : Invalid log file ({0}).", fi.FullName);
                    continue;
                }
                StringBuilder sbt = new StringBuilder();
                StringBuilder sbd = new StringBuilder();
                sbt.Append("an, ");
                sbd.Append(string.Format("{0:N1}, ", gd.gl._an));
                sbt.Append("rn, ");
                sbd.Append(string.Format("{0:N1}, ", gd.gl._rn));
                sbt.Append("rnhk, ");
                sbd.Append(string.Format("{0:G15}, ", (double)gd.gl._rn / gd.gl._an));
                sbt.Append("agn, ");
                sbd.Append(string.Format("{0:N1}, ", gd.gl._agn));
                sbt.Append("agnhk, ");
                sbd.Append(string.Format("{0:G15}, ", (double)gd.gl._agn / gd.gl._an));
                sbt.Append("dn, ");
                sbd.Append(string.Format("{0:N1}, ", gd.gl._dn));
                sbt.Append("dnhk, ");
                sbd.Append(string.Format("{0:G15}, ", (double)gd.gl._dn / gd.gl._an));
                sbt.Append("RC1H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456H[0]));
                sbt.Append("RC2H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456H[1]));
                sbt.Append("RC3H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456H[2]));
                sbt.Append("RC4H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456H[3]));
                sbt.Append("RC5H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456H[4]));
                sbt.Append("RC6H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456H[5]));
                sbt.Append("RCCHhk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Ravg123456H));
                sbt.Append("RC1L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456L[0]));
                sbt.Append("RC2L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456L[1]));
                sbt.Append("RC3L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456L[2]));
                sbt.Append("RC4L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456L[3]));
                sbt.Append("RC5L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456L[4]));
                sbt.Append("RC6L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.R123456L[5]));
                sbt.Append("RCCLhk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Ravg123456L));
                sbt.Append("RCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RavgCPh));
                sbt.Append("RCFRH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RavgCFRH));
                sbt.Append("RCFRL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RavgCFRL));
                sbt.Append("RCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RavgCFR));
                sbt.Append("RC2OH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RC2O[0]));
                sbt.Append("RC2OL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RC2O[1]));
                sbt.Append("RC2O, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RavgC2O));
                sbt.Append("RC11, ");
                sbd.Append(string.Format("{0:G15}, ", gd.RC11));
                sbt.Append("ACPhHcos, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosACPhH));
                sbt.Append("ACPhHcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2ACPhH));
                sbt.Append("ACPhHsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinACPhHa));
                sbt.Append("ACPhHsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2ACPhH));
                sbt.Append("ACPhLcos, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosACPhL));
                sbt.Append("ACPhLcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2ACPhL));
                sbt.Append("ACPhLsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinACPhLa));
                sbt.Append("ACPhLsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2ACPhL));
                sbt.Append("ACPhcos, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosACPh));
                sbt.Append("ACPhcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2ACPh));
                sbt.Append("ACPhsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinACPha));
                sbt.Append("ACPhsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2ACPh));
                sbt.Append("ACFRHcos, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosACFRH));
                sbt.Append("ACFRHcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2ACFRH));
                sbt.Append("ACFRHsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinACFRHa));
                sbt.Append("ACFRHsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2ACFRH));
                sbt.Append("ACFRLcos, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosACFRL));
                sbt.Append("ACFRLcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2ACFRL));
                sbt.Append("ACFRLsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinACFRLa));
                sbt.Append("ACFRLsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2ACFRL));
                sbt.Append("ACFRcos, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosACFR));
                sbt.Append("ACFRcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2ACFR));
                sbt.Append("ACFRsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinACFRa));
                sbt.Append("ACFRsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2ACFR));
                sbt.Append("AiCOsH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AiCOs[0]));
                sbt.Append("AiCOs2H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AiCOs2[0]));
                sbt.Append("AicOSH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AicOS[0]));
                sbt.Append("AicOS2H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AicOS2[0]));
                sbt.Append("AiCOsL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AiCOs[1]));
                sbt.Append("AiCOs2L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AiCOs2[1]));
                sbt.Append("AicOSL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AicOS[1]));
                sbt.Append("AicOS2L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AicOS2[1]));
                sbt.Append("AiKOs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AiKOs));
                sbt.Append("AiKOs2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AiKOs2));
                sbt.Append("AikOSL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AikOS));
                sbt.Append("AikOS2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.AikOS2));
                sbt.Append("DCPhHcosa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosDCPhHa));
                sbt.Append("DCPhHcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2DCPhH));
                sbt.Append("DCPhHsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinDCPhHa));
                sbt.Append("DCPhHsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2DCPhH));
                sbt.Append("DCPhLcosa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosDCPhLa));
                sbt.Append("DCPhLcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2DCPhL));
                sbt.Append("DCPhLsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinDCPhLa));
                sbt.Append("DCPhLsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2DCPhL));
                sbt.Append("DCPhcosa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosDCPha));
                sbt.Append("DCPhcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2DCPh));
                sbt.Append("DCPhsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinDCPha));
                sbt.Append("DCPhsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2DCPh));
                sbt.Append("DCFRHcosa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosDCFRHa));
                sbt.Append("DCFRHcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2DCFRH));
                sbt.Append("DCFRHsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinDCFRHa));
                sbt.Append("DCFRHsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2DCFRH));
                sbt.Append("DCFRLcosa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosDCFRLa));
                sbt.Append("DCFRLcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2DCFRL));
                sbt.Append("DCFRLsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinDCFRLa));
                sbt.Append("DCFRLsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2DCFRL));
                sbt.Append("DCFRcosa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cosDCFRa));
                sbt.Append("DCFRcos2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.cos2DCFR));
                sbt.Append("DCFRsina, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sinDCFRa));
                sbt.Append("DCFRsin2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sin2DCFR));
                sbt.Append("PacBin, ");
                sbd.Append(string.Format("{0:G15}, ", gd.D11a));
                sbt.Append("dofree, ");
                sbd.Append(string.Format("{0:N1}, ", gd.gl._dof));
                sbt.Append("RCDao, ");
                sbd.Append(string.Format("{0:G15}, ", gd.rcI));
                sbt.Append("RCHe, ");
                sbd.Append(string.Format("{0:G15}, ", gd.rcH));
                sbt.Append("eCPhhmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhhmLAB[0]));
                sbt.Append("eCPhhmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhhmLAB[1]));
                sbt.Append("eCPhhmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhhmLAB[2]));
                sbt.Append("eCPhlmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhlmLAB[0]));
                sbt.Append("eCPhlmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhlmLAB[1]));
                sbt.Append("eCPhlmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhlmLAB[2]));
                sbt.Append("eCPhshmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhshmLAB[0]));
                sbt.Append("eCPhshmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhshmLAB[1]));
                sbt.Append("eCPhshmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhshmLAB[2]));
                sbt.Append("eCPhslmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhslmLAB[0]));
                sbt.Append("eCPhslmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhslmLAB[1]));
                sbt.Append("eCPhslmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhslmLAB[2]));
                sbt.Append("eCFRhmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRhmLAB[0]));
                sbt.Append("eCFRhmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRhmLAB[1]));
                sbt.Append("eCFRhmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRhmLAB[2]));
                sbt.Append("eCFRlmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRlmLAB[0]));
                sbt.Append("eCFRlmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRlmLAB[1]));
                sbt.Append("eCFRlmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRlmLAB[2]));
                sbt.Append("eCFRshmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRshmLAB[0]));
                sbt.Append("eCFRshmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRshmLAB[1]));
                sbt.Append("eCFRshmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRshmLAB[2]));
                sbt.Append("eCFRslmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRslmLAB[0]));
                sbt.Append("eCFRslmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRslmLAB[1]));
                sbt.Append("eCFRslmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRslmLAB[2]));
                sbt.Append("eCFROhmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROhmLAB[0]));
                sbt.Append("eCFROhmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROhmLAB[1]));
                sbt.Append("eCFROhmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROhmLAB[2]));
                sbt.Append("eCFROlmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROlmLAB[0]));
                sbt.Append("eCFROlmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROlmLAB[1]));
                sbt.Append("eCFROlmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROlmLAB[2]));
                sbt.Append("eCFROshmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROshmLAB[0]));
                sbt.Append("eCFROshmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROshmLAB[1]));
                sbt.Append("eCFROshmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROshmLAB[2]));
                sbt.Append("eCFROslmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROslmLAB[0]));
                sbt.Append("eCFROslmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROslmLAB[1]));
                sbt.Append("eCFROslmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFROslmLAB[2]));
                sbt.Append("esub3hmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3hmLAB[0]));
                sbt.Append("esub3hmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3hmLAB[1]));
                sbt.Append("esub3hmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3hmLAB[2]));
                sbt.Append("esub3lmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3lmLAB[0]));
                sbt.Append("esub3lmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3lmLAB[1]));
                sbt.Append("esub3lmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3lmLAB[2]));
                sbt.Append("esub3shmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3shmLAB[0]));
                sbt.Append("esub3shmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3shmLAB[1]));
                sbt.Append("esub3shmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3shmLAB[2]));
                sbt.Append("esub3slmKZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3slmLAB[0]));
                sbt.Append("esub3slmIS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3slmLAB[1]));
                sbt.Append("esub3slmDS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3slmLAB[2]));
                sbt.Append("Bindmsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.BINOLdDF[0]));
                sbt.Append("BindmF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.BINOLdDF[1]));
                sbt.Append("CPhdmxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhdxDFzF[0]));
                sbt.Append("CPhdmxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhdxDFzF[1]));
                sbt.Append("CPhdmsF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhdxDFzF[2]));
                sbt.Append("CFRdmxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRdxDFzF[0]));
                sbt.Append("CFRdmxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRdxDFzF[1]));
                sbt.Append("CFRdmsF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRdxDFzF[2]));
                sbt.Append("COdmxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOdxDF[0]));
                sbt.Append("COdmxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOdxDF[1]));
                sbt.Append("sub3dmxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3dxDFzF[0]));
                sbt.Append("sub3dmxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3dxDFzF[1]));
                sbt.Append("sub3dmsF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3dxDFzF[2]));
                sbt.Append("Binmpsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.BINOLpDF[0]));
                sbt.Append("BinmpF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.BINOLpDF[1]));
                sbt.Append("CPhmpxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhpxDFzF[0]));
                sbt.Append("CPhmpxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhpxDFzF[1]));
                sbt.Append("CPhmpsF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhpxDFzF[2]));
                sbt.Append("CFRmpxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRpxDFzF[0]));
                sbt.Append("CFRmpxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRpxDFzF[1]));
                sbt.Append("CFRmpsF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRpxDFzF[2]));
                sbt.Append("COmpxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOpxDF[0]));
                sbt.Append("COmpxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOpxDF[1]));
                sbt.Append("sub3mpxsk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3pxDFzF[0]));
                sbt.Append("sub3mpxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3pxDFzF[1]));
                sbt.Append("sub3mpsF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3pxDFzF[2]));
                sbt.Append("BingpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.BINOLgpCVR[0]));
                sbt.Append("BingpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.BINOLgpCVR[1]));
                sbt.Append("BingpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.BINOLgpCVR[2]));
                sbt.Append("CPhHgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHgpCVR[0]));
                sbt.Append("CPhHgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHgpCVR[1]));
                sbt.Append("CPhHgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHgpCVR[2]));
                sbt.Append("CPhLgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLgpCVR[0]));
                sbt.Append("CPhLgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLgpCVR[1]));
                sbt.Append("CPhLgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLgpCVR[2]));
                sbt.Append("CPhgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhgpCVR[0]));
                sbt.Append("CPhgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhgpCVR[1]));
                sbt.Append("CPhgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhgpCVR[2]));
                sbt.Append("CFRHgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHgpCVR[0]));
                sbt.Append("CFRHgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHgpCVR[1]));
                sbt.Append("CFRHgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHgpCVR[2]));
                sbt.Append("CFRLgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLgpCVR[0]));
                sbt.Append("CFRLgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLgpCVR[1]));
                sbt.Append("CFRLgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLgpCVR[2]));
                sbt.Append("CfRgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRgpCVR[0]));
                sbt.Append("CFRgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRgpCVR[1]));
                sbt.Append("CFRgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRgpCVR[2]));
                sbt.Append("COHgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHgpCVR[0]));
                sbt.Append("COHgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHgpCVR[1]));
                sbt.Append("COHgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHgpCVR[2]));
                sbt.Append("COLgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLgpCVR[0]));
                sbt.Append("COLgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLgpCVR[1]));
                sbt.Append("COLgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLgpCVR[2]));
                sbt.Append("COgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOgpCVR[0]));
                sbt.Append("COgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOgpCVR[1]));
                sbt.Append("COgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOgpCVR[2]));
                sbt.Append("sub3HgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HgpCVR[0]));
                sbt.Append("sub3HgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HgpCVR[1]));
                sbt.Append("sub3HgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HgpCVR[2]));
                sbt.Append("sub3LgpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LgpCVR[0]));
                sbt.Append("sub3LgpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LgpCVR[1]));
                sbt.Append("sub3LgpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LgpCVR[2]));
                sbt.Append("sub3gpH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3gpCVR[0]));
                sbt.Append("sub3gpJ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3gpCVR[1]));
                sbt.Append("sub3gpL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3gpCVR[2]));
                sbt.Append("CPhMcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhMcGDQ[0]));
                sbt.Append("CPhMcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhMcGDQ[1]));
                sbt.Append("CPhMcQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhMcGDQ[2]));
                sbt.Append("CFRMcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRMcGDQ[0]));
                sbt.Append("CFRMcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRMcGDQ[1]));
                sbt.Append("CFRMcQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRMcGDQ[2]));
                sbt.Append("COMcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOMcGDQ[0]));
                sbt.Append("COMcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOMcGDQ[1]));
                sbt.Append("COMcQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOMcGDQ[2]));
                sbt.Append("sub3McG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3McGDQ[0]));
                sbt.Append("sub3McD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3McGDQ[1]));
                sbt.Append("sub3McQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3McGDQ[2]));
                sbt.Append("C1McG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1McGDQ[0]));
                sbt.Append("C1McD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1McGDQ[1]));
                sbt.Append("C1McQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1McGDQ[2]));
                sbt.Append("C2McG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2McGDQ[0]));
                sbt.Append("C2McD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2McGDQ[1]));
                sbt.Append("C2McQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2McGDQ[2]));
                sbt.Append("C3McG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3McGDQ[0]));
                sbt.Append("C3McD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3McGDQ[1]));
                sbt.Append("C3McQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3McGDQ[2]));
                sbt.Append("CFRMhcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRMhcGDQ[0]));
                sbt.Append("CFRMhcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRMhcGDQ[1]));
                sbt.Append("CFRMhcQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRMhcGDQ[2]));
                sbt.Append("han, ");
                sbd.Append(string.Format("{0:N1}, ", gd.gl._han));
                sbt.Append("hana, ");
                sbd.Append(string.Format("{0:G15}, ", (double)gd.gl._han / gd.gl._an));
                sbt.Append("ESE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._ese));
                sbt.Append("DpMMh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.DpMMh));
                sbt.Append("QpMSk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.QdMSkMhFb[0]));
                sbt.Append("QpMMh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.QdMSkMhFb[1]));
                sbt.Append("QpMF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.QdMSkMhFb[2]));
                sbt.Append("TQpMMh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TQdMMhFb[0]));
                sbt.Append("TQpMF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TQdMMhFb[1]));
                sbt.Append("OpMSk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.OcMSkMhFb[0]));
                sbt.Append("OpMMh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.OcMSkMhFb[1]));
                sbt.Append("OpMF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.OcMSkMhFb[2]));
                sbt.Append("HpMSk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.HxMSkMhFb[0]));
                sbt.Append("HpMMh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.HxMSkMhFb[1]));
                sbt.Append("HpMF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.HxMSkMhFb[2]));
                sbt.Append("occmo, ");
                sbd.Append(string.Format("{0:N1}, ", gd.gl._occmo));
                sbt.Append("s2lme, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._s2lme));
                sbt.Append("s2lmke, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._s2lmke));
                sbt.Append("slme, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._slme));
                sbt.Append("slmke, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._slmke));
                sbt.Append("lme, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lme));
                sbt.Append("lmke, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lmke));
                sbt.Append("hme, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._hme));
                sbt.Append("hmke, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._hmke));
                sbt.Append("shme, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._shme));
                sbt.Append("shmke, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._shmke));
                sbt.Append("s2hme, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._s2hme));
                sbt.Append("s2hmke, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._s2hmke));
                sbt.Append("nnrepe, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nnrepe));
                sbt.Append("enatre, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._enatre));
                sbt.Append("keknte, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._keknte));
                sbt.Append("EIsd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._eisd));
                sbt.Append("EIsad, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._eisad));
                sbt.Append("CPhHHfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHHfP[0]));
                sbt.Append("CPhHHfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHHfP[1]));
                sbt.Append("CPhLHfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLHfP[0]));
                sbt.Append("CPhLHfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLHfP[1]));
                sbt.Append("CPhHfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHfP[0]));
                sbt.Append("CPhHfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHfP[1]));
                sbt.Append("COHHfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHHfp[0]));
                sbt.Append("COHHfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHHfp[1]));
                sbt.Append("COLHfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLHfp[0]));
                sbt.Append("COLHfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLHfp[1]));
                sbt.Append("COHfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHfp[0]));
                sbt.Append("COHfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHfp[1]));
                sbt.Append("CFRHfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfP[0]));
                sbt.Append("CFRHfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfP[1]));
                sbt.Append("CFRHfCa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfP[0] / gd.gl._an));
                sbt.Append("CFRHfDa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfP[1] / gd.gl._an));
                sbt.Append("sub3HfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HfP[0]));
                sbt.Append("sub3HfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HfP[1]));
                sbt.Append("sub3HfCa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HfP[0] / gd.gl._an));
                sbt.Append("sub3HfDa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HfP[1] / gd.gl._an));
                sbt.Append("C1HfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1HfP[0]));
                sbt.Append("C1HfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1HfP[1]));
                sbt.Append("C2HfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2HfP[0]));
                sbt.Append("C2HfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2HfP[1]));
                sbt.Append("C3HfC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3HfP[0]));
                sbt.Append("C3HfD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3HfP[1]));
                sbt.Append("HDipN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.HDipN[0]));
                sbt.Append("HDipT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.HDipN[1]));
                sbt.Append("CPhHHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHHfC[0]));
                sbt.Append("CPhHHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHHfC[1]));
                sbt.Append("CPhLHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLHfC[0]));
                sbt.Append("CPhLHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLHfC[1]));
                sbt.Append("CPhHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHfC[0]));
                sbt.Append("CPhHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHfC[1]));
                sbt.Append("COHHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHHfC[0]));
                sbt.Append("COHHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHHfC[1]));
                sbt.Append("COLHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLHfC[0]));
                sbt.Append("COLHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLHfC[1]));
                sbt.Append("COHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHfC[0]));
                sbt.Append("COHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHfC[1]));
                sbt.Append("CFRHHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHHfC[0]));
                sbt.Append("CFRHHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHHfC[1]));
                sbt.Append("CFRLHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLHfC[0]));
                sbt.Append("CFRLHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLHfC[1]));
                sbt.Append("CFRHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfC[0]));
                sbt.Append("CFRHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfC[1]));
                sbt.Append("sub3HHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HHfC[0]));
                sbt.Append("sub3HHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HHfC[1]));
                sbt.Append("sub3LHfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LHfC[0]));
                sbt.Append("sub3LHfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LHfC[1]));
                sbt.Append("sub3Hfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HfC[0]));
                sbt.Append("sub3Hfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HfC[1]));
                sbt.Append("C1Hfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1HfC[0]));
                sbt.Append("C1Hfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1HfC[1]));
                sbt.Append("C2Hfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2HfC[0]));
                sbt.Append("C2Hfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2HfC[1]));
                sbt.Append("C3Hfc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3HfC[0]));
                sbt.Append("C3Hfcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3HfC[1]));
                sbt.Append("CFRHHfhc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHHfhC[0]));
                sbt.Append("CFRHHfhcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHHfhC[1]));
                sbt.Append("CFRLHfhc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLHfhC[0]));
                sbt.Append("CFRLHfhcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLHfhC[1]));
                sbt.Append("CFRHfhc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfhC[0]));
                sbt.Append("CFRHfhcm5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHfhC[1]));
                sbt.Append("moevO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.moevov[0]));
                sbt.Append("moevV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.moevov[1]));
                sbt.Append("moevOa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.moevov[0] / gd.gl._occmo));
                sbt.Append("moevVa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.moevov[1] / gd.gl._vrtmo));
                sbt.Append("tokeO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.tokeov[0]));
                sbt.Append("tokeV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.tokeov[1]));
                sbt.Append("tokeOa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.tokeov[0] / gd.gl._occmo));
                sbt.Append("tokeVa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.tokeov[1] / gd.gl._vrtmo));
                sbt.Append("CPhEcK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhEcKTZ[0]));
                sbt.Append("CPhEcT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhEcKTZ[1]));
                sbt.Append("CPhEcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhEcKTZ[2]));
                sbt.Append("CFREcK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREcKTZ[0]));
                sbt.Append("CFREcT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREcKTZ[1]));
                sbt.Append("CFREcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREcKTZ[2]));
                sbt.Append("COEcK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOEcKTZ[0]));
                sbt.Append("COEcT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOEcKTZ[1]));
                sbt.Append("COEcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOEcKTZ[2]));
                sbt.Append("sub3EcK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3EcKTZ[0]));
                sbt.Append("sub3EcT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3EcKTZ[1]));
                sbt.Append("sub3EcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3EcKTZ[2]));
                sbt.Append("C1Ec, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123Ec[0]));
                sbt.Append("C2Ec, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123Ec[1]));
                sbt.Append("C3Ec, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123Ec[2]));
                sbt.Append("CFREhcK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREhcKTZ[0]));
                sbt.Append("CFREhcT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREhcKTZ[1]));
                sbt.Append("CFREhcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREhcKTZ[2]));
                sbt.Append("CPhEp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhEp));
                sbt.Append("CPhEpa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhEp / 12));
                sbt.Append("CFREp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREp));
                sbt.Append("CFREpa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFREp / gd.CFRn));
                sbt.Append("COEp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOEp));
                sbt.Append("C1Ep, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123Ep[0]));
                sbt.Append("C2Ep, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123Ep[1]));
                sbt.Append("C3Ep, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123Ep[2]));
                sbt.Append("Hchgt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._Hchgt));
                sbt.Append("EDD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._EDD));
                sbt.Append("toke, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._toke));
                sbt.Append("tokea, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._toke / gd.gl._bfn));
                sbt.Append("ESPdp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._ESPdipt));
                sbt.Append("CPhHNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHNAOOvrEvr[0]));
                sbt.Append("CPhHNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHNAOOvrEvr[1]));
                sbt.Append("CPhHNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHNAOOvrEvr[2]));
                sbt.Append("CPhHNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHNAOOvrEvr[3]));
                sbt.Append("CPhLNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLNAOOvrEvr[0]));
                sbt.Append("CPhLNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLNAOOvrEvr[1]));
                sbt.Append("CPhLNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLNAOOvrEvr[2]));
                sbt.Append("CPhLNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLNAOOvrEvr[3]));
                sbt.Append("CPhNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhNAOOvrEvr[0]));
                sbt.Append("CPhNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhNAOOvrEvr[1]));
                sbt.Append("CPhNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhNAOOvrEvr[2]));
                sbt.Append("CPhNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhNAOOvrEvr[3]));
                sbt.Append("CFRHNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[0]));
                sbt.Append("CFRHNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[1]));
                sbt.Append("CFRHNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[2]));
                sbt.Append("CFRHNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[3]));
                sbt.Append("CFRLNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[0]));
                sbt.Append("CFRLNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[1]));
                sbt.Append("CFRLNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[2]));
                sbt.Append("CFRLNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[3]));
                sbt.Append("CFRNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[0]));
                sbt.Append("CFRNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[1]));
                sbt.Append("CFRNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[2]));
                sbt.Append("CFRNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[3]));
                sbt.Append("COHNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHNAOEvr[0]));
                sbt.Append("COHNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHNAOEvr[1]));
                sbt.Append("COLNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLNAOEvr[0]));
                sbt.Append("COLNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLNAOEvr[1]));
                sbt.Append("CONAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoONAOOvrEvr[0]));
                sbt.Append("CONAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoONAOOvrEvr[1]));
                sbt.Append("CONAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoONAOOvrEvr[2]));
                sbt.Append("CONAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoONAOOvrEvr[3]));
                sbt.Append("C1HNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1HNAOEvr[0]));
                sbt.Append("C1HNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1HNAOEvr[1]));
                sbt.Append("C1LNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1LNAOEvr[0]));
                sbt.Append("C1LNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1LNAOEvr[1]));
                sbt.Append("C1NAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1NAOOvrEvr[0]));
                sbt.Append("C1NAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1NAOOvrEvr[1]));
                sbt.Append("C1NAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1NAOOvrEvr[2]));
                sbt.Append("C1NAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1NAOOvrEvr[3]));
                sbt.Append("C2HNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2HNAOEvr[0]));
                sbt.Append("C2HNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2HNAOEvr[1]));
                sbt.Append("C2LNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2LNAOEvr[0]));
                sbt.Append("C2LNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2LNAOEvr[1]));
                sbt.Append("C2NAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2NAOOvrEvr[0]));
                sbt.Append("C2NAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2NAOOvrEvr[1]));
                sbt.Append("C2NAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2NAOOvrEvr[2]));
                sbt.Append("C2NAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2NAOOvrEvr[3]));
                sbt.Append("C3HNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3HNAOEvr[0]));
                sbt.Append("C3HNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3HNAOEvr[1]));
                sbt.Append("C3LNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3LNAOEvr[0]));
                sbt.Append("C3LNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3LNAOEvr[1]));
                sbt.Append("C3NAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3NAOOvrEvr[0]));
                sbt.Append("C3NAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3NAOOvrEvr[1]));
                sbt.Append("C3NAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3NAOOvrEvr[2]));
                sbt.Append("C3NAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3NAOOvrEvr[3]));
                sbt.Append("sub3HNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[0]));
                sbt.Append("sub3HNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[1]));
                sbt.Append("sub3HNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[2]));
                sbt.Append("sub3HNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[3]));
                sbt.Append("sub3LNAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[0]));
                sbt.Append("sub3LNAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[1]));
                sbt.Append("sub3LNAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[2]));
                sbt.Append("sub3LNAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[3]));
                sbt.Append("sub3NAOok, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[0]));
                sbt.Append("sub3NAOor, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[1]));
                sbt.Append("sub3NAOek, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[2]));
                sbt.Append("sub3NAOer, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[3]));
                sbt.Append("CFRHNAOoka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[0] / gd.CFRn));
                sbt.Append("CFRHNAOora, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[1] / gd.CFRn));
                sbt.Append("CFRHNAOeka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[2] / gd.CFRn));
                sbt.Append("CFRHNAOera, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHNAOOvrEvr[3] / gd.CFRn));
                sbt.Append("CFRLNAOoka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[0] / gd.CFRn));
                sbt.Append("CFRLNAOora, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[1] / gd.CFRn));
                sbt.Append("CFRLNAOeka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[2] / gd.CFRn));
                sbt.Append("CFRLNAOera, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLNAOOvrEvr[3] / gd.CFRn));
                sbt.Append("CFRNAOoka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[0] / gd.CFRn));
                sbt.Append("CFRNAOora, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[1] / gd.CFRn));
                sbt.Append("CFRNAOeka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[2] / gd.CFRn));
                sbt.Append("CFRNAOera, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOOvrEvr[3] / gd.CFRn));
                sbt.Append("sub3HNAOoka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[0] / gd.sub3n));
                sbt.Append("sub3HNAOora, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[1] / gd.sub3n));
                sbt.Append("sub3HNAOeka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[2] / gd.sub3n));
                sbt.Append("sub3HNAOera, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HNAOOvrEvr[3] / gd.sub3n));
                sbt.Append("sub3LNAOoka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[0] / gd.sub3n));
                sbt.Append("sub3LNAOora, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[1] / gd.sub3n));
                sbt.Append("sub3LNAOeka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[2] / gd.sub3n));
                sbt.Append("sub3LNAOera, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LNAOOvrEvr[3] / gd.sub3n));
                sbt.Append("sub3NAOoka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[0] / gd.sub3n));
                sbt.Append("sub3NAOora, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[1] / gd.sub3n));
                sbt.Append("sub3NAOeka, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[2] / gd.sub3n));
                sbt.Append("sub3NAOera, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOOvrEvr[3] / gd.sub3n));
                sbt.Append("npcr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._npcr));
                sbt.Append("npvr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._npvr));
                sbt.Append("nmbr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nmbr));
                sbt.Append("nrbr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nrbr));
                sbt.Append("CPhNAOcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhNAOcGDQ[0]));
                sbt.Append("CPhNAOcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhNAOcGDQ[1]));
                sbt.Append("CPhNAOcQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhNAOcGDQ[2]));
                sbt.Append("CFRNAOcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOcGDQ[0]));
                sbt.Append("CFRNAOcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOcGDQ[1]));
                sbt.Append("CFRNAOcQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRNAOcGDQ[2]));
                sbt.Append("sub3NAOcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOcGDQ[0]));
                sbt.Append("sub3NAOcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOcGDQ[1]));
                sbt.Append("sub3NAOcQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOcGDQ[2]));
                sbt.Append("CONAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoONAOc));
                sbt.Append("C1NAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123NAOc[0]));
                sbt.Append("C2NAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123NAOc[1]));
                sbt.Append("C3NAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123NAOc[2]));
                sbt.Append("C1HNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoC1[0]]));
                sbt.Append("C1LNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoC1[1]]));
                sbt.Append("C2HNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoC2[0]]));
                sbt.Append("C2LNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoC2[1]]));
                sbt.Append("C3HNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoC3[0]]));
                sbt.Append("C3LNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoC3[1]]));
                sbt.Append("COHNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoO[0]]));
                sbt.Append("COLNAOc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nch[gd.CoO[1]]));
                sbt.Append("sub3NAOtG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOtGDQ[0]));
                sbt.Append("sub3NAOtD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOtGDQ[1]));
                sbt.Append("sub3NAOtQ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOtGDQ[2]));
                sbt.Append("sub3NAOtGa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOtGDQ[0] / gd.sub3n));
                sbt.Append("sub3NAOtDa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOtGDQ[1] / gd.sub3n));
                sbt.Append("sub3NAOtQa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3NAOtGDQ[2] / gd.sub3n));
                sbt.Append("CPhN2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhN2s2p[0]));
                sbt.Append("CPhN2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhN2s2p[1]));
                sbt.Append("CFRN2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRN2s2p[0]));
                sbt.Append("CFRN2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRN2s2p[1]));
                sbt.Append("sub3N2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3N2s2p[0]));
                sbt.Append("sub3N2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3N2s2p[1]));
                sbt.Append("sub3Nns, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Nnsnp[0]));
                sbt.Append("sub3Nnp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Nnsnp[1]));
                sbt.Append("C1N2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1N2s2p[0]));
                sbt.Append("C1N2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1N2s2p[1]));
                sbt.Append("C2N2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2N2s2p[0]));
                sbt.Append("C2N2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2N2s2p[1]));
                sbt.Append("C3N2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3N2s2p[0]));
                sbt.Append("C3N2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3N2s2p[1]));
                sbt.Append("CFRN2sa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRN2s2p[0] / gd.CFRn));
                sbt.Append("CFRN2pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRN2s2p[1] / gd.CFRn));
                sbt.Append("sub3N2sa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3N2s2p[0] / gd.sub3n));
                sbt.Append("sub3N2pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3N2s2p[1] / gd.sub3n));
                sbt.Append("sub3Nnsa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Nnsnp[0] / gd.sub3n));
                sbt.Append("sub3Nnpa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Nnsnp[1] / gd.sub3n));
                sbt.Append("CPhHBD1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBD1espd[0]));
                sbt.Append("CPhHBD1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBD1espd[1]));
                sbt.Append("CPhHBD1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBD1espd[2]));
                sbt.Append("CPhHBD1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBD1espd[3]));
                sbt.Append("CPhLBD1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBD1espd[0]));
                sbt.Append("CPhLBD1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBD1espd[1]));
                sbt.Append("CPhLBD1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBD1espd[2]));
                sbt.Append("CPhLBD1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBD1espd[3]));
                sbt.Append("CPhBD1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBD1espd[0]));
                sbt.Append("CPhBD1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBD1espd[1]));
                sbt.Append("CPhBD1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBD1espd[2]));
                sbt.Append("CPhBD1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBD1espd[3]));
                sbt.Append("CPhHBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBD2pd[0]));
                sbt.Append("CPhHBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBD2pd[1]));
                sbt.Append("CPhLBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBD2pd[0]));
                sbt.Append("CPhLBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBD2pd[1]));
                sbt.Append("CPhBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBD2pd[0]));
                sbt.Append("CPhBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBD2pd[1]));
                sbt.Append("CPhHBDs1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBDs1espd[0]));
                sbt.Append("CPhHBDs1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBDs1espd[1]));
                sbt.Append("CPhHBDs1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBDs1espd[2]));
                sbt.Append("CPhHBDs1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBDs1espd[3]));
                sbt.Append("CPhLBDs1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBDs1espd[0]));
                sbt.Append("CPhLBDs1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBDs1espd[1]));
                sbt.Append("CPhLBDs1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBDs1espd[2]));
                sbt.Append("CPhLBDs1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBDs1espd[3]));
                sbt.Append("CPhBDs1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBDs1espd[0]));
                sbt.Append("CPhBDs1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBDs1espd[1]));
                sbt.Append("CPhBDs1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBDs1espd[2]));
                sbt.Append("CPhBDs1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBDs1espd[3]));
                sbt.Append("CPhHBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBDs2pd[0]));
                sbt.Append("CPhHBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhHBDs2pd[1]));
                sbt.Append("CPhLBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBDs2pd[0]));
                sbt.Append("CPhLBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhLBDs2pd[1]));
                sbt.Append("CPhBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBDs2pd[0]));
                sbt.Append("CPhBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CPhBDs2pd[1]));
                sbt.Append("CFRHBD1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBD1espd[0]));
                sbt.Append("CFRHBD1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBD1espd[1]));
                sbt.Append("CFRHBD1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBD1espd[2]));
                sbt.Append("CFRHBD1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBD1espd[3]));
                sbt.Append("CFRLBD1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBD1espd[0]));
                sbt.Append("CFRLBD1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBD1espd[1]));
                sbt.Append("CFRLBD1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBD1espd[2]));
                sbt.Append("CFRLBD1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBD1espd[3]));
                sbt.Append("CFRBD1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[0]));
                sbt.Append("CFRBD1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[1]));
                sbt.Append("CFRBD1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[2]));
                sbt.Append("CFRBD1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[3]));
                sbt.Append("CFRHBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBD2pd[0]));
                sbt.Append("CFRHBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBD2pd[1]));
                sbt.Append("CFRLBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBD2pd[0]));
                sbt.Append("CFRLBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBD2pd[1]));
                sbt.Append("CFRBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD2pd[0]));
                sbt.Append("CFRBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD2pd[1]));
                sbt.Append("CFRHBDs1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBDs1espd[0]));
                sbt.Append("CFRHBDs1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBDs1espd[1]));
                sbt.Append("CFRHBDs1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBDs1espd[2]));
                sbt.Append("CFRHBDs1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBDs1espd[3]));
                sbt.Append("CFRLBDs1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBDs1espd[0]));
                sbt.Append("CFRLBDs1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBDs1espd[1]));
                sbt.Append("CFRLBDs1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBDs1espd[2]));
                sbt.Append("CFRLBDs1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBDs1espd[3]));
                sbt.Append("CFRBDs1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs1espd[0]));
                sbt.Append("CFRBDs1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs1espd[1]));
                sbt.Append("CFRBDs1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs1espd[2]));
                sbt.Append("CFRBDs1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs1espd[3]));
                sbt.Append("CFRHBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBDs2pd[0]));
                sbt.Append("CFRHBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRHBDs2pd[1]));
                sbt.Append("CFRLBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBDs2pd[0]));
                sbt.Append("CFRLBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRLBDs2pd[1]));
                sbt.Append("CFRBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs2pd[0]));
                sbt.Append("CFRBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs2pd[1]));
                sbt.Append("CFRBD1ta, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[0] / gd.CFRn));
                sbt.Append("CFRBD1sa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[1] / gd.CFRn));
                sbt.Append("CFRBD1pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[2] / gd.CFRn));
                sbt.Append("CFRBD1da, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[3] / gd.CFRn));
                sbt.Append("CFRBD1ta, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[0] / gd.CFRn));
                sbt.Append("CFRBD1sa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[1] / gd.CFRn));
                sbt.Append("CFRBD1pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[2] / gd.CFRn));
                sbt.Append("CFRBD1da, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD1espd[3] / gd.CFRn));
                sbt.Append("CFRBD2pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD2pd[0] / gd.CFRn));
                sbt.Append("CFRBD2da, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBD2pd[1] / gd.CFRn));
                sbt.Append("CFRBDs2pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs2pd[0] / gd.CFRn));
                sbt.Append("CFRBDs2da, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRBDs2pd[1] / gd.CFRn));
                sbt.Append("sub3HBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HBD2pd[0]));
                sbt.Append("sub3HBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HBD2pd[1]));
                sbt.Append("sub3LBD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LBD2pd[0]));
                sbt.Append("sub3LBD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LBD2pd[1]));
                sbt.Append("sub3BD2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BD2pd[0]));
                sbt.Append("sub3BD2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BD2pd[1]));
                sbt.Append("sub3HBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HBDs2pd[0]));
                sbt.Append("sub3HBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HBDs2pd[1]));
                sbt.Append("sub3LBDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LBDs2pd[0]));
                sbt.Append("sub3LBDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LBDs2pd[1]));
                sbt.Append("sub3BDs2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BDs2pd[0]));
                sbt.Append("sub3BDs2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BDs2pd[1]));
                sbt.Append("sub3HL2t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HL2espd[0]));
                sbt.Append("sub3HL2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HL2espd[1]));
                sbt.Append("sub3HL2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HL2espd[2]));
                sbt.Append("sub3HL2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HL2espd[3]));
                sbt.Append("sub3LL2t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LL2espd[0]));
                sbt.Append("sub3LL2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LL2espd[1]));
                sbt.Append("sub3LL2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LL2espd[2]));
                sbt.Append("sub3LL2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LL2espd[3]));
                sbt.Append("sub3L2t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[0]));
                sbt.Append("sub3L2s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[1]));
                sbt.Append("sub3L2p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[2]));
                sbt.Append("sub3L2d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[3]));
                sbt.Append("sub3HLnt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HLnespd[0]));
                sbt.Append("sub3HLns, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HLnespd[1]));
                sbt.Append("sub3HLnp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HLnespd[2]));
                sbt.Append("sub3HLnd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3HLnespd[3]));
                sbt.Append("sub3LLnt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LLnespd[0]));
                sbt.Append("sub3LLns, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LLnespd[1]));
                sbt.Append("sub3LLnp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LLnespd[2]));
                sbt.Append("sub3LLnd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LLnespd[3]));
                sbt.Append("sub3Lnt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[0]));
                sbt.Append("sub3Lns, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[1]));
                sbt.Append("sub3Lnp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[2]));
                sbt.Append("sub3Lnd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[3]));
                sbt.Append("C11BD1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDespd[0]));
                sbt.Append("C11BD1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDespd[1]));
                sbt.Append("C11BD1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDespd[2]));
                sbt.Append("C11BD1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDespd[3]));
                sbt.Append("C11BDs1t, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDsespd[0]));
                sbt.Append("C11BDs1s, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDsespd[1]));
                sbt.Append("C11BDs1p, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDsespd[2]));
                sbt.Append("C11BDs1d, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BDsespd[3]));
                sbt.Append("C2OHBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDespd[0]));
                sbt.Append("C2OHBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDespd[1]));
                sbt.Append("C2OHBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDespd[2]));
                sbt.Append("C2OHBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDespd[3]));
                sbt.Append("C2OLBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDespd[0]));
                sbt.Append("C2OLBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDespd[1]));
                sbt.Append("C2OLBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDespd[2]));
                sbt.Append("C2OLBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDespd[3]));
                sbt.Append("C2OBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDespd[0]));
                sbt.Append("C2OBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDespd[1]));
                sbt.Append("C2OBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDespd[2]));
                sbt.Append("C2OBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDespd[3]));
                sbt.Append("C2OHBDst, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDsespd[0]));
                sbt.Append("C2OHBDss, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDsespd[1]));
                sbt.Append("C2OHBDsp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDsespd[2]));
                sbt.Append("C2OHBDsd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OHBDsespd[3]));
                sbt.Append("C2OLBDst, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDsespd[0]));
                sbt.Append("C2OLBDss, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDsespd[1]));
                sbt.Append("C2OLBDsp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDsespd[2]));
                sbt.Append("C2OLBDsd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OLBDsespd[3]));
                sbt.Append("C2OBDst, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDsespd[0]));
                sbt.Append("C2OBDss, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDsespd[1]));
                sbt.Append("C2OBDsp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDsespd[2]));
                sbt.Append("C2OBDsd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBDsespd[3]));
                sbt.Append("C3sHBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDespd[0]));
                sbt.Append("C3sHBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDespd[1]));
                sbt.Append("C3sHBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDespd[2]));
                sbt.Append("C3sHBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDespd[3]));
                sbt.Append("C3sLBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDespd[0]));
                sbt.Append("C3sLBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDespd[1]));
                sbt.Append("C3sLBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDespd[2]));
                sbt.Append("C3sLBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDespd[3]));
                sbt.Append("C3sBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDespd[0]));
                sbt.Append("C3sBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDespd[1]));
                sbt.Append("C3sBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDespd[2]));
                sbt.Append("C3sBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDespd[3]));
                sbt.Append("C3sHBDst, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDsespd[0]));
                sbt.Append("C3sHBDss, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDsespd[1]));
                sbt.Append("C3sHBDsp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDsespd[2]));
                sbt.Append("C3sHBDsd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sHBDsespd[3]));
                sbt.Append("C3sLBDst, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDsespd[0]));
                sbt.Append("C3sLBDss, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDsespd[1]));
                sbt.Append("C3sLBDsp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDsespd[2]));
                sbt.Append("C3sLBDsd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sLBDsespd[3]));
                sbt.Append("C3sBDst, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDsespd[0]));
                sbt.Append("C3sBDss, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDsespd[1]));
                sbt.Append("C3sBDsp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDsespd[2]));
                sbt.Append("C3sBDsd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBDsespd[3]));
                sbt.Append("COHBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHLespd[0]));
                sbt.Append("COHBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHLespd[1]));
                sbt.Append("COHBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHLespd[2]));
                sbt.Append("COHBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOHLespd[3]));
                sbt.Append("COLBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLLespd[0]));
                sbt.Append("COLBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLLespd[1]));
                sbt.Append("COLBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLLespd[2]));
                sbt.Append("COLBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLLespd[3]));
                sbt.Append("COBDt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLespd[0]));
                sbt.Append("COBDs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLespd[1]));
                sbt.Append("COBDp, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLespd[2]));
                sbt.Append("COBDd, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLespd[3]));
                sbt.Append("sub3BD2pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BD2pd[0] / gd.sub3n));
                sbt.Append("sub3BD2da, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BD2pd[1] / gd.sub3n));
                sbt.Append("sub3BDs2pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BDs2pd[0] / gd.sub3n));
                sbt.Append("sub3BDs2da, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3BDs2pd[1] / gd.sub3n));
                sbt.Append("sub3L2ta, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[0] / gd.sub3n));
                sbt.Append("sub3L2sa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[1] / gd.sub3n));
                sbt.Append("sub3L2pa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[2] / gd.sub3n));
                sbt.Append("sub3L2da, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2espd[3] / gd.sub3n));
                sbt.Append("sub3Lnta, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[0] / gd.sub3n));
                sbt.Append("sub3Lnsa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[1] / gd.sub3n));
                sbt.Append("sub3Lnpa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[2] / gd.sub3n));
                sbt.Append("sub3Lnda, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3Lnespd[3] / gd.sub3n));
                sbt.Append("NHOsk1sin2T, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk1sin2TCS[0]));
                sbt.Append("NHOsk1sin2C, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk1sin2TCS[1]));
                sbt.Append("NHOsk1sin2S, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk1sin2TCS[2]));
                sbt.Append("NHOsk1cosT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk1cosTCS[0]));
                sbt.Append("NHOsk1cosC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk1cosTCS[1]));
                sbt.Append("NHOsk1cosS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk1cosTCS[2]));
                sbt.Append("NHOsk2sinT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk2sinTCS[0]));
                sbt.Append("NHOsk2sinC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk2sinTCS[1]));
                sbt.Append("NHOsk2sinS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk2sinTCS[2]));
                sbt.Append("NHOsk2cos2T, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk2cos2TCS[0]));
                sbt.Append("NHOsk2cos2C, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk2cos2TCS[1]));
                sbt.Append("NHOsk2cos2S, ");
                sbd.Append(string.Format("{0:G15}, ", gd.NHOSk2cos2TCS[2]));
                sbt.Append("CPhsDoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh1DonZGD[0]));
                sbt.Append("CPhsDoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh1DonZGD[1]));
                sbt.Append("CPhsDoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh1DonZGD[2]));
                sbt.Append("CPhpDoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh2DonZGD[0]));
                sbt.Append("CPhpDoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh2DonZGD[1]));
                sbt.Append("CPhpDoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh2DonZGD[2]));
                sbt.Append("CPhAcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhAccZGD[0]));
                sbt.Append("CPhAcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhAccZGD[1]));
                sbt.Append("CPhAcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhAccZGD[2]));
                sbt.Append("CFRsDoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR1DonZGD[0]));
                sbt.Append("CFRsDoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR1DonZGD[1]));
                sbt.Append("CFRsDoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR1DonZGD[2]));
                sbt.Append("CFRpDoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR2DonZGD[0]));
                sbt.Append("CFRpDoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR2DonZGD[1]));
                sbt.Append("CFRpDoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR2DonZGD[2]));
                sbt.Append("CFRAcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRAccZGD[0]));
                sbt.Append("CFRAcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRAccZGD[1]));
                sbt.Append("CFRAcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRAccZGD[2]));
                sbt.Append("sub3pDoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub32DonZGD[0]));
                sbt.Append("sub3pDoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub32DonZGD[1]));
                sbt.Append("sub3pDoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub32DonZGD[2]));
                sbt.Append("sub3L2DoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2DonZGD[0]));
                sbt.Append("sub3L2DoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2DonZGD[1]));
                sbt.Append("sub3L2DoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2DonZGD[2]));
                sbt.Append("sub3LnDoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LnDonZGD[0]));
                sbt.Append("sub3LnDoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LnDonZGD[1]));
                sbt.Append("sub3LnDoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LnDonZGD[2]));
                sbt.Append("sub3AcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3AccZGD[0]));
                sbt.Append("sub3AcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3AccZGD[1]));
                sbt.Append("sub3AcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3AccZGD[2]));
                sbt.Append("C11Do, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11DonAcc[0]));
                sbt.Append("C11Ac, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11DonAcc[1]));
                sbt.Append("C2ODoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2ODonZGD[0]));
                sbt.Append("C2ODoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2ODonZGD[1]));
                sbt.Append("C2ODoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2ODonZGD[2]));
                sbt.Append("C2OAcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OAccZGD[0]));
                sbt.Append("C2OAcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OAccZGD[1]));
                sbt.Append("C2OAcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OAccZGD[2]));
                sbt.Append("C3sDoZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sDonZGD[0]));
                sbt.Append("C3sDoG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sDonZGD[1]));
                sbt.Append("C3sDoD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sDonZGD[2]));
                sbt.Append("C3sAcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sAccZGD[0]));
                sbt.Append("C3sAcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sAccZGD[1]));
                sbt.Append("C3sAcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sAccZGD[2]));
                sbt.Append("CFRsDoZa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR1DonZGD[0] / gd.CFRn));
                sbt.Append("CFRpDoZa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR2DonZGD[0] / gd.CFRn));
                sbt.Append("CFRAcZa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRAccZGD[0] / gd.CFRn));
                sbt.Append("sub3pDoZa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub32DonZGD[0] / gd.sub3n));
                sbt.Append("sub3L2DoZa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2DonZGD[0] / gd.sub3n));
                sbt.Append("sub3LnDoZa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LnDonZGD[0] / gd.sub3n));
                sbt.Append("CPhsBS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh1BESKT[0]));
                sbt.Append("CPhsBK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh1BESKT[1]));
                sbt.Append("CPhsBT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh1BESKT[2]));
                sbt.Append("CPhpBS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh2BESKT[0]));
                sbt.Append("CPhpBK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh2BESKT[1]));
                sbt.Append("CPhpBT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPh2BESKT[2]));
                sbt.Append("CFRsBS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR1BESKT[0]));
                sbt.Append("CFRsBK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR1BESKT[1]));
                sbt.Append("CFRsBT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR1BESKT[2]));
                sbt.Append("CFRpBS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR2BESKT[0]));
                sbt.Append("CFRpBK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR2BESKT[1]));
                sbt.Append("CFRpBT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFR2BESKT[2]));
                sbt.Append("sub3pBS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub32BESKT[0]));
                sbt.Append("sub3pBK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub32BESKT[1]));
                sbt.Append("sub3pBT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub32BESKT[2]));
                sbt.Append("sub3L2S, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2ESKT[0]));
                sbt.Append("sub3L2K, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2ESKT[1]));
                sbt.Append("sub3L2T, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3L2ESKT[2]));
                sbt.Append("sub3LnS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LnESKT[0]));
                sbt.Append("sub3LnK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LnESKT[1]));
                sbt.Append("sub3LnT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3LnESKT[2]));
                sbt.Append("C11BE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C11BE));
                sbt.Append("C2OBS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBESKT[0]));
                sbt.Append("C2OBK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBESKT[1]));
                sbt.Append("C2OBT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2OBESKT[2]));
                sbt.Append("C3sBS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBESKT[0]));
                sbt.Append("C3sBK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBESKT[1]));
                sbt.Append("C3sBT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3sBESKT[2]));
                sbt.Append("COLES, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLESKT[0]));
                sbt.Append("COLEK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLESKT[1]));
                sbt.Append("COLET, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOLESKT[2]));
                sbt.Append("CPhRYE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhRYE));
                sbt.Append("CFRRYE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRRYE));
                sbt.Append("sub3RYE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3RYE));
                sbt.Append("CORYE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoORYE));
                sbt.Append("nbvl, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nbvl));
                sbt.Append("nbtl, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nbtl));
                sbt.Append("nbvnl, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nbvnl));
                sbt.Append("nbrnl, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nbrnl));
                sbt.Append("nbtnl, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nbtnl));
                sbt.Append("nre, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._nre));
                sbt.Append("scfe, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._scfe));
                sbt.Append("C1GiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GiHGD[0]));
                sbt.Append("C1GiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GiHGD[1]));
                sbt.Append("C1GiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GiHGD[2]));
                sbt.Append("C1GaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GaHGD[0]));
                sbt.Append("C1GaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GaHGD[1]));
                sbt.Append("C1GaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GaHGD[2]));
                sbt.Append("C1GtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GtFHGD[0]));
                sbt.Append("C1GtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GtFHGD[1]));
                sbt.Append("C1GtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GtFHGD[2]));
                sbt.Append("C1GenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GenHGD[0]));
                sbt.Append("C1GenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GenHGD[1]));
                sbt.Append("C1GenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C1GenHGD[2]));
                sbt.Append("C2GiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GiHGD[0]));
                sbt.Append("C2GiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GiHGD[1]));
                sbt.Append("C2GiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GiHGD[2]));
                sbt.Append("C2GaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GaHGD[0]));
                sbt.Append("C2GaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GaHGD[1]));
                sbt.Append("C2GaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GaHGD[2]));
                sbt.Append("C2GtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GtFHGD[0]));
                sbt.Append("C2GtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GtFHGD[1]));
                sbt.Append("C2GtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GtFHGD[2]));
                sbt.Append("C2GenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GenHGD[0]));
                sbt.Append("C2GenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GenHGD[1]));
                sbt.Append("C2GenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C2GenHGD[2]));
                sbt.Append("C3GiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GiHGD[0]));
                sbt.Append("C3GiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GiHGD[1]));
                sbt.Append("C3GiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GiHGD[2]));
                sbt.Append("C3GaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GaHGD[0]));
                sbt.Append("C3GaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GaHGD[1]));
                sbt.Append("C3GaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GaHGD[2]));
                sbt.Append("C3GtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GtFHGD[0]));
                sbt.Append("C3GtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GtFHGD[1]));
                sbt.Append("C3GtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GtFHGD[2]));
                sbt.Append("C3GenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GenHGD[0]));
                sbt.Append("C3GenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GenHGD[1]));
                sbt.Append("C3GenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C3GenHGD[2]));
                sbt.Append("C4GiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GiHGD[0]));
                sbt.Append("C4GiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GiHGD[1]));
                sbt.Append("C4GiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GiHGD[2]));
                sbt.Append("C4GaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GaHGD[0]));
                sbt.Append("C4GaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GaHGD[1]));
                sbt.Append("C4GaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GaHGD[2]));
                sbt.Append("C4GtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GtFHGD[0]));
                sbt.Append("C4GtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GtFHGD[1]));
                sbt.Append("C4GtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GtFHGD[2]));
                sbt.Append("C4GenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GenHGD[0]));
                sbt.Append("C4GenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GenHGD[1]));
                sbt.Append("C4GenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C4GenHGD[2]));
                sbt.Append("C5GiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GiHGD[0]));
                sbt.Append("C5GiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GiHGD[1]));
                sbt.Append("C5GiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GiHGD[2]));
                sbt.Append("C5GaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GaHGD[0]));
                sbt.Append("C5GaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GaHGD[1]));
                sbt.Append("C5GaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GaHGD[2]));
                sbt.Append("C5GtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GtFHGD[0]));
                sbt.Append("C5GtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GtFHGD[1]));
                sbt.Append("C5GtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GtFHGD[2]));
                sbt.Append("C5GenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GenHGD[0]));
                sbt.Append("C5GenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GenHGD[1]));
                sbt.Append("C5GenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C5GenHGD[2]));
                sbt.Append("C6GiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GiHGD[0]));
                sbt.Append("C6GiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GiHGD[1]));
                sbt.Append("C6GiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GiHGD[2]));
                sbt.Append("C6GaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GaHGD[0]));
                sbt.Append("C6GaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GaHGD[1]));
                sbt.Append("C6GaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GaHGD[2]));
                sbt.Append("C6GtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GtFHGD[0]));
                sbt.Append("C6GtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GtFHGD[1]));
                sbt.Append("C6GtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GtFHGD[2]));
                sbt.Append("C6GenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GenHGD[0]));
                sbt.Append("C6GenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GenHGD[1]));
                sbt.Append("C6GenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C6GenHGD[2]));
                sbt.Append("COGiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGiHGD[0]));
                sbt.Append("COGiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGiHGD[1]));
                sbt.Append("COGiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGiHGD[2]));
                sbt.Append("COGaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGaHGD[0]));
                sbt.Append("COGaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGaHGD[1]));
                sbt.Append("COGaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGaHGD[2]));
                sbt.Append("COGtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGtFHGD[0]));
                sbt.Append("COGtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGtFHGD[1]));
                sbt.Append("COGtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGtFHGD[2]));
                sbt.Append("COGenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGenHGD[0]));
                sbt.Append("COGenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGenHGD[1]));
                sbt.Append("COGenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoOGenHGD[2]));
                sbt.Append("CPhGiH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGiHGD[0]));
                sbt.Append("CPhGiG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGiHGD[1]));
                sbt.Append("CPhGiD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGiHGD[2]));
                sbt.Append("CPhGaH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGaHGD[0]));
                sbt.Append("CPhGaG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGaHGD[1]));
                sbt.Append("CPhGaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGaHGD[2]));
                sbt.Append("CPhGtFH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGtFHGD[0]));
                sbt.Append("CPhGtFG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGtFHGD[1]));
                sbt.Append("CPhGtFD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGtFHGD[2]));
                sbt.Append("CPhGenH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGenHGD[0]));
                sbt.Append("CPhGenG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGenHGD[1]));
                sbt.Append("CPhGenD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhGenHGD[2]));
                sbt.Append("CFRGiHa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGiHGD[0] / gd.CFRn));
                sbt.Append("CFRGiGa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGiHGD[1] / gd.CFRn));
                sbt.Append("CFRGiDa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGiHGD[2] / gd.CFRn));
                sbt.Append("CFRGaHa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGaHGD[0] / gd.CFRn));
                sbt.Append("CFRGaGa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGaHGD[1] / gd.CFRn));
                sbt.Append("CFRGaDa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGaHGD[2] / gd.CFRn));
                sbt.Append("CFRGtFHa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGtFHGD[0] / gd.CFRn));
                sbt.Append("CFRGtFGa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGtFHGD[1] / gd.CFRn));
                sbt.Append("CFRGtFDa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGtFHGD[2] / gd.CFRn));
                sbt.Append("CFRGenHa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGenHGD[0] / gd.CFRn));
                sbt.Append("CFRGenGa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGenHGD[1] / gd.CFRn));
                sbt.Append("CFRGenDa, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRGenHGD[2] / gd.CFRn));
                sbt.Append("dmdpD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dmdpDFT[0]));
                sbt.Append("dmdpF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dmdpDFT[1]));
                sbt.Append("dmdpT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dmdpDFT[2]));
                sbt.Append("dqctD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dqctDFT[0]));
                sbt.Append("dqctF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dqctDFT[1]));
                sbt.Append("dqctT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dqctDFT[2]));
                sbt.Append("orgtD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.orgtDFT[0]));
                sbt.Append("orgtF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.orgtDFT[1]));
                sbt.Append("orgtT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.orgtDFT[2]));
                sbt.Append("orgeY, ");
                sbd.Append(string.Format("{0:G15}, ", gd.orgeEW[0]));
                sbt.Append("orgeW, ");
                sbd.Append(string.Format("{0:G15}, ", gd.orgeEW[1]));
                sbt.Append("ispo, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._ispo));
                sbt.Append("orgi, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._orgi));
                sbt.Append("Mmass, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._Mmass));
                sbt.Append("AlphaD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._AlphaD));
                sbt.Append("C1Ac, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123OAc[0]));
                sbt.Append("C2Ac, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123OAc[1]));
                sbt.Append("C3Ac, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123OAc[2]));
                sbt.Append("COAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.C123OAc[3]));
                sbt.Append("C1HAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoC1[0]]));
                sbt.Append("C1LAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoC1[1]]));
                sbt.Append("C2HAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoC2[0]]));
                sbt.Append("C2LAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoC2[1]]));
                sbt.Append("C3HAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoC3[0]]));
                sbt.Append("C3LAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoC3[1]]));
                sbt.Append("COHAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoO[0]]));
                sbt.Append("COLAc, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._APTc[gd.CoO[1]]));
                sbt.Append("CPhAcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhAcGDZ[0]));
                sbt.Append("CPhAcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhAcGDZ[1]));
                sbt.Append("CPhAcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CoPhAcGDZ[2]));
                sbt.Append("CFRAcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRAcGDZ[0]));
                sbt.Append("CFRAcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRAcGDZ[1]));
                sbt.Append("CFRAcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRAcGDZ[2]));
                sbt.Append("sub3AcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3AcGDZ[0]));
                sbt.Append("sub3AcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3AcGDZ[1]));
                sbt.Append("sub3AcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.sub3AcGDZ[2]));
                sbt.Append("CFRAhcG, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRhAcGDZ[0]));
                sbt.Append("CFRAhcD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRhAcGDZ[1]));
                sbt.Append("CFRAhcZ, ");
                sbd.Append(string.Format("{0:G15}, ", gd.CFRhAcGDZ[2]));
                sbt.Append("EPolD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EPDFT[0]));
                sbt.Append("EPolF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EPDFT[1]));
                sbt.Append("EPolT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EPDFT[2]));
                sbt.Append("APolD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.APDFT[0]));
                sbt.Append("APolF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.APDFT[1]));
                sbt.Append("APolT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.APDFT[2]));
                sbt.Append("mwfcS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.mwfcS));
                sbt.Append("dvpE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dvpE));
                sbt.Append("TIRkeCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TIRke[0]));
                sbt.Append("TIRkeCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TIRke[1]));
                sbt.Append("TIRkesub3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TIRke[2]));
                sbt.Append("TIRkeCO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TIRke[3]));
                sbt.Append("TIRkeC1, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TIRke[4]));
                sbt.Append("TIRkeC2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TIRke[5]));
                sbt.Append("TIRkeC3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.TIRke[6]));
                sbt.Append("h2IRkeCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h2IRke[0]));
                sbt.Append("h2IRkeCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h2IRke[1]));
                sbt.Append("h2IRkesub3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h2IRke[2]));
                sbt.Append("h2IRkeCO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h2IRke[3]));
                sbt.Append("h2IRkeC1, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h2IRke[4]));
                sbt.Append("h2IRkeC2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h2IRke[5]));
                sbt.Append("h2IRkeC3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h2IRke[6]));
                sbt.Append("h5IRkeCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h5IRke[0]));
                sbt.Append("h5IRkeCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h5IRke[1]));
                sbt.Append("h5IRkesub3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h5IRke[2]));
                sbt.Append("h5IRkeCO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h5IRke[3]));
                sbt.Append("h5IRkeC1, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h5IRke[4]));
                sbt.Append("h5IRkeC2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h5IRke[5]));
                sbt.Append("h5IRkeC3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.h5IRke[6]));
                sbt.Append("kIRkeCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.kIRke[0]));
                sbt.Append("kIRkeCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.kIRke[1]));
                sbt.Append("kIRkesub3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.kIRke[2]));
                sbt.Append("kIRkeCO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.kIRke[3]));
                sbt.Append("kIRkeC1, ");
                sbd.Append(string.Format("{0:G15}, ", gd.kIRke[4]));
                sbt.Append("kIRkeC2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.kIRke[5]));
                sbt.Append("kIRkeC3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.kIRke[6]));
                sbt.Append("khIRkeCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.khIRke[0]));
                sbt.Append("khIRkeCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.khIRke[1]));
                sbt.Append("khIRkesub3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.khIRke[2]));
                sbt.Append("khIRkeCO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.khIRke[3]));
                sbt.Append("khIRkeC1, ");
                sbd.Append(string.Format("{0:G15}, ", gd.khIRke[4]));
                sbt.Append("khIRkeC2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.khIRke[5]));
                sbt.Append("khIRkeC3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.khIRke[6]));
                sbt.Append("k2IRkeCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.k2IRke[0]));
                sbt.Append("k2IRkeCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.k2IRke[1]));
                sbt.Append("k2IRkesub3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.k2IRke[2]));
                sbt.Append("k2IRkeCO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.k2IRke[3]));
                sbt.Append("k2IRkeC1, ");
                sbd.Append(string.Format("{0:G15}, ", gd.k2IRke[4]));
                sbt.Append("k2IRkeC2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.k2IRke[5]));
                sbt.Append("k2IRkeC3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.k2IRke[6]));
                sbt.Append("iIRkeCPh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.iIRke[0]));
                sbt.Append("iIRkeCFR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.iIRke[1]));
                sbt.Append("iIRkesub3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.iIRke[2]));
                sbt.Append("iIRkeCO, ");
                sbd.Append(string.Format("{0:G15}, ", gd.iIRke[3]));
                sbt.Append("iIRkeC1, ");
                sbd.Append(string.Format("{0:G15}, ", gd.iIRke[4]));
                sbt.Append("iIRkeC2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.iIRke[5]));
                sbt.Append("iIRkeC3, ");
                sbd.Append(string.Format("{0:G15}, ", gd.iIRke[6]));
                sbt.Append("IRAFh2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.IRAF[0]));
                sbt.Append("IRAFh5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.IRAF[1]));
                sbt.Append("IRAFk, ");
                sbd.Append(string.Format("{0:G15}, ", gd.IRAF[2]));
                sbt.Append("IRAFkh, ");
                sbd.Append(string.Format("{0:G15}, ", gd.IRAF[3]));
                sbt.Append("IRAFk2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.IRAF[4]));
                sbt.Append("IRAFi, ");
                sbd.Append(string.Format("{0:G15}, ", gd.IRAF[5]));
                sbt.Append("paxD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.paxDFT[0]));
                sbt.Append("paxF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.paxDFT[1]));
                sbt.Append("paxT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.paxDFT[2]));
                sbt.Append("rotta, ");
                sbd.Append(string.Format("{0:G15}, ", gd.rotts / gd.gl._dof));
                sbt.Append("zpve, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._zpve));
                sbt.Append("tce, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._tce));
                sbt.Append("tcet, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._tcet));
                sbt.Append("tcg, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._tcg));
                sbt.Append("sezpe, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._sezpe));
                sbt.Append("sete, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._sete));
                sbt.Append("setet, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._setet));
                sbt.Append("setfe, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._setfe));
                sbt.Append("ett, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._ett));
                sbt.Append("ettr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._ettr));
                sbt.Append("etv, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._etv));
                sbt.Append("cvt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._cvt));
                sbt.Append("cvtr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._cvtr));
                sbt.Append("cvv, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._cvv));
                sbt.Append("stot, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._stot));
                sbt.Append("sttr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._sttr));
                sbt.Append("stro, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._stro));
                sbt.Append("svib, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._svib));
                sbt.Append("lfvsE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.lfvS[0]));
                sbt.Append("lfvsC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.lfvS[1]));
                sbt.Append("lfvsS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.lfvS[2]));
                sbt.Append("lfvsB, ");
                sbd.Append(string.Format("{0:G15}, ", gd.lfvS[3]));
                sbt.Append("lfvsV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.lfvS[4]));
                sbt.Append("lnqtb, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lnqtb));
                sbt.Append("lnqtv, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lnqtv));
                sbt.Append("lnqvb, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lnqvb));
                sbt.Append("lnqvv, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lnqvv));
                sbt.Append("lnqt, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lnqt));
                sbt.Append("lnqr, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._lnqr));
                sbt.Append("edmdo, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._edmdo));
                sbt.Append("dpiso, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._dpiso));
                sbt.Append("dpaniso, ");
                sbd.Append(string.Format("{0:G15}, ", gd.gl._dpaniso));
                sbt.Append("Vsub3vdWC32RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC32RKTS[0]));
                sbt.Append("Vsub3vdWC32RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC32RKTS[1]));
                sbt.Append("Vsub3vdWC32RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC32RKTS[2]));
                sbt.Append("Vsub3vdWC34RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC34RKTS[0]));
                sbt.Append("Vsub3vdWC34RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC34RKTS[1]));
                sbt.Append("Vsub3vdWC34RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC34RKTS[2]));
                sbt.Append("Vsub3vdWC36RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC36RKTS[0]));
                sbt.Append("Vsub3vdWC36RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC36RKTS[1]));
                sbt.Append("Vsub3vdWC36RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC36RKTS[2]));
                sbt.Append("Vsub3vdWC38RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC38RKTS[0]));
                sbt.Append("Vsub3vdWC38RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC38RKTS[1]));
                sbt.Append("Vsub3vdWC38RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWC38RKTS[2]));
                sbt.Append("Vsub3ACC32RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC32RKTS[0]));
                sbt.Append("Vsub3ACC32RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC32RKTS[1]));
                sbt.Append("Vsub3ACC32RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC32RKTS[2]));
                sbt.Append("Vsub3ACC34RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC34RKTS[0]));
                sbt.Append("Vsub3ACC34RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC34RKTS[1]));
                sbt.Append("Vsub3ACC34RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC34RKTS[2]));
                sbt.Append("Vsub3ACC36RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC36RKTS[0]));
                sbt.Append("Vsub3ACC36RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC36RKTS[1]));
                sbt.Append("Vsub3ACC36RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC36RKTS[2]));
                sbt.Append("Vsub3ACC38RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC38RKTS[0]));
                sbt.Append("Vsub3ACC38RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC38RKTS[1]));
                sbt.Append("Vsub3ACC38RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACC38RKTS[2]));
                sbt.Append("Vsub3AEC32RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC32RKTS[0]));
                sbt.Append("Vsub3AEC32RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC32RKTS[1]));
                sbt.Append("Vsub3AEC32RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC32RKTS[2]));
                sbt.Append("Vsub3AEC34RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC34RKTS[0]));
                sbt.Append("Vsub3AEC34RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC34RKTS[1]));
                sbt.Append("Vsub3AEC34RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC34RKTS[2]));
                sbt.Append("Vsub3AEC36RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC36RKTS[0]));
                sbt.Append("Vsub3AEC36RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC36RKTS[1]));
                sbt.Append("Vsub3AEC36RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC36RKTS[2]));
                sbt.Append("Vsub3AEC38RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC38RKTS[0]));
                sbt.Append("Vsub3AEC38RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC38RKTS[1]));
                sbt.Append("Vsub3AEC38RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEC38RKTS[2]));
                sbt.Append("Vsub3IEC32RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC32RKTS[0]));
                sbt.Append("Vsub3IEC32RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC32RKTS[1]));
                sbt.Append("Vsub3IEC32RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC32RKTS[2]));
                sbt.Append("Vsub3IEC34RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC34RKTS[0]));
                sbt.Append("Vsub3IEC34RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC34RKTS[1]));
                sbt.Append("Vsub3IEC34RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC34RKTS[2]));
                sbt.Append("Vsub3IEC36RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC36RKTS[0]));
                sbt.Append("Vsub3IEC36RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC36RKTS[1]));
                sbt.Append("Vsub3IEC36RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC36RKTS[2]));
                sbt.Append("Vsub3IEC38RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC38RKTS[0]));
                sbt.Append("Vsub3IEC38RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC38RKTS[1]));
                sbt.Append("Vsub3IEC38RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEC38RKTS[2]));
                sbt.Append("Vsub3IAC32RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC32RKTS[0]));
                sbt.Append("Vsub3IAC32RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC32RKTS[1]));
                sbt.Append("Vsub3IAC32RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC32RKTS[2]));
                sbt.Append("Vsub3IAC34RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC34RKTS[0]));
                sbt.Append("Vsub3IAC34RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC34RKTS[1]));
                sbt.Append("Vsub3IAC34RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC34RKTS[2]));
                sbt.Append("Vsub3IAC36RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC36RKTS[0]));
                sbt.Append("Vsub3IAC36RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC36RKTS[1]));
                sbt.Append("Vsub3IAC36RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC36RKTS[2]));
                sbt.Append("Vsub3IAC38RK, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC38RKTS[0]));
                sbt.Append("Vsub3IAC38RT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC38RKTS[1]));
                sbt.Append("Vsub3IAC38RS, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAC38RKTS[2]));
                sbt.Append("Vsub3vdWOc2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWOc[0]));
                sbt.Append("Vsub3vdWOc4, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWOc[1]));
                sbt.Append("Vsub3vdWOc6, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWOc[2]));
                sbt.Append("Vsub3vdWOc8, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3vdWOc[3]));
                sbt.Append("Vsub3ACOc2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACOc[0]));
                sbt.Append("Vsub3ACOc4, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACOc[1]));
                sbt.Append("Vsub3ACOc6, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACOc[2]));
                sbt.Append("Vsub3ACOc8, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3ACOc[3]));
                sbt.Append("Vsub3AEOc2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEOc[0]));
                sbt.Append("Vsub3AEOc4, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEOc[1]));
                sbt.Append("Vsub3AEOc6, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEOc[2]));
                sbt.Append("Vsub3AEOc8, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3AEOc[3]));
                sbt.Append("Vsub3IEOc2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEOc[0]));
                sbt.Append("Vsub3IEOc4, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEOc[1]));
                sbt.Append("Vsub3IEOc6, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEOc[2]));
                sbt.Append("Vsub3IEOc8, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IEOc[3]));
                sbt.Append("Vsub3IAOc2, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAOc[0]));
                sbt.Append("Vsub3IAOc4, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAOc[1]));
                sbt.Append("Vsub3IAOc6, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAOc[2]));
                sbt.Append("Vsub3IAOc8, ");
                sbd.Append(string.Format("{0:G15}, ", gd.Vsub3IAOc[3]));
                sbt.Append("EnPsub3OcEA, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc[0]));
                sbt.Append("EnPsub3OcPN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc[1]));
                sbt.Append("EnPsub3OcAN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc[2]));
                sbt.Append("EnPsub3OcMN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc[3]));
                sbt.Append("EnPsub3OcEN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc[4]));
                sbt.Append("EnPsub3OcIE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc[5]));
                sbt.Append("EnPsub3Oc2EA, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc2[0]));
                sbt.Append("EnPsub3Oc2PN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc2[1]));
                sbt.Append("EnPsub3Oc2AN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc2[2]));
                sbt.Append("EnPsub3Oc2MN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc2[3]));
                sbt.Append("EnPsub3Oc2EN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc2[4]));
                sbt.Append("EnPsub3Oc2IE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnPsub3Oc2[5]));
                sbt.Append("ElPsub3OcM, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc[0]));
                sbt.Append("ElPsub3OcH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc[1]));
                sbt.Append("ElPsub3OcH5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc[2]));
                sbt.Append("ElPsub3OcE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc[3]));
                sbt.Append("ElPsub3OcN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc[4]));
                sbt.Append("ElPsub3OcA, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc[5]));
                sbt.Append("ElPsub3Oc2M, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc2[0]));
                sbt.Append("ElPsub3Oc2H, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc2[1]));
                sbt.Append("ElPsub3Oc2H5, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc2[2]));
                sbt.Append("ElPsub3Oc2E, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc2[3]));
                sbt.Append("ElPsub3Oc2N, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc2[4]));
                sbt.Append("ElPsub3Oc2A, ");
                sbd.Append(string.Format("{0:G15}, ", gd.ElPsub3Oc2[5]));
                sbt.Append("EgoPsub3OcLV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc[0]));
                sbt.Append("EgoPsub3OcLR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc[1]));
                sbt.Append("EgoPsub3OcMV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc[2]));
                sbt.Append("EgoPsub3OcMR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc[3]));
                sbt.Append("EgoPsub3OcPV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc[4]));
                sbt.Append("EgoPsub3OcPR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc[5]));
                sbt.Append("EgoPsub3Oc2LV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc2[0]));
                sbt.Append("EgoPsub3Oc2LR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc2[1]));
                sbt.Append("EgoPsub3Oc2MV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc2[2]));
                sbt.Append("EgoPsub3Oc2MR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc2[3]));
                sbt.Append("EgoPsub3Oc2PV, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc2[4]));
                sbt.Append("EgoPsub3Oc2PR, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EgoPsub3Oc2[5]));
                sbt.Append("EnoPsub3OcL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc[0]));
                sbt.Append("EnoPsub3OcM, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc[1]));
                sbt.Append("EnoPsub3OcP, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc[2]));
                sbt.Append("EnoPsub3OcPs, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc[3]));
                sbt.Append("EnoPsub3Oc2L, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc2[0]));
                sbt.Append("EnoPsub3Oc2M, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc2[1]));
                sbt.Append("EnoPsub3Oc2P, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc2[2]));
                sbt.Append("EnoPsub3Oc2Ps, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPsub3Oc2[3]));
                sbt.Append("EnoPwLsub3OcvdW, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[0]));
                sbt.Append("EnoPwLsub3OcAC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[1]));
                sbt.Append("EnoPwLsub3OcAE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[2]));
                sbt.Append("EnoPwLsub3OcIE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[3]));
                sbt.Append("EnoPwLsub3OcIA, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[4]));
                sbt.Append("EnoPwLsub3OcPN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[5]));
                sbt.Append("EnoPwLsub3OcAN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[6]));
                sbt.Append("EnoPwLsub3OcMN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc[7]));
                sbt.Append("EnoPwLsub3Oc2vdW, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[0]));
                sbt.Append("EnoPwLsub3Oc2AC, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[1]));
                sbt.Append("EnoPwLsub3Oc2AE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[2]));
                sbt.Append("EnoPwLsub3Oc2IE, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[3]));
                sbt.Append("EnoPwLsub3Oc2IA, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[4]));
                sbt.Append("EnoPwLsub3Oc2PN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[5]));
                sbt.Append("EnoPwLsub3Oc2AN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[6]));
                sbt.Append("EnoPwLsub3Oc2MN, ");
                sbd.Append(string.Format("{0:G15}, ", gd.EnoPwLsub3Oc2[7]));
                sbt.Append("DAiCosC11, ");
                sbd.Append(string.Format("{0:G15}, ", gd.DipAcos[0]));
                sbt.Append("DAiCosC2OH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.DipAcos[1]));
                sbt.Append("DAiCosC2OL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.DipAcos[2]));
                sbt.Append("DAicoSC11, ");
                sbd.Append(string.Format("{0:G15}, ", gd.DipAsin[0]));
                sbt.Append("DAicoSC2OH, ");
                sbd.Append(string.Format("{0:G15}, ", gd.DipAsin[1]));
                sbt.Append("DAicoSC2OL, ");
                sbd.Append(string.Format("{0:G15}, ", gd.DipAsin[2]));
                sbt.Append("dpamD, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dpamDFT[0]));
                sbt.Append("dpamF, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dpamDFT[1]));
                sbt.Append("dpamT, ");
                sbd.Append(string.Format("{0:G15}, ", gd.dpamDFT[2]));
                StringBuilder sbx = new StringBuilder(dirx);
                sbx.Append("\\");
                sbx.Append(fi.Name.Remove(fi.Name.Length - 4));
                sbx.Append(".csv");
                string fpthx = sbx.ToString();
                using (FileStream fs = new FileStream(fpthx, FileMode.Create))
                {
                    using (StreamWriter sw = new StreamWriter(fs, Encoding.UTF8, 256))
                    {
                        sw.WriteLine(sbt.ToString());
                        sw.WriteLine(sbd.ToString());
                        sw.Close();
                    }
                    fs.Close();
                }
                gd.Dispose();
            }
        }
        static private string NDirC(ref StringBuilder sb)//新しい変換先を作る
        {
            string ndir = sb.ToString();
            if (!Directory.Exists(ndir))
            {
                Directory.CreateDirectory(ndir);
            }
            else
            {
                DateTime dt = DateTime.Now;
                //Console.WriteLine("E : {0:F}", dt);//debug用
                string apd = dt.ToString("yyMMdd", CultureInfo.GetCultureInfo("ja-JP"));
                sb.Append(apd);
                ndir = sb.ToString();
                if (!Directory.Exists(ndir))
                {
                    Directory.CreateDirectory(ndir);
                }
                else
                {
                    apd = dt.ToString("HHmmss", CultureInfo.GetCultureInfo("ja-JP"));
                    sb.Append("_");
                    sb.Append(apd);
                    ndir = sb.ToString();
                    if (!Directory.Exists(ndir))
                    {
                        Directory.CreateDirectory(ndir);
                    }
                    else throw new Exception("Please remove old folders in file directory.");//「\GauDescyyMMdd_HHmmss」フォルダーが存在する。あり得へん！
                }
            }
            return ndir;
        }
        private void CorSrch()//BINOLコアを探す
        {
            if (gl._als.Length != gl._an) throw new ArgumentOutOfRangeException("als/an", "Corsrch : Can not verify total atom number.");
            List<int> HL = new List<int>();
            List<int> BL = new List<int>();
            List<int> CL = new List<int>();
            List<int> NL = new List<int>();
            List<int> OL = new List<int>();
            List<int> FL = new List<int>();
            List<int> PL = new List<int>();
            List<int> SL = new List<int>();
            List<int> ClL = new List<int>();
            List<int> BrL = new List<int>();
            List<int> IL = new List<int>();
            for (int cnt = 0; cnt < gl._an; cnt++)//特定元素を数える
            {
                if (gl._als[cnt] == 1)
                {
                    HL.Add(cnt);
                }
                else if (gl._als[cnt] == 5)
                {
                    BL.Add(cnt);
                }
                else if (gl._als[cnt] == 6)
                {
                    CL.Add(cnt);
                }
                else if (gl._als[cnt] == 7)
                {
                    NL.Add(cnt);
                }
                else if (gl._als[cnt] == 8)
                {
                    OL.Add(cnt);
                }
                else if (gl._als[cnt] == 9)
                {
                    FL.Add(cnt);
                }
                else if (gl._als[cnt] == 15)
                {
                    PL.Add(cnt);
                }
                else if (gl._als[cnt] == 16)
                {
                    SL.Add(cnt);
                }
                else if (gl._als[cnt] == 17)
                {
                    ClL.Add(cnt);
                }
                else if (gl._als[cnt] == 35)
                {
                    BrL.Add(cnt);
                }
                else if (gl._als[cnt] == 53)
                {
                    IL.Add(cnt);
                }
            }
            HydL = HL.ToArray();
            BorL = BL.ToArray();
            CarL = CL.ToArray();
            NitL = NL.ToArray();
            OxyL = OL.ToArray();
            FluL = FL.ToArray();
            PhoL = PL.ToArray();
            SulL = SL.ToArray();
            ChlL = ClL.ToArray();
            BroL = BrL.ToArray();
            IodL = IL.ToArray();
            HL = null;
            BL = null;
            CL = null;
            NL = null;
            OL = null;
            FL = null;
            PL = null;
            SL = null;
            ClL = null;
            BrL = null;
            IL = null;
            if (OxyL.Length < 2) throw new ArgumentOutOfRangeException("OxyL", "Corsrch : Oxygen atom number is less than 2 in BINOL.");
            if (CarL.Length < 12) throw new ArgumentOutOfRangeException("CarL", "Corsrch : Carbon atom number is less than 12 in BINOL.");
            //Console.WriteLine("SU : HydL={0}\tBorL={1}\tCarL={2}\r\nNitL={3}\tOxyL={4}\tFluL={5}\r\nPhoL={6}\tSulL={7}\tChlL={8}\r\nBroL={9}\tIodL={10}", HydL.Length, BorL.Length, CarL.Length, NitL.Length, OxyL.Length, FluL.Length, PhoL.Length, SulL.Length, ChlL.Length, BroL.Length, IodL.Length);//debug用
            bool flg2 = false;//「見つかった」フラグ2
            List<int> DihLt = new List<int>();//二面角インデックス一時リスト
            List<bool> DihLTt = new List<bool>();//二面角順番一時リスト
            List<int> Dih4L = new List<int>();//二面角原子一時リスト
            List<int> DihLt2 = new List<int>();
            List<bool> DihLTt2 = new List<bool>();
            List<int> Dih4L2 = new List<int>();
            List<int[]> BOCCCCOBL = new List<int[]>();//B-O-C2-C1-C1'-C2'-O2-(B)構造一時リスト
            List<int[]> HOCCCCOHL = new List<int[]>();//H-O-C2-C1-C1'-C2'-O'-H'構造一時リスト
            int[][] C3456ZGL = new int[0][];//ビフェニルC3-C4-C5-C6構造とC3'-C4'-C5'-C6'構造配列
            int[] C3456ZG = new int[8];//ビフェニルC3-C4-C5-C6構造とC3'-C4'-C5'-C6'構造
            int[][] OCOCHacL = new int[0][]; ;//カルボン酸OAc部分配列
            List<int> OCOCHL;//カルボン酸OAc部分(O-C(=O)-C(H)(H)-H/C)一時リスト
            List<int> itempl = new List<int>();
            object lo = new object();
            CancellationTokenSource cts = new CancellationTokenSource();
            CancellationToken ct = cts.Token;
            ParallelOptions po = new ParallelOptions();
            po.MaxDegreeOfParallelism = CommonParam.thdn;
            po.CancellationToken = ct;
            po.TaskScheduler = TaskScheduler.Default;
            bool flg;
            if (BorL.Length != 0)
            {
                Parallel.For(0, gl._dhd.Length, po, (cntf) =>
                   {
                       for (int cnt2 = 0; cnt2 < BorL.Length; cnt2++)//硼素リストを列挙してBを特定する
                       {
                           if (gl._dhl[cntf, 0] == BorL[cnt2])//B-O-C-C
                           {
                               if (gl._als[gl._dhl[cntf, 1]] == 8 && gl._als[gl._dhl[cntf, 2]] == 6 && gl._als[gl._dhl[cntf, 3]] == 6)
                               {
                                   //Console.WriteLine("E : false : {0} {1}", gl._dhl[cntf, 3], cntf);//debug用
                                   lock (lo)
                                   {
                                       DihLt.Add(cntf);
                                       DihLTt.Add(false);
                                       Dih4L.Add(gl._dhl[cntf, 3]);
                                   }
                               }
                           }
                           if (gl._dhl[cntf, 3] == BorL[cnt2])//C-C-O-B
                           {
                               if (gl._als[gl._dhl[cntf, 2]] == 8 && gl._als[gl._dhl[cntf, 1]] == 6 && gl._als[gl._dhl[cntf, 0]] == 6)
                               {
                                   //Console.WriteLine("E : true : {0} {1}", gl._dhl[cntf, 0], cntf);//debug用
                                   lock (lo)
                                   {
                                       DihLt.Add(cntf);
                                       DihLTt.Add(true);
                                       Dih4L.Add(gl._dhl[cntf, 0]);
                                   }
                               }
                           }
                       }
                   });
                //Console.WriteLine("KI : DihLt={0}\tDihLt[0]={1},{2},{3},{4}\r\nDihLTt[0]={5}\tDih4L[0]={6}", DihLt.Count, DihLt[0], DihLt[1], DihLt[2], DihLt[3], DihLTt[0], Dih4L[0]);//debug用
                if (DihLt.Count >= 3)
                {
                    Parallel.For(0, DihLt.Count, po, (cntf) =>
                      {
                          bool flg = false;//「見つかった」フラグ
                          int cnt = cntf;
                          int cnt2 = 0;
                          int itemp;
                          int cnt3 = 0;
                          int itemp2 = 0;
                          int itemp3 = 0;
                          int[] BOCCCCOB = new int[7];//B-O-C2-C1-C1'-C2'-O2-(B)構造
                          for (cnt2 = cntf + 1; cnt2 < DihLt.Count; cnt2++)//真ん中のC-C結合を確認する
                          {
                              if ((DihLTt[cntf] ? gl._dhl[DihLt[cntf], 3] : gl._dhl[DihLt[cntf], 0]) != (DihLTt[cnt2] ? gl._dhl[DihLt[cnt2], 3] : gl._dhl[DihLt[cnt2], 0])) continue;//同じ硼素だと確認する
                              for (cnt3 = 0; cnt3 < gl._rdd.Length; cnt3++)//結合を列挙してC1-C1'を探す
                              {
                                  if ((gl._rdl[cnt3, 0] == Dih4L[cntf] && gl._rdl[cnt3, 1] == Dih4L[cnt2]) || (gl._rdl[cnt3, 1] == Dih4L[cntf] && gl._rdl[cnt3, 0] == Dih4L[cnt2]))
                                  {
                                      itemp2 = DihLTt[cntf] ? gl._dhl[DihLt[cntf], 2] : gl._dhl[DihLt[cntf], 1];//一個目のO
                                      itemp3 = DihLTt[cnt2] ? gl._dhl[DihLt[cnt2], 2] : gl._dhl[DihLt[cnt2], 1];//二個目のO
                                      //Console.WriteLine("E : itemp2={0}\titemp3={1}", itemp2, itemp3);//debug用
                                      if (itemp2 != itemp3)//同じOではない
                                      {
                                          if (itemp2 < itemp3)
                                          {
                                              itemp = itemp3;
                                              itemp3 = itemp2;
                                              itemp2 = itemp;
                                              itemp = cnt2;
                                              cnt2 = cntf;
                                              cntf = itemp;
                                          }
                                          if (DihLTt[cnt2])//B-O-C2-C1
                                          {
                                              BOCCCCOB[0] = gl._dhl[DihLt[cnt2], 3];
                                              BOCCCCOB[1] = itemp3;
                                              BOCCCCOB[2] = gl._dhl[DihLt[cnt2], 1];
                                              BOCCCCOB[3] = gl._dhl[DihLt[cnt2], 0];
                                          }
                                          else
                                          {
                                              BOCCCCOB[0] = gl._dhl[DihLt[cnt2], 0];
                                              BOCCCCOB[1] = itemp3;
                                              BOCCCCOB[2] = gl._dhl[DihLt[cnt2], 2];
                                              BOCCCCOB[3] = gl._dhl[DihLt[cnt2], 3];
                                          }
                                          if (DihLTt[cntf])//C1'-C2'-O'-B
                                          {
                                              BOCCCCOB[4] = gl._dhl[DihLt[cntf], 0];
                                              BOCCCCOB[5] = gl._dhl[DihLt[cntf], 1];
                                              BOCCCCOB[6] = itemp2;
                                          }
                                          else
                                          {
                                              BOCCCCOB[4] = gl._dhl[DihLt[cntf], 3];
                                              BOCCCCOB[5] = gl._dhl[DihLt[cntf], 2];
                                              BOCCCCOB[6] = itemp2;
                                          }
                                          //Console.WriteLine("A : {0} {1} {2} {3} {4} {5} {6}", BOCCCCOB[0], BOCCCCOB[1], BOCCCCOB[2], BOCCCCOB[3], BOCCCCOB[4], BOCCCCOB[5], BOCCCCOB[6]);//debug用
                                          flg = true;
                                          for (itemp2 = 0; itemp2 < 7; itemp2++)//被る原子の無いようにチェック
                                          {
                                              for (itemp3 = itemp2 + 1; itemp3 < 7; itemp3++)
                                              {
                                                  if (BOCCCCOB[itemp2] == BOCCCCOB[itemp3]) flg = false;
                                              }
                                          }
                                          if (flg)
                                          {
                                              for (cnt3 = 0; cnt3 < 7; cnt3++)//結合数(混成タイプ)チェック
                                              {
                                                  itemp2 = 0;
                                                  for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                                  {
                                                      if (BOCCCCOB[cnt3] == gl._rdl[itemp3, 0] || BOCCCCOB[cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                                  }
                                                  if (cnt3 == 0)
                                                  {
                                                      if (itemp2 != 3)
                                                      {
                                                          Console.WriteLine("B : {0}", BOCCCCOB[cnt3]);
                                                          flg = false;
                                                          break;
                                                      }
                                                  }
                                                  if (cnt3 == 1 || cnt3 == 6)
                                                  {
                                                      if (itemp2 != 2)
                                                      {
                                                          Console.WriteLine("O : {0}", BOCCCCOB[cnt3]);
                                                          flg = false;
                                                          break;
                                                      }
                                                  }
                                                  if (cnt3 == 2 || cnt3 == 3 || cnt3 == 4 || cnt3 == 5)
                                                  {
                                                      if (itemp2 != 3)
                                                      {
                                                          Console.WriteLine("C : {0}", BOCCCCOB[cnt3]);
                                                          flg = false;
                                                          break;
                                                      }
                                                  }
                                              }
                                          }
                                          if (flg)
                                          {
                                              lock (lo) BOCCCCOBL.Add(BOCCCCOB);
                                              flg = false;
                                              break;
                                          }
                                      }
                                  }
                              }
                          }
                      });
                }
                /*
                Console.WriteLine("KO : BOCCCCOBL={0}", BOCCCCOBL.Count);
                for (int dcnt = 0; dcnt < BOCCCCOBL.Count; dcnt++)
                {
                    Console.WriteLine("KO : [{0}]:{1},{2},{3},{4},{5},{6},{7}", dcnt, BOCCCCOBL[dcnt][0], BOCCCCOBL[dcnt][1], BOCCCCOBL[dcnt][2], BOCCCCOBL[dcnt][3], BOCCCCOBL[dcnt][4], BOCCCCOBL[dcnt][5], BOCCCCOBL[dcnt][6]);
                }
                //*///debug用
                flg = false;
                int cnt = 0;
                int cnt2 = 0;
                int cnt3 = 0;
                int itemp7 = 0;
                int itemp2 = 0;
                int itemp3 = 0;
                if (BOCCCCOBL.Count >= 1)
                {

                    C3456ZGL = new int[BOCCCCOBL.Count][];
                    DihLt.Clear();
                    DihLTt.Clear();
                    Dih4L.Clear();
                    for (cnt = 0; cnt < BOCCCCOBL.Count; cnt++)//BOCCCCO(B)構造毎にビフェニル構造を探す
                    {
                        Parallel.For(0, gl._dhd.Length, po, (cntf) =>
                          {
                              if (gl._dhl[cntf, 0] == BOCCCCOBL[cnt][3])//C1から始まる二面角情報を探す
                              {
                                  if (gl._dhl[cntf, 1] == BOCCCCOBL[cnt][2])//C2
                                  {
                                      lock (lo)
                                      {
                                          //Console.WriteLine("SU : 1true : {0} {1}", gl._dhl[cntf, 3], cntf);//debug用
                                          DihLt.Add(cntf);
                                          DihLTt.Add(true);
                                          Dih4L.Add(gl._dhl[cntf, 3]);
                                      }
                                  }
                                  else if (gl._dhl[cntf, 1] != BOCCCCOBL[cnt][4])//非C1'
                                  {
                                      lock (lo)
                                      {
                                          //Console.WriteLine("SU : 2true : {0} {1}", gl._dhl[cntf, 3], cntf);//debug用
                                          DihLt2.Add(cntf);
                                          DihLTt2.Add(true);
                                          Dih4L2.Add(gl._dhl[cntf, 3]);
                                      }
                                  }
                              }
                              if (gl._dhl[cntf, 3] == BOCCCCOBL[cnt][3])//C1まで終わる二面角情報を探す
                              {
                                  if (gl._dhl[cntf, 2] == BOCCCCOBL[cnt][2])//C2
                                  {
                                      lock (lo)
                                      {
                                          //Console.WriteLine("SU : 1false : {0} {1}", gl._dhl[cntf, 0], cntf);//debug用
                                          DihLt.Add(cntf);
                                          DihLTt.Add(false);
                                          Dih4L.Add(gl._dhl[cntf, 0]);
                                      }
                                  }
                                  else if (gl._dhl[cntf, 2] != BOCCCCOBL[cnt][4])//非C1'
                                  {
                                      lock (lo)
                                      {
                                          //Console.WriteLine("SU : 2false : {0} {1}", gl._dhl[cntf, 0], cntf);//debug用
                                          DihLt2.Add(cntf);
                                          DihLTt2.Add(false);
                                          Dih4L2.Add(gl._dhl[cntf, 0]);
                                      }
                                  }
                              }
                          });
                        //Console.WriteLine("E : DihLt={0}\tDihLt2={1}", DihLt.Count, DihLt2.Count);//debug用
                        /*
                        if (DihLt.Count != 3 || DihLt2.Count != 4)//二面角情報個数チェック
                        {
                            C3456ZGL[cnt] = new int[0];
                            continue;
                        }
                        //*/
                        itemp7 = -1;
                        for (cnt2 = 0; cnt2 < DihLt.Count; cnt2++)//六員環を探す(C1-C2-C3-C4とC1-C6-C5-C4)
                        {
                            for (cnt3 = 0; cnt3 < DihLt2.Count; cnt3++)
                            {
                                if (Dih4L[cnt2] == Dih4L2[cnt3])
                                {
                                    if (itempl.Count != 0)//唯一性チェック
                                    {
                                        C3456ZGL[cnt] = new int[0];
                                        itemp7 = -2;
                                        break;
                                    }
                                    if (itemp7 == -2) break;
                                    itempl.Add(cnt2);//C1-C2-C3-C4
                                    itempl.Add(cnt3);//C1-C6-C5-C4
                                }
                            }
                            if (itemp7 == -2) break;
                        }
                        if (itemp7 == -2) continue;
                        //Console.WriteLine("KI : itempl={0}\titempl[0]={1}\titempl[1]={2}\r\nDihLt[itempl[0]]={3}\tDihLt2[itempl[1]]={4}", itempl.Count, itempl[0], itempl[1], DihLt[itempl[0]], DihLt2[itempl[1]]);//debug用
                        if (itempl.Count < 2 || DihLt[itempl[0]] == DihLt2[itempl[1]])
                        {
                            C3456ZGL[cnt] = new int[0];
                            continue;
                        }
                        else if (itempl.Count >= 2)
                        {
                            if (itempl.Count % 2 != 0) throw new ArgumentOutOfRangeException("itempl", "Corsrch : itempl count error.");
                            for (cnt2 = 0; cnt2 < (itempl.Count / 2); cnt2++)
                            {
                                flg = true;
                                for (cnt3 = 0; cnt3 < 4; cnt3++)//C1-C2-C3-C4結合数(混成タイプ)チェック
                                {
                                    itemp2 = 0;
                                    for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                    {
                                        if (gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                    }
                                    if (itemp2 != 3)
                                    {
                                        flg = false;
                                        break;
                                    }
                                }
                                if (flg)
                                {
                                    for (cnt3 = 0; cnt3 < 4; cnt3++)//C1-C6-C5-C4結合数(混成タイプ)チェック
                                    {
                                        itemp2 = 0;
                                        for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                        {
                                            if (gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                        }
                                        if (itemp2 != 3)
                                        {
                                            flg = false;
                                            break;
                                        }
                                    }
                                }
                                if (flg)
                                {
                                    itempl[0] = itempl[cnt2 * 2];
                                    itempl[1] = itempl[cnt2 * 2 + 1];
                                    break;
                                }
                            }
                        }
                        if (!flg)
                        {
                            C3456ZGL[cnt] = new int[0];
                            continue;
                        }
                        else
                        {
                            C3456ZG[0] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 2] : gl._dhl[DihLt[itempl[0]], 1];//C3前を登録
                            C3456ZG[1] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 3] : gl._dhl[DihLt[itempl[0]], 0];//C4前を登録
                            C3456ZG[2] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 2] : gl._dhl[DihLt2[itempl[1]], 1];//C5前を登録
                            C3456ZG[3] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 1] : gl._dhl[DihLt2[itempl[1]], 2];//C6前を登録
                            flg = false;
                        }
                        //Console.WriteLine("A : C3Z={0}\tC4Z={1}\tC5Z={2}\tC6Z={3}", C3456ZG[0], C3456ZG[1], C3456ZG[2], C3456ZG[3]);//debug用
                        DihLt.Clear();
                        DihLt2.Clear();
                        DihLTt.Clear();
                        DihLTt2.Clear();
                        Dih4L.Clear();
                        Dih4L2.Clear();
                        itempl.Clear();
                        for (cnt2 = 0; cnt2 < gl._dhd.Length; cnt2++)//C3456後を探す
                        {
                            if (gl._dhl[cnt2, 0] == BOCCCCOBL[cnt][4])//C1'から始まる二面角情報を探す
                            {
                                if (gl._dhl[cnt2, 1] == BOCCCCOBL[cnt][5])//C2'
                                {
                                    //Console.WriteLine("I : 1true : {0} {1}", gl._dhl[cnt2, 3], cnt2);//debug用
                                    DihLt.Add(cnt2);
                                    DihLTt.Add(true);
                                    Dih4L.Add(gl._dhl[cnt2, 3]);
                                }
                                else if (gl._dhl[cnt2, 1] != BOCCCCOBL[cnt][3])//非C1
                                {
                                    //Console.WriteLine("I : 2true : {0} {1}", gl._dhl[cnt2, 3], cnt2);//debug用
                                    DihLt2.Add(cnt2);
                                    DihLTt2.Add(true);
                                    Dih4L2.Add(gl._dhl[cnt2, 3]);
                                }
                            }
                            if (gl._dhl[cnt2, 3] == BOCCCCOBL[cnt][4])//C1'まで終わる二面角情報を探す
                            {
                                if (gl._dhl[cnt2, 2] == BOCCCCOBL[cnt][5])//C2'
                                {
                                    //Console.WriteLine("I : 1false : {0} {1}", gl._dhl[cnt2, 0], cnt2);//debug用
                                    DihLt.Add(cnt2);
                                    DihLTt.Add(false);
                                    Dih4L.Add(gl._dhl[cnt2, 0]);
                                }
                                else if (gl._dhl[cnt2, 2] != BOCCCCOBL[cnt][3])//非C1
                                {
                                    //Console.WriteLine("I : 2false : {0} {1}", gl._dhl[cnt2, 0], cnt2);//debug用
                                    DihLt2.Add(cnt2);
                                    DihLTt2.Add(false);
                                    Dih4L2.Add(gl._dhl[cnt2, 0]);
                                }
                            }
                        }
                        //Console.WriteLine("A : DihLt={0}\tDihLt2={1}", DihLt.Count, DihLt2.Count);//debug用
                        /*
                        if (DihLt.Count != 3 || DihLt2.Count != 4)//二面角情報個数チェック
                        {
                            C3456ZGL[cnt] = new int[0];
                            continue;
                        }
                        */
                        itemp7 = -1;
                        for (cnt2 = 0; cnt2 < DihLt.Count; cnt2++)//六員環を探す(C1'-C2'-C3'-C4'とC1'-C6'-C5'-C4')
                        {
                            for (cnt3 = 0; cnt3 < DihLt2.Count; cnt3++)
                            {
                                if (Dih4L[cnt2] == Dih4L2[cnt3])
                                {
                                    if (itempl.Count != 0)//唯一性チェック
                                    {
                                        C3456ZGL[cnt] = new int[0];
                                        itemp2 = -2;
                                        break;
                                    }
                                    if (itemp7 == -2) break;
                                    itempl.Add(cnt2);//C1'-C2'-C3'-C4'
                                    itempl.Add(cnt3);//C1'-C6'-C5'-C4'
                                }
                            }
                            if (itemp7 == -2) break;
                        }
                        if (itemp2 == -2) continue;
                        //Console.WriteLine("KO : itempl={0}\titempl[0]={1}\titempl[1]={2}\r\nDihLt[itempl[0]]={3}\tDihLt2[itempl[1]]={4}", itempl.Count, itempl[0], itempl[1], DihLt[itempl[0]], DihLt2[itempl[1]]);//debug用
                        if (itempl.Count < 2 || DihLt[itempl[0]] == DihLt2[itempl[1]])
                        {
                            C3456ZGL[cnt] = new int[0];
                            continue;
                        }
                        else if (itempl.Count >= 2)
                        {
                            if (itempl.Count % 2 != 0) throw new ArgumentOutOfRangeException("itempl", "Corsrch : itempl count error.");
                            for (cnt2 = 0; cnt2 < (itempl.Count / 2); cnt2++)
                            {
                                flg = true;
                                for (cnt3 = 0; cnt3 < 4; cnt3++)//C1'-C2'-C3'-C4'結合数(混成タイプ)チェック
                                {
                                    itemp2 = 0;
                                    for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                    {
                                        if (gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                    }
                                    if (itemp2 != 3)
                                    {
                                        flg = false;
                                        break;
                                    }
                                }
                                if (flg)
                                {
                                    for (cnt3 = 0; cnt3 < 4; cnt3++)//C1'-C6'-C5'-C4'結合数(混成タイプ)チェック
                                    {
                                        itemp2 = 0;
                                        for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                        {
                                            if (gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                        }
                                        if (itemp2 != 3)
                                        {
                                            flg = false;
                                            break;
                                        }
                                    }
                                }
                                if (flg)
                                {
                                    itempl[0] = itempl[cnt2 * 2];
                                    itempl[1] = itempl[cnt2 * 2 + 1];
                                    break;
                                }
                            }
                        }
                        if (!flg)
                        {
                            C3456ZGL[cnt] = new int[0];
                        }
                        else
                        {
                            C3456ZG[4] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 2] : gl._dhl[DihLt[itempl[0]], 1];//C3'後を登録
                            C3456ZG[5] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 3] : gl._dhl[DihLt[itempl[0]], 0];//C4'後を登録
                            C3456ZG[6] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 2] : gl._dhl[DihLt2[itempl[1]], 1];//C5'後を登録
                            C3456ZG[7] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 1] : gl._dhl[DihLt2[itempl[1]], 2];//C6'後を登録
                        }
                        //Console.WriteLine("I : C3G={0}\tC4G={1}\tC5G={2}\tC6G={3}", C3456ZG[4], C3456ZG[5], C3456ZG[6], C3456ZG[7]);//debug用
                        itemp7 = 0;
                        for (cnt2 = 0; cnt2 < 8; cnt2++)//被る原子の無いようにチェック
                        {
                            for (cnt3 = cnt2 + 1; cnt3 < 8; cnt3++)
                            {
                                if (C3456ZG[cnt2] == C3456ZG[cnt3])
                                {
                                    C3456ZGL[cnt] = new int[0];
                                    itemp7 = 1;
                                }
                                if (itemp7 == 1) break;
                            }
                            if (itemp7 == 1) break;
                            for (cnt3 = 2; cnt3 < 6; cnt3++)
                            {
                                if (C3456ZG[cnt2] == BOCCCCOBL[cnt][cnt3])
                                {
                                    C3456ZGL[cnt] = new int[0];
                                    itemp7 = 1;
                                }
                                if (itemp7 == 1) break;
                            }
                        }
                        if (itemp7 == 1)
                        {
                            C3456ZGL[cnt] = new int[0];
                            continue;
                        }
                        flg2 = true;
                        C3456ZGL[cnt] = C3456ZG;
                        HOCCCCOHL = null;
                    }
                }
                else
                {
                    flg2 = false;
                }
                cnt3 = 0;
                if (flg2)
                {
                    OCOCHacL = new int[BOCCCCOBL.Count][];
                    flg2 = false;
                    for (cnt = 0; cnt < BOCCCCOBL.Count; cnt++)//OAc部分を探す
                    {
                        OCOCHacL[cnt] = new int[0];
                        OCOCHL = new List<int>();
                        cnt3 = 0;
                        flg = false;
                        for (cnt2 = 0; cnt2 < gl._rdd.Length; cnt2++)//Oを探す
                        {
                            if (gl._rdl[cnt2, 0] != BOCCCCOBL[cnt][0] && gl._rdl[cnt2, 1] != BOCCCCOBL[cnt][0]) continue;
                            cnt3++;
                            itemp7 = gl._rdl[cnt2, gl._rdl[cnt2, 0] == BOCCCCOBL[cnt][0] ? 1 : 0];
                            if (itemp7 == BOCCCCOBL[cnt][1] || itemp7 == BOCCCCOBL[cnt][6]) continue;
                            if (gl._als[itemp7] != 8) continue;
                            OCOCHL.Add(itemp7);
                        }
                        if (cnt3 != 3) continue;
                        if (OCOCHL.Count != 1) continue;
                        cnt3 = 0;
                        for (cnt2 = 0; cnt2 < gl._rdd.Length; cnt2++)//COのCを探す
                        {
                            if (gl._rdl[cnt2, 0] != itemp7 && gl._rdl[cnt2, 1] != itemp7) continue;
                            cnt3++;
                            itemp2 = gl._rdl[cnt2, gl._rdl[cnt2, 0] == itemp7 ? 1 : 0];
                            if (itemp2 == BOCCCCOBL[cnt][0]) continue;
                            if (gl._als[itemp2] != 6) continue;
                            OCOCHL.Add(itemp2);
                        }
                        if (cnt3 != 2) continue;
                        if (OCOCHL.Count != 2) continue;
                        cnt3 = 0;
                        for (cnt2 = 0; cnt2 < gl._rdd.Length; cnt2++)//COのOを探す
                        {
                            if (gl._rdl[cnt2, 0] != OCOCHL[1] && gl._rdl[cnt2, 1] != OCOCHL[1]) continue;
                            cnt3++;
                            itemp7 = gl._rdl[cnt2, gl._rdl[cnt2, 0] == OCOCHL[1] ? 1 : 0];
                            if (itemp7 == OCOCHL[0]) continue;
                            if (gl._als[itemp7] == 8) OCOCHL.Add(itemp7);
                            if (gl._als[itemp7] == 6) itemp2 = itemp7;
                        }
                        if (cnt3 != 3) continue;
                        if (OCOCHL.Count != 3) continue;
                        OCOCHL.Add(itemp2);
                        cnt3 = 0;
                        for (cnt2 = 0; cnt2 < gl._rdd.Length; cnt2++)//COのOを探す
                        {
                            if (gl._rdl[cnt2, 0] != OCOCHL[3] && gl._rdl[cnt2, 1] != OCOCHL[3]) continue;
                            cnt3++;
                            itemp7 = gl._rdl[cnt2, gl._rdl[cnt2, 0] == OCOCHL[3] ? 1 : 0];
                            if (itemp7 == OCOCHL[1]) continue;
                            if (gl._als[itemp7] == 1) OCOCHL.Add(itemp7);
                            if (gl._als[itemp7] == 6) flg = true;
                        }
                        if (cnt3 != 4) continue;
                        if (!(OCOCHL.Count == 6 && flg) && !(OCOCHL.Count == 7 && !flg)) continue;
                        OCOCHacL[cnt] = OCOCHL.ToArray();
                        flg2 = true;
                        //Console.WriteLine("SU : OCOCHL={0}\t : {1},{2},{3},{4},{5},{6}{7}\r\nflg={8}", OCOCHL.Count, OCOCHL[0], OCOCHL[1], OCOCHL[2], OCOCHL[3], OCOCHL[4], OCOCHL[5], flg ? "" : string.Format(",{0}", OCOCHL[6].ToString()), flg);//debug用
                    }
                }
                if (flg2)
                {
                    HOCCCCOHL = null;
                }
            }
            if (BorL.Length == 0 || !flg2)//フリーBINOL
            {
                DihLt.Clear();
                DihLt2.Clear();
                DihLTt.Clear();
                DihLTt2.Clear();
                Dih4L.Clear();
                Dih4L2.Clear();
                itempl.Clear();
                BOCCCCOBL = null;
                OCOCHL = null;
                OCOCHacL = null;
                CoB = -1;
                CoOb = -1;
                CoCco = -1;
                CoOco = -1;
                CoCac = -1;
                CoHac = new int[0];
                if (HydL.Length < 2) throw new ArgumentOutOfRangeException("HydL", "Corsrch : Hydrogen atom number is less than 2 in free BINOL.");
                Parallel.For(0, gl._dhd.Length, po, (cntf) =>
                  {
                      for (int cnt2 = 0; cnt2 < OxyL.Length; cnt2++)//酸素リストを列挙してOを特定する
                      {
                          if (gl._dhl[cntf, 1] == OxyL[cnt2])//H-O-C-C
                          {
                              if (gl._als[gl._dhl[cntf, 0]] != 1 || gl._als[gl._dhl[cntf, 2]] != 6 || gl._als[gl._dhl[cntf, 3]] != 6) continue;
                              lock (lo)
                              {
                                  //Console.WriteLine("I : false : {0} {1}", gl._dhl[cntf, 3], cntf);//debug用
                                  DihLt.Add(cntf);
                                  DihLTt.Add(false);
                                  Dih4L.Add(gl._dhl[cntf, 3]);
                              }
                          }
                          else if (gl._dhl[cntf, 2] == OxyL[cnt2])//C-C-O-H
                          {
                              if (gl._als[gl._dhl[cntf, 3]] != 1 || gl._als[gl._dhl[cntf, 0]] != 6 || gl._als[gl._dhl[cntf, 1]] != 6) continue;
                              lock (lo)
                              {
                                  //Console.WriteLine("I : true : {0} {1}", gl._dhl[cntf, 0], cntf);//debug用
                                  DihLt.Add(cntf);
                                  DihLTt.Add(true);
                                  Dih4L.Add(gl._dhl[cntf, 0]);
                              }
                          }
                      }
                  });//二面角情報でH-O-C-C或いはC-C-O-Hを探す
                //Console.WriteLine("KO : DihLt={0}\tDihLt[0]={1},{2},{3},{4}\r\nDihLTt[0]={5}\tDih4L[0]={6}", DihLt.Count, DihLt[0], DihLt[1], DihLt[2], DihLt[3], DihLTt[0], Dih4L[0]);//debug用
                if (DihLt.Count < 2) throw new ArgumentOutOfRangeException("DihLT", "Corsrch : H-O-C-C structure number is less than 2 in free BINOL.");
                Parallel.For(0, DihLt.Count, po, (cntf) =>
                   {
                       bool flg = false;
                       int cnt = cntf;
                       int cnt2 = 0;
                       int cnt3 = 0;
                       int itemp = 0;
                       int itemp2 = 0;
                       int itemp3 = 0;
                       int[] HOCCCCOH = new int[8];//H-O-C2-C1-C1'-C2'-O'-H'構造
                       for (cnt2 = cnt + 1; cnt2 < DihLt.Count; cnt2++)//真ん中のC-C結合を確認する
                       {
                           for (cnt3 = 0; cnt3 < gl._rdd.Length; cnt3++)//結合を列挙してC1-C'を探す
                           {
                               if ((gl._rdl[cnt3, 0] == Dih4L[cnt] && gl._rdl[cnt3, 1] == Dih4L[cnt2]) || (gl._rdl[cnt3, 1] == Dih4L[cnt] && gl._rdl[cnt3, 0] == Dih4L[cnt2]))
                               {
                                   itemp2 = DihLTt[cnt] ? gl._dhl[DihLt[cnt], 3] : gl._dhl[DihLt[cnt], 0];//一個目のH
                                   itemp3 = DihLTt[cnt2] ? gl._dhl[DihLt[cnt2], 3] : gl._dhl[DihLt[cnt2], 0];//二個目のH
                                   if (itemp2 != itemp3)//同じHではない
                                   {
                                       if (itemp2 < itemp3)
                                       {
                                           itemp = itemp3;
                                           itemp3 = itemp2;
                                           itemp2 = itemp;
                                           itemp = cnt2;
                                           cnt2 = cnt;
                                           cnt = itemp;
                                       }
                                       if (DihLTt[cnt2])//H-O-C2-C1
                                       {
                                           HOCCCCOH[0] = itemp3;
                                           HOCCCCOH[1] = gl._dhl[DihLt[cnt2], 2];
                                           HOCCCCOH[2] = gl._dhl[DihLt[cnt2], 1];
                                           HOCCCCOH[3] = gl._dhl[DihLt[cnt2], 0];
                                       }
                                       else
                                       {
                                           HOCCCCOH[0] = itemp3;
                                           HOCCCCOH[1] = gl._dhl[DihLt[cnt2], 1];
                                           HOCCCCOH[2] = gl._dhl[DihLt[cnt2], 2];
                                           HOCCCCOH[3] = gl._dhl[DihLt[cnt2], 3];
                                       }
                                       if (DihLTt[cnt])//C1'-C2'-O'-H'
                                       {
                                           HOCCCCOH[4] = gl._dhl[DihLt[cnt], 0];
                                           HOCCCCOH[5] = gl._dhl[DihLt[cnt], 1];
                                           HOCCCCOH[6] = gl._dhl[DihLt[cnt], 2];
                                           HOCCCCOH[7] = itemp2;
                                       }
                                       else
                                       {
                                           HOCCCCOH[4] = gl._dhl[DihLt[cnt], 3];
                                           HOCCCCOH[5] = gl._dhl[DihLt[cnt], 2];
                                           HOCCCCOH[6] = gl._dhl[DihLt[cnt], 1];
                                           HOCCCCOH[7] = itemp2;
                                       }
                                       flg = true;
                                       for (itemp2 = 0; itemp2 < 8; itemp2++)//被る原子の無いようにチェック
                                       {
                                           for (itemp3 = itemp2 + 1; itemp3 < 8; itemp3++)
                                           {
                                               if (HOCCCCOH[itemp2] == HOCCCCOH[itemp3]) flg = false;
                                           }
                                       }
                                       if (flg)
                                       {
                                           for (cnt3 = 0; cnt3 < 8; cnt3++)//結合数(混成タイプ)チェック
                                           {
                                               itemp2 = 0;
                                               for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                               {
                                                   if (HOCCCCOH[cnt3] == gl._rdl[itemp3, 0] || HOCCCCOH[cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                               }
                                               if (cnt3 == 0 || cnt3 == 7)
                                               {
                                                   if (itemp2 != 1)
                                                   {
                                                       flg = false;
                                                       break;
                                                   }
                                               }
                                               if (cnt3 == 1 || cnt3 == 6)
                                               {
                                                   if (itemp2 != 2)
                                                   {
                                                       flg = false;
                                                       break;
                                                   }
                                               }
                                               if (cnt3 == 2 || cnt3 == 3 || cnt3 == 4 || cnt3 == 5)
                                               {
                                                   if (itemp2 != 3)
                                                   {
                                                       flg = false;
                                                       break;
                                                   }
                                               }
                                           }
                                       }
                                       if (flg)
                                       {
                                           lock (lo) HOCCCCOHL.Add(HOCCCCOH);
                                           flg = false;
                                           break;
                                       }
                                   }
                               }
                           }
                       }
                   });//H-O-C-C-C-C-O-Hを探す
                /*
                Console.WriteLine("KO : HOCCCCOHL={0}", HOCCCCOHL.Count);
                for (int dcnt = 0; dcnt < HOCCCCOHL.Count; dcnt++)
                {
                    Console.WriteLine("KO : [{0}]:{1},{2},{3},{4},{5},{6},{7},{8}", dcnt, HOCCCCOHL[dcnt][0], HOCCCCOHL[dcnt][1], HOCCCCOHL[dcnt][2], HOCCCCOHL[dcnt][3], HOCCCCOHL[dcnt][4], HOCCCCOHL[dcnt][5], HOCCCCOHL[dcnt][6], HOCCCCOHL[dcnt][7]);
                }
                //*///debug用
                if (HOCCCCOHL.Count < 1) throw new ArgumentOutOfRangeException("HOCCCCOHL", "Corsrch : H-O-C-C-C-C-O-H structure number is less than 1 in free BINOL.");
                C3456ZGL = new int[HOCCCCOHL.Count][];
                DihLt.Clear();
                DihLTt.Clear();
                Dih4L.Clear();
                int cnt = 0;
                for (cnt = 0; cnt < HOCCCCOHL.Count; cnt++)//HOCCCCOH構造毎にビフェニル構造を探す
                {
                    Parallel.For(0, gl._dhd.Length, po, (cntf) =>
                      {
                          if (gl._dhl[cntf, 0] == HOCCCCOHL[cnt][3])//C1から始まる二面角情報を探す
                          {
                              if (gl._dhl[cntf, 1] == HOCCCCOHL[cnt][2])//C2
                              {
                                  //Console.WriteLine("SU : 1true : {0} {1}", gl._dhl[cntf, 3], cntf);//debug用
                                  lock (lo)
                                  {
                                      DihLt.Add(cntf);
                                      DihLTt.Add(true);
                                      Dih4L.Add(gl._dhl[cntf, 3]);
                                  }
                              }
                              else if (gl._dhl[cntf, 1] != HOCCCCOHL[cnt][4])//非C1'
                              {
                                  //Console.WriteLine("SU : 2true : {0} {1}", gl._dhl[cntf, 3], cntf);//debug用
                                  lock (lo)
                                  {
                                      DihLt2.Add(cntf);
                                      DihLTt2.Add(true);
                                      Dih4L2.Add(gl._dhl[cntf, 3]);
                                  }
                              }
                          }
                          if (gl._dhl[cntf, 3] == HOCCCCOHL[cnt][3])//C1まで終わる二面角情報を探す
                          {
                              if (gl._dhl[cntf, 2] == HOCCCCOHL[cnt][2])//C2
                              {
                                  //Console.WriteLine("SU : 1false : {0} {1}", gl._dhl[cntf, 0], cntf);//debug用
                                  lock (lo)
                                  {
                                      DihLt.Add(cntf);
                                      DihLTt.Add(false);
                                      Dih4L.Add(gl._dhl[cntf, 0]);
                                  }
                              }
                              else if (gl._dhl[cntf, 2] != HOCCCCOHL[cnt][4])//非C1'
                              {
                                  //Console.WriteLine("SU : 2false : {0} {1}", gl._dhl[cntf, 0], cntf);//debug用
                                  lock (lo)
                                  {
                                      DihLt2.Add(cntf);
                                      DihLTt2.Add(false);
                                      Dih4L2.Add(gl._dhl[cntf, 0]);
                                  }
                              }
                          }
                      });//C3456前を探す
                    //Console.WriteLine("A : DihLt={0}\tDihLt2={1}", DihLt.Count, DihLt2.Count);//debug用
                    /*
                    if (DihLt.Count != 3 || DihLt2.Count != 4)//二面角情報個数チェック
                    {
                        C3456ZGL[cnt] = new int[0];
                        continue;
                    }
                    //*/
                    int itemp5 = -1;
                    int cnt2 = 0;
                    int cnt3 = 0;
                    int itemp2 = 0;
                    int itemp3 = 0;
                    flg = false;
                    for (cnt2 = 0; cnt2 < DihLt.Count; cnt2++)//六員環を探す(C1-C2-C3-C4とC1-C6-C5-C4)
                    {
                        for (cnt3 = 0; cnt3 < DihLt2.Count; cnt3++)
                        {
                            if (Dih4L[cnt2] == Dih4L2[cnt3])
                            {
                                if (itempl.Count != 0)//唯一性チェック
                                {
                                    C3456ZGL[cnt] = new int[0];
                                    itemp5 = -2;
                                    break;
                                }
                                if (itemp5 == -2) break;
                                itempl.Add(cnt2);//C1-C2-C3-C4
                                itempl.Add(cnt3);//C1-C6-C5-C4
                            }
                        }
                        if (itemp5 == -2) break;
                    }
                    if (itemp5 == -2) continue;
                    //Console.WriteLine("KI : itempl={0}\titempl[0]={1}\titempl[1]={2}\r\nDihLt[itempl[0]]={3}\tDihLt2[itempl[1]]={4}", itempl.Count, itempl[0], itempl[1], DihLt[itempl[0]], DihLt2[itempl[1]]);//debug用
                    if (itempl.Count < 2 || DihLt[itempl[0]] == DihLt2[itempl[1]])
                    {
                        C3456ZGL[cnt] = new int[0];
                        continue;
                    }
                    else if (itempl.Count >= 2)
                    {
                        if (itempl.Count % 2 != 0) throw new ArgumentOutOfRangeException("itempl", "Corsrch : itempl count error.");
                        for (cnt2 = 0; cnt2 < (itempl.Count / 2); cnt2++)
                        {
                            flg = true;
                            for (cnt3 = 0; cnt3 < 4; cnt3++)//C1-C2-C3-C4結合数(混成タイプ)チェック
                            {
                                itemp2 = 0;
                                for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                {
                                    if (gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                }
                                if (itemp2 != 3)
                                {
                                    flg = false;
                                    break;
                                }
                            }
                            if (flg)
                            {
                                for (cnt3 = 0; cnt3 < 4; cnt3++)//C1-C6-C5-C4結合数(混成タイプ)チェック
                                {
                                    itemp2 = 0;
                                    for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                    {
                                        if (gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                    }
                                    if (itemp2 != 3)
                                    {
                                        flg = false;
                                        break;
                                    }
                                }
                            }
                            if (flg)
                            {
                                itempl[0] = itempl[cnt2 * 2];
                                itempl[1] = itempl[cnt2 * 2 + 1];
                                break;
                            }
                        }
                    }
                    if (!flg)
                    {
                        C3456ZGL[cnt] = new int[0];
                        continue;
                    }
                    else
                    {
                        C3456ZG[0] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 2] : gl._dhl[DihLt[itempl[0]], 1];//C3前を登録
                        C3456ZG[1] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 3] : gl._dhl[DihLt[itempl[0]], 0];//C4前を登録
                        C3456ZG[2] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 2] : gl._dhl[DihLt2[itempl[1]], 1];//C5前を登録
                        C3456ZG[3] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 1] : gl._dhl[DihLt2[itempl[1]], 2];//C6前を登録
                        flg = false;
                    }
                    //Console.WriteLine("E : C3Z={0}\tC4Z={1}\tC5Z={2}\tC6Z={3}", C3456ZG[0], C3456ZG[1], C3456ZG[2], C3456ZG[3]);//debug用
                    DihLt.Clear();
                    DihLt2.Clear();
                    DihLTt.Clear();
                    DihLTt2.Clear();
                    Dih4L.Clear();
                    Dih4L2.Clear();
                    itempl.Clear();
                    for (cnt2 = 0; cnt2 < gl._dhd.Length; cnt2++)//C3456後を探す
                    {
                        if (gl._dhl[cnt2, 0] == HOCCCCOHL[cnt][4])//C1'から始まる二面角情報を探す
                        {
                            if (gl._dhl[cnt2, 1] == HOCCCCOHL[cnt][5])//C2'
                            {
                                //Console.WriteLine("KI : 1true : {0} {1}", gl._dhl[cnt2, 3], cnt2);//debug用
                                lock (lo)
                                {
                                    DihLt.Add(cnt2);
                                    DihLTt.Add(true);
                                    Dih4L.Add(gl._dhl[cnt2, 3]);
                                }
                            }
                            else if (gl._dhl[cnt2, 1] != HOCCCCOHL[cnt][3])//非C1
                            {
                                //Console.WriteLine("KI : 2true : {0} {1}", gl._dhl[cnt2, 3], cnt2);//debug用
                                lock (lo)
                                {
                                    DihLt2.Add(cnt2);
                                    DihLTt2.Add(true);
                                    Dih4L2.Add(gl._dhl[cnt2, 3]);
                                }
                            }
                        }
                        if (gl._dhl[cnt2, 3] == HOCCCCOHL[cnt][4])//C1'まで終わる二面角情報を探す
                        {
                            if (gl._dhl[cnt2, 2] == HOCCCCOHL[cnt][5])//C2'
                            {
                                //Console.WriteLine("KI : 1false : {0} {1}", gl._dhl[cnt2, 0], cnt2);//debug用
                                lock (lo)
                                {
                                    DihLt.Add(cnt2);
                                    DihLTt.Add(false);
                                    Dih4L.Add(gl._dhl[cnt2, 0]);
                                }
                            }
                            else if (gl._dhl[cnt2, 2] != HOCCCCOHL[cnt][3])//非C1
                            {
                                //Console.WriteLine("KI : 2false : {0} {1}", gl._dhl[cnt2, 0], cnt2);//debug用
                                lock (lo)
                                {
                                    DihLt2.Add(cnt2);
                                    DihLTt2.Add(false);
                                    Dih4L2.Add(gl._dhl[cnt2, 0]);
                                }
                            }
                        }
                    }
                    //Console.WriteLine("KI : DihLt={0}\tDihLt2={1}", DihLt.Count, DihLt2.Count);//debug用
                    /*
                    if (DihLt.Count != 3 || DihLt2.Count != 4)//二面角情報個数チェック
                    {
                        C3456ZGL[cnt] = new int[0];
                        continue;
                    }
                    //*/
                    int itemp6 = -1;
                    for (cnt2 = 0; cnt2 < DihLt.Count; cnt2++)//六員環を探す(C1'-C2'-C3'-C4'とC1'-C6'-C5'-C4')
                    {
                        for (cnt3 = 0; cnt3 < DihLt2.Count; cnt3++)
                        {
                            if (Dih4L[cnt2] == Dih4L2[cnt3])
                            {
                                if (itempl.Count != 0)//唯一性チェック
                                {
                                    C3456ZGL[cnt] = new int[0];
                                    itemp2 = -2;
                                    break;
                                }
                                if (itemp6 == -2) break;
                                itempl.Add(cnt2);//C1'-C2'-C3'-C4'
                                itempl.Add(cnt3);//C1'-C6'-C5'-C4'
                            }
                        }
                        if (itemp6 == -2) break;
                    }
                    if (itemp2 == -2) continue;
                    //Console.WriteLine("SU : itempl={0}\titempl[0]={1}\titempl[1]={2}\r\nDihLt[itempl[0]]={3}\tDihLt2[itempl[1]]={4}", itempl.Count, itempl[0], itempl[1], DihLt[itempl[0]], DihLt2[itempl[1]]);//debug用
                    if (itempl.Count < 2 || DihLt[itempl[0]] == DihLt2[itempl[1]])
                    {
                        C3456ZGL[cnt] = new int[0];
                        continue;
                    }
                    else if (itempl.Count >= 2)
                    {
                        if (itempl.Count % 2 != 0) throw new ArgumentOutOfRangeException("itempl", "Corsrch : itempl count error.");
                        for (cnt2 = 0; cnt2 < (itempl.Count / 2); cnt2++)
                        {
                            flg = true;
                            for (cnt3 = 0; cnt3 < 4; cnt3++)//C1'-C2'-C3'-C4'結合数(混成タイプ)チェック
                            {
                                itemp2 = 0;
                                for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                {
                                    if (gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt[itempl[cnt2 * 2]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                }
                                if (itemp2 != 3)
                                {
                                    flg = false;
                                    break;
                                }
                            }
                            if (flg)
                            {
                                for (cnt3 = 0; cnt3 < 4; cnt3++)//C1'-C6'-C5'-C4'結合数(混成タイプ)チェック
                                {
                                    itemp2 = 0;
                                    for (itemp3 = 0; itemp3 < gl._rdd.Length; itemp3++)
                                    {
                                        if (gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 0] || gl._dhl[DihLt2[itempl[cnt2 * 2 + 1]], cnt3] == gl._rdl[itemp3, 1]) itemp2++;
                                    }
                                    if (itemp2 != 3)
                                    {
                                        flg = false;
                                        break;
                                    }
                                }
                            }
                            if (flg)
                            {
                                itempl[0] = itempl[cnt2 * 2];
                                itempl[1] = itempl[cnt2 * 2 + 1];
                                break;
                            }
                        }
                    }
                    if (!flg)
                    {
                        C3456ZGL[cnt] = new int[0];
                        continue;
                    }
                    else
                    {
                        C3456ZG[4] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 2] : gl._dhl[DihLt[itempl[0]], 1];//C3'後を登録
                        C3456ZG[5] = DihLTt[itempl[0]] ? gl._dhl[DihLt[itempl[0]], 3] : gl._dhl[DihLt[itempl[0]], 0];//C4'後を登録
                        C3456ZG[6] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 2] : gl._dhl[DihLt2[itempl[1]], 1];//C5'後を登録
                        C3456ZG[7] = DihLTt2[itempl[1]] ? gl._dhl[DihLt2[itempl[1]], 1] : gl._dhl[DihLt2[itempl[1]], 2];//C6'後を登録
                    }
                    //Console.WriteLine("KO : C3G={0}\tC4G={1}\tC5G={2}\tC6G={3}", C3456ZG[4], C3456ZG[5], C3456ZG[6], C3456ZG[7]);//debug用
                    itemp6 = 0;
                    for (cnt2 = 0; cnt2 < 8; cnt2++)//被る原子の無いようにチェック
                    {
                        for (cnt3 = cnt2 + 1; cnt3 < 8; cnt3++)
                        {
                            if (C3456ZG[cnt2] == C3456ZG[cnt3])
                            {
                                C3456ZGL[cnt] = new int[0];
                                itemp6 = 1;
                            }
                            if (itemp6 == 1) break;
                        }
                        if (itemp6 == 1) break;
                        for (cnt3 = 2; cnt3 < 6; cnt3++)
                        {
                            if (C3456ZG[cnt2] == HOCCCCOHL[cnt][cnt3])
                            {
                                C3456ZGL[cnt] = new int[0];
                                itemp6 = 1;
                            }
                            if (itemp6 == 1) break;
                        }
                    }
                    if (itemp6 == 1) continue;
                    flg2 = true;
                    C3456ZGL[cnt] = C3456ZG;
                }
            }
            if (!flg2) throw new ArgumentOutOfRangeException("flg2", "Corsrch : Can not find BINOL core.");
            Dih4L = null;
            Dih4L2 = null;
            DihLt = null;
            DihLt2 = null;
            DihLTt = null;
            DihLTt2 = null;
            int itemp = 0;
            if (OCOCHacL == null)
            {
                BINOLt = null;
                for (int cnt = 0; cnt < C3456ZGL.Length; cnt++)
                {
                    if (C3456ZGL[cnt].Length != 8) continue;
                    itemp = cnt;
                    break;
                }
                if (C3456ZGL[itemp].Length != 8) throw new ArgumentOutOfRangeException("C3456ZGL", "Corsrch : Can not find free BINOL core.");
                flg = gl._nch[C3456ZGL[itemp][0]] > gl._nch[C3456ZGL[itemp][4]];//NBO自然電荷の高いC3が先
                CoC1 = new int[2];
                CoC1[0] = HOCCCCOHL[itemp][flg ? 3 : 4];
                CoC1[1] = HOCCCCOHL[itemp][flg ? 4 : 3];
                CoC2 = new int[2];
                CoC2[0] = HOCCCCOHL[itemp][flg ? 2 : 5];
                CoC2[1] = HOCCCCOHL[itemp][flg ? 5 : 2];
                CoO = new int[2];
                CoO[0] = HOCCCCOHL[itemp][flg ? 1 : 6];
                CoO[1] = HOCCCCOHL[itemp][flg ? 6 : 1];
                CoH = new int[2];
                CoH[0] = HOCCCCOHL[itemp][flg ? 0 : 7];
                CoH[1] = HOCCCCOHL[itemp][flg ? 7 : 0];
            }
            else
            {
                for (int cnt = 0; cnt < OCOCHacL.Length; cnt++)
                {
                    if (OCOCHacL[cnt].Length != 8 && OCOCHacL[cnt].Length != 7) continue;
                    itemp = cnt;
                    break;
                }
                if (OCOCHacL[itemp].Length == 7) BINOLt = false;
                else if (OCOCHacL[itemp].Length == 6) BINOLt = true;
                else throw new ArgumentOutOfRangeException("OCOCHacL", "Corsrch : Can not find B coordinated BINOL core.");
                flg = gl._nch[C3456ZGL[itemp][0]] > gl._nch[C3456ZGL[itemp][4]];//NBO自然電荷の高いC3が先
                CoC1 = new int[2];
                CoC1[0] = BOCCCCOBL[itemp][flg ? 3 : 4];
                CoC1[1] = BOCCCCOBL[itemp][flg ? 4 : 3];
                CoC2 = new int[2];
                CoC2[0] = BOCCCCOBL[itemp][flg ? 2 : 5];
                CoC2[1] = BOCCCCOBL[itemp][flg ? 5 : 2];
                CoO = new int[2];
                CoO[0] = BOCCCCOBL[itemp][flg ? 1 : 6];
                CoO[1] = BOCCCCOBL[itemp][flg ? 6 : 1];
                CoB = BOCCCCOBL[itemp][0];
                CoOb = OCOCHacL[itemp][0];
                CoCco = OCOCHacL[itemp][1];
                CoOco = OCOCHacL[itemp][2];
                CoCac = OCOCHacL[itemp][3];
                if (BINOLt == false)
                {
                    CoHac = new int[3];
                    CoHac[2] = OCOCHacL[itemp][6];
                }
                else if (BINOLt == true) CoHac = new int[2];
                CoHac[0] = OCOCHacL[itemp][4];
                CoHac[1] = OCOCHacL[itemp][5];
            }
            CoC3 = new int[2];
            CoC3[0] = C3456ZGL[itemp][flg ? 0 : 4];
            CoC3[1] = C3456ZGL[itemp][flg ? 4 : 0];
            CoC4 = new int[2];
            CoC4[0] = C3456ZGL[itemp][flg ? 1 : 5];
            CoC4[1] = C3456ZGL[itemp][flg ? 5 : 1];
            CoC5 = new int[2];
            CoC5[0] = C3456ZGL[itemp][flg ? 2 : 6];
            CoC5[1] = C3456ZGL[itemp][flg ? 6 : 2];
            CoC6 = new int[2];
            CoC6[0] = C3456ZGL[itemp][flg ? 3 : 7];
            CoC6[1] = C3456ZGL[itemp][flg ? 7 : 3];
            //Console.WriteLine("KI : H:{0},{1}({2}),{3},{4},{5},{6}\r\nL:{7},{8}({9}),{10},{11},{12},{13}", CoC1[0], CoC2[0], CoO[0], CoC3[0], CoC4[0], CoC5[0], CoC6[0], CoC1[1], CoC2[1], CoO[1], CoC3[1], CoC4[1], CoC5[1], CoC6[1]);//debug用
            BOCCCCOBL = null;
            OCOCHL = null;
            OCOCHacL = null;
            HOCCCCOHL = null;
            C3456ZG = null;
            C3456ZGL = null;
            itempl = null;
            List<int[]> CoFuRi = new List<int[]>();//縮合環リストHigh
            int[] BasRi = new int[6] { CoC2[0], CoC3[0], CoC4[0], CoC5[0], CoC6[0], CoC1[0] };//コア環High
            CoFuRiSrch(ref CoFuRi, in BasRi, ref po);
            List<int> CFRl = new List<int>(BasRi);//縮合環式構造High一時リスト
            foreach (int[] cfr in CoFuRi)
            {
                foreach (int ind in cfr)
                {
                    flg = false;
                    foreach (int ind2 in CFRl)
                    {
                        if (ind == ind2)
                        {
                            flg = true;
                            break;
                        }
                    }
                    if (!flg)
                    {
                        CFRl.Add(ind);
                    }
                }
            }
            CoFuRiH = CFRl.ToArray();
            /*
            Console.WriteLine("A : CoFuRiH={0}", CoFuRiH.Length);
            foreach (int itempd in CoFuRiH)
            {
                Console.Write("{0} ", itempd);
            }
            Console.WriteLine();
            //*///debug用
            CoFuRi = new List<int[]>();//縮合環リストLow
            BasRi = new int[6] { CoC2[1], CoC3[1], CoC4[1], CoC5[1], CoC6[1], CoC1[1] };//コア環Low
            CoFuRiSrch(ref CoFuRi, in BasRi, ref po);
            CFRl = new List<int>(BasRi);//縮合環式構造Low一時リスト
            foreach (int[] cfr in CoFuRi)
            {
                foreach (int ind in cfr)
                {
                    flg = false;
                    foreach (int ind2 in CFRl)
                    {
                        if (ind == ind2)
                        {
                            flg = true;
                            break;
                        }
                    }
                    if (!flg)
                    {
                        CFRl.Add(ind);
                    }
                }
            }
            CoFuRiL = CFRl.ToArray();
            /*
            Console.WriteLine("SU : CoFuRiL={0}", CoFuRiL.Length);
            foreach (int itempd in CoFuRiL)
            {
                Console.Write("{0} ", itempd);
            }
            Console.WriteLine();
            //*///debug用
            CoFuRi = null;
            BasRi = null;
            CFRl = null;
            List<int> sub3 = new List<int>() { CoC2[0], CoC3[0], CoC4[0], CoC5[0], CoC6[0] };//初期3位High置換基リスト{C2,C3,C4,C5,C6}
            Sub3Srch(ref sub3, CoC3[0], ref po);
            sub3.RemoveRange(0, 5);
            if (sub3.Count < 1) throw new ArgumentOutOfRangeException("sub3", "CorSrch : Substitution atom on C3 (High) is less than 1.");
            sub3H = sub3.ToArray();
            /*
            Console.WriteLine("I : sub3H={0}", sub3H.Length);
            foreach (int itempd in sub3H)
            {
                Console.Write("{0} ", itempd);
            }
            Console.WriteLine();
            //*///debug用
            sub3 = new List<int>() { CoC2[1], CoC3[1], CoC4[1], CoC5[1], CoC6[1] };//初期3位Low置換基リスト{C2,C3,C4,C5,C6}
            Sub3Srch(ref sub3, CoC3[1], ref po);
            sub3.RemoveRange(0, 5);
            if (sub3.Count < 1) throw new ArgumentOutOfRangeException("sub3", "CorSrch : Substitution atom on C3 (Low) is less than 1.");
            sub3L = sub3.ToArray();
            /*
            Console.WriteLine("KI : sub3L={0}", sub3L.Length);
            foreach (int itempd in sub3L)
            {
                Console.Write("{0} ", itempd);
            }
            Console.WriteLine();
            //*///debug用
            sub3 = null;
        }
        private void CoFuRiSrch(ref List<int[]> CoFuRi, in int[] BasRi, ref ParallelOptions po)//縮合共役環式構造を探す
        {
            int cnt, itemp, itemp2, itemp3, itemp4;
            object lo = new object();
            List<int> DihLt, DihLt2;
            List<bool> DihLTt, DihLTt2;
            List<int[]> CFRt = new List<int[]>();
            for (cnt = 0; cnt < BasRi.Length - 1; cnt++)//結合毎に環式構造を探す
            {
                DihLt = new List<int>();
                DihLt2 = new List<int>();
                DihLTt = new List<bool>();
                DihLTt2 = new List<bool>();
                itemp = BasRi[cnt];
                itemp2 = BasRi[cnt + 1];
                itemp3 = BasRi[cnt == 0 ? BasRi.Length - 1 : cnt - 1];
                itemp4 = BasRi[cnt == BasRi.Length - 2 ? 0 : cnt + 2];
                Parallel.For(0, gl._dhd.Length, po, (cntf) =>
                {
                    if (gl._dhl[cntf, 0] == itemp)//itempから始まる二面角を探す
                    {
                        if (gl._dhl[cntf, 1] != itemp2 && gl._dhl[cntf, 1] != itemp3)
                        {
                            lock (lo)
                            {
                                DihLt.Add(cntf);
                                DihLTt.Add(true);
                            }
                        }
                    }
                    else if (gl._dhl[cntf, 3] == itemp)//itempまで終わる二面角を探す
                    {
                        if (gl._dhl[cntf, 2] != itemp2 && gl._dhl[cntf, 2] != itemp3)
                        {
                            lock (lo)
                            {
                                DihLt.Add(cntf);
                                DihLTt.Add(false);
                            }
                        }
                    }
                    else if (gl._dhl[cntf, 0] == itemp2)//itemp2から始まる二面角を探す
                    {
                        if (gl._dhl[cntf, 1] != itemp && gl._dhl[cntf, 1] != itemp4)
                        {
                            lock (lo)
                            {
                                DihLt2.Add(cntf);
                                DihLTt2.Add(true);
                            }
                        }
                    }
                    else if (gl._dhl[cntf, 3] == itemp2)//itemp2まで終わる二面角を探す
                    {
                        if (gl._dhl[cntf, 2] != itemp && gl._dhl[cntf, 2] != itemp4)
                        {
                            lock (lo)
                            {
                                DihLt2.Add(cntf);
                                DihLTt2.Add(false);
                            }
                        }
                    }
                });
                if (DihLt.Count < 1 || DihLTt.Count < 1 || DihLt2.Count < 1 || DihLTt2.Count < 1) continue;
                Parallel.For(0, DihLTt.Count, po, (cntf) =>
                   {
                       int cnt2;
                       List<int> ringt = new List<int>();
                       for (cnt2 = 0; cnt2 < DihLt2.Count; cnt2++)
                       {
                           if (gl._dhl[DihLt[cntf], DihLTt[cntf] ? 3 : 0] == gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 3 : 0])//七員環
                           {
                               ringt = new List<int>();
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 0 : 3]);
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 1 : 2]);
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 2 : 1]);
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 3 : 0]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 2 : 1]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 1 : 2]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 0 : 3]);
                           }
                           else if (gl._dhl[DihLt[cntf], DihLTt[cntf] ? 3 : 0] == gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 2 : 1] && gl._dhl[DihLt[cntf], DihLTt[cntf] ? 2 : 1] == gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 3 : 0])//六員環
                           {
                               ringt = new List<int>();
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 0 : 3]);
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 1 : 2]);
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 2 : 1]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 2 : 1]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 1 : 2]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 0 : 3]);
                           }
                           else if (gl._dhl[DihLt[cntf], DihLTt[cntf] ? 2 : 1] == gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 2 : 1] && gl._dhl[DihLt[cntf], DihLTt[cntf] ? 3 : 0] == gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 1 : 2] && gl._dhl[DihLt[cntf], DihLTt[cntf] ? 1 : 2] == gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 3 : 0])//五員環
                           {
                               ringt = new List<int>();
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 0 : 3]);
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 1 : 2]);
                               ringt.Add(gl._dhl[DihLt[cntf], DihLTt[cntf] ? 2 : 1]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 1 : 2]);
                               ringt.Add(gl._dhl[DihLt2[cnt2], DihLTt2[cnt2] ? 0 : 3]);
                           }
                       }
                       if (ringt.Count >= 5 && ringt.Count <= 7)
                       {
                           lock (lo) CFRt.Add(ringt.ToArray());
                       }
                   });
            }
            foreach (int[] cfr in CFRt)
            {
                bool flg = false;
                Parallel.For(0, cfr.Length, po, (cnt2) =>
                {
                    int cnt3, itemp5;
                    itemp5 = 0;
                    if (gl._als[cfr[cnt2]] != 6) return;
                    for (cnt3 = 0; cnt3 < gl._rdd.Length; cnt3++)
                    {
                        if (gl._rdl[cnt3, 0] == cfr[cnt2] || gl._rdl[cnt3, 1] == cfr[cnt2]) itemp5++;
                    }
                    if (gl._als[cfr[cnt2]] == 6 && itemp5 > 3) flg = true;
                });//sp3炭素の無いようにチェック
                if (!flg)
                {
                    Parallel.ForEach(CoFuRi, po, (cfr2) =>
                    {
                        if (cfr.Length != cfr2.Length) return;
                        bool flg2, flg3 = false;
                        foreach (int ind in cfr)
                        {
                            flg2 = false;
                            foreach (int ind2 in cfr2)
                            {
                                if (ind == ind2)
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2)
                            {
                                flg3 = true;
                                break;
                            }
                        }
                        if (!flg3)
                        {
                            lock (lo) flg = true;
                        }
                    });//既に登録した環かどうかをチェック
                    if (!flg)
                    {
                        CoFuRi.Add(cfr);
                        CoFuRiSrch(ref CoFuRi, in cfr, ref po);
                    }
                }
            }
        }
        private void Sub3Srch(ref List<int> sub3, int BsA, ref ParallelOptions po)//3位置換基を探す(幅優先)、初期sub3は{C2,C3,C4,C5,C6}
        {
            ConcurrentBag<int> cb = new ConcurrentBag<int>();
            int l = sub3.Count;
            List<int> sub3l = sub3;
            Parallel.For(0, gl._rdd.Length, po, (cnt) =>
            {
                int ind = -1;
                if (gl._rdl[cnt, 0] == BsA)
                {
                    ind = gl._rdl[cnt, 1];
                }
                else if (gl._rdl[cnt, 1] == BsA)
                {
                    ind = gl._rdl[cnt, 0];
                }
                if (ind == -1) return;
                bool flg = false;
                for (int cnt2 = 0; cnt2 < l; cnt2++)
                {
                    if (sub3l[cnt2] == ind) flg = true;
                }
                if (!flg) sub3l.Add(ind);
            });//BsAに繋いでいる原子を探す。C4じゃなければSub3に入れる
            sub3 = sub3l;
            for (int cnt = l; cnt < sub3.Count; cnt++)
            {
                Sub3Srch(ref sub3, sub3[cnt], ref po);
            }
        }
        private void DescC()//共通記述子
        {
            ParallelOptions po = new ParallelOptions();
            CancellationTokenSource cts = new CancellationTokenSource();
            CancellationToken ct = cts.Token;
            po.CancellationToken = ct;
            po.MaxDegreeOfParallelism = CommonParam.thdn;
            po.TaskScheduler = TaskScheduler.Default;
            object lo = new object();
            object lo2 = new object();
            Ri123456H = new int[6] { -1, -1, -1, -1, -1, -1 };
            R123456H = new double[6];
            Ri123456L = new int[6] { -1, -1, -1, -1, -1, -1 };
            R123456L = new double[6];
            RiC2O = new int[2] { -1, -1 };
            RC2O = new double[2];
            List<int> RiCFRLH = new List<int>();//縮合共役環式構造High結合長インデックス一時リスト
            List<int> RiCFRLL = new List<int>();//縮合共役環式構造Low結合長インデックス一時リスト
            Parallel.For(0, gl._rdd.Length, po, (cnt) =>
            {
                bool flg = false;
                foreach (int ind in CoFuRiH)//縮合共役環式構造High結合長インデックスを探す
                {
                    if (gl._rdl[cnt, 0] == ind)
                    {
                        foreach (int ind2 in CoFuRiH)
                        {
                            if (gl._rdl[cnt, 1] == ind2)
                            {
                                lock (lo) RiCFRLH.Add(cnt);
                                flg = true;
                                break;
                            }
                        }
                    }
                    else if (gl._rdl[cnt, 1] == ind)
                    {
                        foreach (int ind2 in CoFuRiH)
                        {
                            if (gl._rdl[cnt, 0] == ind2)
                            {
                                lock (lo) RiCFRLH.Add(cnt);
                                flg = true;
                                break;
                            }
                        }
                    }
                    if (flg) break;
                }
                flg = false;
                foreach (int ind in CoFuRiL)//縮合共役環式構造Low結合長インデックスを探す
                {
                    if (gl._rdl[cnt, 0] == ind)
                    {
                        foreach (int ind2 in CoFuRiL)
                        {
                            if (gl._rdl[cnt, 1] == ind2)
                            {
                                lock (lo2) RiCFRLL.Add(cnt);
                                flg = true;
                                break;
                            }
                        }
                    }
                    else if (gl._rdl[cnt, 1] == ind)
                    {
                        foreach (int ind2 in CoFuRiL)
                        {
                            if (gl._rdl[cnt, 0] == ind2)
                            {
                                lock (lo2) RiCFRLL.Add(cnt);
                                flg = true;
                                break;
                            }
                        }
                    }
                    if (flg) break;
                }
                if ((gl._rdl[cnt, 0] == CoC1[0] && gl._rdl[cnt, 1] == CoC2[0]) || (gl._rdl[cnt, 1] == CoC1[0] && gl._rdl[cnt, 0] == CoC2[0])) lock (Ri123456H.SyncRoot) Ri123456H[0] = cnt;//コアHigh結合長インデックスを探す
                else if ((gl._rdl[cnt, 0] == CoC3[0] && gl._rdl[cnt, 1] == CoC2[0]) || (gl._rdl[cnt, 1] == CoC3[0] && gl._rdl[cnt, 0] == CoC2[0])) lock (Ri123456H.SyncRoot) Ri123456H[1] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC3[0] && gl._rdl[cnt, 1] == CoC4[0]) || (gl._rdl[cnt, 1] == CoC3[0] && gl._rdl[cnt, 0] == CoC4[0])) lock (Ri123456H.SyncRoot) Ri123456H[2] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC5[0] && gl._rdl[cnt, 1] == CoC4[0]) || (gl._rdl[cnt, 1] == CoC5[0] && gl._rdl[cnt, 0] == CoC4[0])) lock (Ri123456H.SyncRoot) Ri123456H[3] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC5[0] && gl._rdl[cnt, 1] == CoC6[0]) || (gl._rdl[cnt, 1] == CoC5[0] && gl._rdl[cnt, 0] == CoC6[0])) lock (Ri123456H.SyncRoot) Ri123456H[4] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC1[0] && gl._rdl[cnt, 1] == CoC6[0]) || (gl._rdl[cnt, 1] == CoC1[0] && gl._rdl[cnt, 0] == CoC6[0])) lock (Ri123456H.SyncRoot) Ri123456H[5] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC1[1] && gl._rdl[cnt, 1] == CoC2[1]) || (gl._rdl[cnt, 1] == CoC1[1] && gl._rdl[cnt, 0] == CoC2[1])) lock (Ri123456L.SyncRoot) Ri123456L[0] = cnt;//コアLow結合長インデックスを探す
                else if ((gl._rdl[cnt, 0] == CoC3[1] && gl._rdl[cnt, 1] == CoC2[1]) || (gl._rdl[cnt, 1] == CoC3[1] && gl._rdl[cnt, 0] == CoC2[1])) lock (Ri123456L.SyncRoot) Ri123456L[1] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC3[1] && gl._rdl[cnt, 1] == CoC4[1]) || (gl._rdl[cnt, 1] == CoC3[1] && gl._rdl[cnt, 0] == CoC4[1])) lock (Ri123456L.SyncRoot) Ri123456L[2] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC5[1] && gl._rdl[cnt, 1] == CoC4[1]) || (gl._rdl[cnt, 1] == CoC5[1] && gl._rdl[cnt, 0] == CoC4[1])) lock (Ri123456L.SyncRoot) Ri123456L[3] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC5[1] && gl._rdl[cnt, 1] == CoC6[1]) || (gl._rdl[cnt, 1] == CoC5[1] && gl._rdl[cnt, 0] == CoC6[1])) lock (Ri123456L.SyncRoot) Ri123456L[4] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC1[1] && gl._rdl[cnt, 1] == CoC6[1]) || (gl._rdl[cnt, 1] == CoC1[1] && gl._rdl[cnt, 0] == CoC6[1])) lock (Ri123456L.SyncRoot) Ri123456L[5] = cnt;
                else if ((gl._rdl[cnt, 0] == CoC2[0] && gl._rdl[cnt, 1] == CoO[0]) || (gl._rdl[cnt, 1] == CoC2[0] && gl._rdl[cnt, 0] == CoO[0])) lock (RiC2O.SyncRoot) RiC2O[0] = cnt;//コアC2-O High結合長インデックスを探す
                else if ((gl._rdl[cnt, 0] == CoC2[1] && gl._rdl[cnt, 1] == CoO[1]) || (gl._rdl[cnt, 1] == CoC2[1] && gl._rdl[cnt, 0] == CoO[1])) lock (RiC2O.SyncRoot) RiC2O[1] = cnt;//コアC2-O Low結合長インデックスを探す
                else if ((gl._rdl[cnt, 0] == CoC1[0] && gl._rdl[cnt, 1] == CoC1[1]) || (gl._rdl[cnt, 1] == CoC1[0] && gl._rdl[cnt, 0] == CoC1[1])) RiC11 = cnt;
            });
            if (RiCFRLH.Count < 6 || RiCFRLL.Count < 6) throw new ArgumentOutOfRangeException("RiCFRLH/RiCFRLL", "DescC : Bond number in CFR is lower than 6.");
            RiCFRH = RiCFRLH.ToArray();
            RCFRH = new double[RiCFRH.Length];
            RiCFRL = RiCFRLL.ToArray();
            RCFRL = new double[RiCFRL.Length];
            RiCFRLH = null;
            RiCFRLL = null;
            int cnt = 0;
            for (cnt = 0; cnt < 6; cnt++)
            {
                if (Ri123456H[cnt] == -1) throw new ArgumentOutOfRangeException(String.Format("Ri123456H[{0}]", cnt), "DescC : Can not find radius.");
                R123456H[cnt] = gl._rdd[Ri123456H[cnt]];
                if (Ri123456L[cnt] == -1) throw new ArgumentOutOfRangeException(String.Format("Ri123456L[{0}]", cnt), "DescC : Can not find radius.");
                R123456L[cnt] = gl._rdd[Ri123456L[cnt]];
            }
            for (cnt = 0; cnt < RCFRH.Length; cnt++)
            {
                RCFRH[cnt] = gl._rdd[RiCFRH[cnt]];
            }
            for (cnt = 0; cnt < RCFRL.Length; cnt++)
            {
                RCFRL[cnt] = gl._rdd[RiCFRL[cnt]];
            }
            if (RiC2O[0] == -1 || RiC2O[1] == -1) throw new ArgumentOutOfRangeException("RiC2O", "DescC : Can not find radius.");
            RC2O[0] = gl._rdd[RiC2O[0]];
            RC2O[1] = gl._rdd[RiC2O[1]];
            RC11 = gl._rdd[RiC11];
            //Console.WriteLine("KO : R12H=[{0}]{1}\tR12L=[{2}]{3}\r\nRCFRH={4}\tRCFRL={5}\r\nRC2O[0]={6}\tRC2O[1]={7}\r\nRC11={8}", Ri123456H[0], R123456H[0], Ri123456L[0], R123456L[0], RCFRH.Length, RCFRL.Length, RC2O[0], RC2O[1], RC11);//debug用
            Ravg123456H = 0;
            foreach (double dtemp in R123456H)
            {
                Ravg123456H += dtemp;
            }
            Ravg123456H /= 6;
            Ravg123456L = 0;
            foreach (double dtemp in R123456L)
            {
                Ravg123456L += dtemp;
            }
            Ravg123456L /= 6;
            RavgCPh = (Ravg123456H + Ravg123456L) / 2;
            RavgCFRH = 0;
            foreach (double dtemp in RCFRH)
            {
                RavgCFRH += dtemp;
            }
            RavgCFRL = 0;
            foreach (double dtemp in RCFRL)
            {
                RavgCFRL += dtemp;
            }
            RavgCFR = (RavgCFRH + RavgCFRL) / (RCFRH.Length + RCFRL.Length);
            RavgCFRH /= RCFRH.Length;
            RavgCFRL /= RCFRL.Length;
            RavgC2O = (RC2O[0] + RC2O[1]) / 2;
            //Console.WriteLine("SU : Ravg123456H={0}\tRavg123456L={1}\tRavgCPh={2}\r\nRavgCFRH={3}\tRavgCFRL={4}\tRavgCFR={5}\r\nRavgC2O={6}", Ravg123456H, Ravg123456L, RavgCPh, RavgCFRH, RavgCFRL, RavgCFR, RavgC2O);//debug用
            int[] CoPhH = new int[6] { CoC1[0], CoC2[0], CoC3[0], CoC4[0], CoC5[0], CoC6[0] };//コアPh Highインデックス
            int[] CoPhL = new int[6] { CoC1[1], CoC2[1], CoC3[1], CoC4[1], CoC5[1], CoC6[1] };//コアPh Lowインデックス
            List<int> AiCPhHL = new List<int>();//コアPh High結合角一時リスト
            List<int> AiCPhLL = new List<int>();//コアPh Low結合角一時リスト
            List<int> AiCFRHL = new List<int>();//縮合共役環式構造High結合角インデックス一時リスト
            List<int> AiCFRLL = new List<int>();//縮合共役環式構造Low結合角インデックス一時リスト
            Aico = new int[2] { -1, -1 };
            object lo3 = new object();
            Parallel.For(0, gl._agd.Length, po, (cnt2) =>
            {
                foreach (int ind in CoFuRiH)//縮合共役環式構造Highにある原子が中心の結合角を探す
                {
                    if (gl._agl[cnt2, 1] == ind)
                    {
                        lock (lo) AiCFRHL.Add(cnt2);
                        break;
                    }
                }
                foreach (int ind in CoFuRiL)//縮合共役環式構造Lowにある原子が中心の結合角を探す
                {
                    if (gl._agl[cnt2, 1] == ind)
                    {
                        lock (lo2) AiCFRLL.Add(cnt2);
                        break;
                    }
                }
                foreach (int ind in CoPhH)//コアPh Highにある原子が中心の結合角を探す
                {
                    if (gl._agl[cnt2, 1] == ind)
                    {
                        lock (lo3) AiCPhHL.Add(cnt2);
                        break;
                    }
                }
                foreach (int ind in CoPhL)//コアPh Lowにある原子が中心の結合角を探す
                {
                    if (gl._agl[cnt2, 1] == ind)
                    {
                        lock (lo3) AiCPhLL.Add(cnt2);
                        break;
                    }
                }
                if (gl._agl[cnt2, 1] == CoO[0]) Aico[0] = cnt2;//コアO Highが中心の結合角を探す
                else if (gl._agl[cnt2, 1] == CoO[1]) Aico[1] = cnt2;//コアO Lowが中心の結合角を探す
            });
            if (AiCPhHL.Count != 18 || AiCPhLL.Count != 18) throw new ArgumentOutOfRangeException("AiCPhHL/AiCPhLL", "DescC : Bond angle number of core Ph is not 18.");
            AiCPhH = AiCPhHL.ToArray();
            AiCPhL = AiCPhLL.ToArray();
            AiCFRH = AiCFRHL.ToArray();
            AiCFRL = AiCFRLL.ToArray();
            AiCPhHL = null;
            AiCPhLL = null;
            AiCFRHL = null;
            AiCFRLL = null;
            ACPhH = new double[AiCPhH.Length];
            ACPhL = new double[AiCPhL.Length];
            ACFRH = new double[AiCFRH.Length];
            ACFRL = new double[AiCFRL.Length];
            Aiko = new double[2];
            for (cnt = 0; cnt < ACPhH.Length; cnt++)
            {
                ACPhH[cnt] = gl._agd[AiCPhH[cnt]];
                ACPhL[cnt] = gl._agd[AiCPhL[cnt]];
            }
            for (cnt = 0; cnt < ACFRH.Length; cnt++)
            {
                ACFRH[cnt] = gl._agd[AiCFRH[cnt]];
            }
            for (cnt = 0; cnt < ACFRL.Length; cnt++)
            {
                ACFRL[cnt] = gl._agd[AiCFRL[cnt]];
            }
            if (Aico[0] == -1 || Aico[1] == -1) throw new ArgumentOutOfRangeException("Aicoちゃん", "DescC : Can not find angel.");
            Aiko[0] = gl._agd[Aico[0]];
            Aiko[1] = gl._agd[Aico[1]];
            //Console.WriteLine("I : ACPhH[0]={0}\tACPhL[0]={1}\r\nACFRH={2}\tACFRH[0]={3}\r\nACFRL={4}\tACFRL[0]={5}\r\nAiko[0]={6}\tAiko[1]={7}", ACPhH[0], ACPhL[0], ACFRH.Length, ACFRH[0], ACFRL.Length, ACFRL[0], Aiko[0], Aiko[1]);//debug用
            cosACPhH = 0;
            cos2ACPhH = 0;
            sinACPhHa = 0;
            sin2ACPhH = 0;
            double dtemp2;
            double dtemp3;
            double dtemp4;
            foreach (double dtemp in ACPhH)
            {
                dtemp2 = (dtemp - 120) / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosACPhH += dtemp3;
                cos2ACPhH += Math.Pow(dtemp3, 2);
                sinACPhHa += Math.Abs(dtemp4);
                sin2ACPhH += Math.Pow(dtemp4, 2);
            }
            cosACPhL = 0;
            cos2ACPhL = 0;
            sinACPhLa = 0;
            sin2ACPhL = 0;
            foreach (double dtemp in ACPhL)
            {
                dtemp2 = (dtemp - 120) / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosACPhL += dtemp3;
                cos2ACPhL += Math.Pow(dtemp3, 2);
                sinACPhLa += Math.Abs(dtemp4);
                sin2ACPhL += Math.Pow(dtemp4, 2);
            }
            cosACFRH = 0;
            cos2ACFRH = 0;
            sinACFRHa = 0;
            sin2ACFRH = 0;
            foreach (double dtemp in ACFRH)
            {
                dtemp2 = (dtemp - 120) / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosACFRH += dtemp3;
                cos2ACFRH += Math.Pow(dtemp3, 2);
                sinACFRHa += Math.Abs(dtemp4);
                sin2ACFRH += Math.Pow(dtemp4, 2);
            }
            cosACFRL = 0;
            cos2ACFRL = 0;
            sinACFRLa = 0;
            sin2ACFRL = 0;
            foreach (double dtemp in ACFRL)
            {
                dtemp2 = (dtemp - 120) / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosACFRL += dtemp3;
                cos2ACFRL += Math.Pow(dtemp3, 2);
                sinACFRLa += Math.Abs(dtemp4);
                sin2ACFRL += Math.Pow(dtemp4, 2);
            }
            AiCOs = new double[2];
            AiCOs2 = new double[2];
            AicOS = new double[2];
            AicOS2 = new double[2];
            for (cnt = 0; cnt < 2; cnt++)
            {
                dtemp2 = Aiko[cnt] / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                AiCOs[cnt] = dtemp3;
                AiCOs2[cnt] = Math.Pow(dtemp3, 2);
                AicOS[cnt] = Math.Abs(dtemp4);
                AicOS2[cnt] = Math.Pow(dtemp4, 2);
            }
            cosACPh = cosACPhH + cosACPhL;
            cos2ACPh = cos2ACPhH + cos2ACPhL;
            sinACPha = sinACPhHa + sinACPhLa;
            sin2ACPh = sin2ACPhH + sin2ACPhL;
            cosACFR = cosACFRH + cosACFRL;
            cos2ACFR = cos2ACFRH + cos2ACFRL;
            sinACFRa = sinACFRHa + sinACFRLa;
            sin2ACFR = sin2ACFRH + sin2ACFRL;
            AiKOs = AiCOs[0] + AiCOs[1];
            AiKOs2 = AiCOs2[0] + AiCOs2[1];
            AikOS = AicOS[0] + AicOS[1];
            AikOS2 = AicOS2[0] + AicOS2[1];
            //Console.WriteLine("E : cos2ACPh={0}\tsin2ACPh={1}\r\ncos2ACFR={2}\tsin2ACFR={3}\r\nAiKOs2={4}\tAikoS2={5}", cos2ACPh, sin2ACPh, cos2ACFR, sin2ACFR, AiKOs2, AikOS2);//debug用
            List<int> DiCPhHL = new List<int>();
            List<int> DiCPhLL = new List<int>();
            List<int> DiCFRHL = new List<int>();
            List<int> DiCFRLL = new List<int>();
            Parallel.For(0, gl._dhd.Length, po, (cnt2) =>
            {
                bool flg = false;
                foreach (int ind in CoPhH)//コアPh Highにある原子が中心の二面角を探す
                {
                    if (gl._dhl[cnt2, 1] == ind)
                    {
                        foreach (int ind2 in CoPhH)
                        {
                            if (gl._dhl[cnt2, 2] == ind2)
                            {
                                lock (lo) DiCPhHL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    else if (gl._dhl[cnt2, 2] == ind)
                    {
                        foreach (int ind2 in CoPhH)
                        {
                            if (gl._dhl[cnt2, 1] == ind2)
                            {
                                lock (lo) DiCPhHL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    if (flg) break;
                }
                flg = false;
                foreach (int ind in CoPhL)//コアPh Lowにある原子が中心の二面角を探す
                {
                    if (gl._dhl[cnt2, 1] == ind)
                    {
                        foreach (int ind2 in CoPhL)
                        {
                            if (gl._dhl[cnt2, 2] == ind2)
                            {
                                lock (lo) DiCPhLL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    else if (gl._dhl[cnt2, 2] == ind)
                    {
                        foreach (int ind2 in CoPhL)
                        {
                            if (gl._dhl[cnt2, 1] == ind2)
                            {
                                lock (lo) DiCPhLL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    if (flg) break;
                }
                flg = false;
                foreach (int ind in CoFuRiH)//縮合共役環式構造Highにある原子が中心の二面角を探す
                {
                    if (gl._dhl[cnt2, 1] == ind)
                    {
                        foreach (int ind2 in CoFuRiH)
                        {
                            if (gl._dhl[cnt2, 2] == ind2)
                            {
                                lock (lo2) DiCFRHL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    else if (gl._dhl[cnt2, 2] == ind)
                    {
                        foreach (int ind2 in CoFuRiH)
                        {
                            if (gl._dhl[cnt2, 1] == ind2)
                            {
                                lock (lo2) DiCFRHL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    if (flg) break;
                }
                flg = false;
                foreach (int ind in CoFuRiL)//縮合共役環式構造Lowにある原子が中心の二面角を探す
                {
                    if (gl._dhl[cnt2, 1] == ind)
                    {
                        foreach (int ind2 in CoFuRiL)
                        {
                            if (gl._dhl[cnt2, 2] == ind2)
                            {
                                lock (lo3) DiCFRLL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    else if (gl._dhl[cnt2, 2] == ind)
                    {
                        foreach (int ind2 in CoFuRiL)
                        {
                            if (gl._dhl[cnt2, 1] == ind2)
                            {
                                lock (lo3) DiCFRLL.Add(cnt2);
                                flg = true;
                                break;
                            }
                        }
                    }
                    if (flg) break;
                }
            });
            if (DiCPhHL.Count != 24 || DiCPhLL.Count != 24) throw new ArgumentOutOfRangeException("DiCPhHL/DiCPhLL", "DescC : Dihedral angle number of core Ph is not 24.");
            DiCPhH = DiCPhHL.ToArray();
            DiCPhL = DiCPhLL.ToArray();
            DiCFRH = DiCFRHL.ToArray();
            DiCFRL = DiCFRLL.ToArray();
            DCPhH = new double[DiCPhH.Length];
            DCPhL = new double[DiCPhL.Length];
            DCFRH = new double[DiCFRH.Length];
            DCFRL = new double[DiCFRL.Length];
            DiCPhHL = null;
            DiCPhLL = null;
            DiCFRHL = null;
            DiCFRLL = null;
            for (cnt = 0; cnt < DCPhH.Length; cnt++)
            {
                DCPhH[cnt] = gl._dhd[DiCPhH[cnt]];
                DCPhL[cnt] = gl._dhd[DiCPhL[cnt]];
            }
            for (cnt = 0; cnt < DCFRH.Length; cnt++)
            {
                DCFRH[cnt] = gl._dhd[DiCFRH[cnt]];
            }
            for (cnt = 0; cnt < DCFRL.Length; cnt++)
            {
                DCFRL[cnt] = gl._dhd[DiCFRL[cnt]];
            }
            //Console.WriteLine("KO : DCPhH[0]={0}\tDCPhL[0]={1}\r\nDCFRH={2}\tDCFRH[0]={3}\r\nDCFRL={4}\tDCFRL[0]={5}", DCPhH[0], DCPhL[0], DCFRH.Length, DCFRH.Length, DCFRL.Length, DCFRL[0]);//debug用
            cosDCPhHa = 0;
            cos2DCPhH = 0;
            sinDCPhHa = 0;
            sin2DCPhH = 0;
            foreach (double dtemp in DCPhH)
            {
                dtemp2 = dtemp / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosDCPhHa += Math.Abs(dtemp3);
                cos2DCPhH += Math.Pow(dtemp3, 2);
                sinDCPhHa += Math.Abs(dtemp4);
                sin2DCPhH += Math.Pow(dtemp4, 2);
            }
            cosDCPhLa = 0;
            cos2DCPhL = 0;
            sinDCPhLa = 0;
            sin2DCPhL = 0;
            foreach (double dtemp in DCPhL)
            {
                dtemp2 = dtemp / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosDCPhLa += Math.Abs(dtemp3);
                cos2DCPhL += Math.Pow(dtemp3, 2);
                sinDCPhLa += Math.Abs(dtemp4);
                sin2DCPhL += Math.Pow(dtemp4, 2);
            }
            cosDCFRHa = 0;
            cos2DCFRH = 0;
            sinDCFRHa = 0;
            sin2DCFRH = 0;
            foreach (double dtemp in DCFRH)
            {
                dtemp2 = dtemp / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosDCFRHa += Math.Abs(dtemp3);
                cos2DCFRH += Math.Pow(dtemp3, 2);
                sinDCFRHa += Math.Abs(dtemp4);
                sin2DCFRH += Math.Pow(dtemp4, 2);
            }
            cosDCFRLa = 0;
            cos2DCFRL = 0;
            sinDCFRLa = 0;
            sin2DCFRL = 0;
            foreach (double dtemp in DCFRL)
            {
                dtemp2 = dtemp / 180 * Math.PI;
                dtemp3 = Math.Cos(dtemp2);
                dtemp4 = Math.Sin(dtemp2);
                cosDCFRLa += Math.Abs(dtemp3);
                cos2DCFRL += Math.Pow(dtemp3, 2);
                sinDCFRLa += Math.Abs(dtemp4);
                sin2DCFRL += Math.Pow(dtemp4, 2);
            }
            cosDCPha = cosDCPhHa + cosDCPhLa;
            cos2DCPh = cos2DCPhH + cos2DCPhL;
            sinDCPha = sinDCPhHa + sinDCPhLa;
            sin2DCPh = sin2DCPhH + sin2DCPhL;
            cosDCFRa = cosDCFRHa + cosDCFRLa;
            cos2DCFR = cos2DCFRH + cos2DCFRL;
            sinDCFRa = sinDCFRHa + sinDCFRLa;
            sin2DCFR = sin2DCFRH + sin2DCFRL;
            //Console.WriteLine("SU : cosDCPha={0}\tcos2DCPh={1}\tsinDCPha={2}\tsin2DCPh={3}\r\ncosDCFRa={4}\tcos2DCFR={5}\tsinDCFRa={6}\tsin2DCFR={7}", cosDCPha, cos2DCPh, sinDCPha, sin2DCPh, cosDCFRa, cos2DCFR, sinDCFRa, sin2DCFR);//debug用
            Di11s = new int[4] { -1, -1, -1, -1 };
            for (cnt = 0; cnt < gl._dhd.Length; cnt++)//BINOL二面角を探す
            {
                if ((gl._dhl[cnt, 0] == CoC2[0] && gl._dhl[cnt, 1] == CoC1[0] && gl._dhl[cnt, 2] == CoC1[1] && gl._dhl[cnt, 3] == CoC2[1]) || (gl._dhl[cnt, 0] == CoC2[1] && gl._dhl[cnt, 1] == CoC1[1] && gl._dhl[cnt, 2] == CoC1[0] && gl._dhl[cnt, 3] == CoC2[0]))//C2-C1-C1'-C2'二面角を探す
                {
                    Di11s[0] = cnt;
                }
                else if ((gl._dhl[cnt, 0] == CoC6[0] && gl._dhl[cnt, 1] == CoC1[0] && gl._dhl[cnt, 2] == CoC1[1] && gl._dhl[cnt, 3] == CoC6[1]) || (gl._dhl[cnt, 0] == CoC6[1] && gl._dhl[cnt, 1] == CoC1[1] && gl._dhl[cnt, 2] == CoC1[0] && gl._dhl[cnt, 3] == CoC6[0]))//C6-C1-C1'-C6'二面角を探す
                {
                    Di11s[1] = cnt;
                }
                else if ((gl._dhl[cnt, 0] == CoC2[0] && gl._dhl[cnt, 1] == CoC1[0] && gl._dhl[cnt, 2] == CoC1[1] && gl._dhl[cnt, 3] == CoC6[1]) || (gl._dhl[cnt, 0] == CoC6[1] && gl._dhl[cnt, 1] == CoC1[1] && gl._dhl[cnt, 2] == CoC1[0] && gl._dhl[cnt, 3] == CoC2[0]))//C2-C1-C1'-C6'二面角を探す
                {
                    Di11s[2] = cnt;
                }
                else if ((gl._dhl[cnt, 0] == CoC6[0] && gl._dhl[cnt, 1] == CoC1[0] && gl._dhl[cnt, 2] == CoC1[1] && gl._dhl[cnt, 3] == CoC2[1]) || (gl._dhl[cnt, 0] == CoC2[1] && gl._dhl[cnt, 1] == CoC1[1] && gl._dhl[cnt, 2] == CoC1[0] && gl._dhl[cnt, 3] == CoC6[0]))//C6-C1-C1'-C6'二面角を探す
                {
                    Di11s[3] = cnt;
                }
            }
            D11s = new double[4];
            for (cnt = 0; cnt < 4; cnt++)
            {
                if (Di11s[cnt] == -1) throw new ArgumentOutOfRangeException("Di11s", "DescC : Can not find BINOL dihedral angles.");
                D11s[cnt] = gl._dhd[Di11s[cnt]];
            }
            D11a = (360 + Math.Abs(D11s[0]) + Math.Abs(D11s[1]) - Math.Abs(D11s[2]) - Math.Abs(D11s[3])) / 4;
            cosD11a = Math.Cos(D11a);
            //Console.WriteLine("A : Di11s[0]=[{0}]{1}\tDi11s[1]=[{2}]{3}\r\nDi11s[2]=[{4}]{5}\tDi11s[3]=[{6}]{7}\r\nD11a={8}\tcosD11a={9}", Di11s[0], D11s[0], Di11s[1], D11s[1], Di11s[2], D11s[2], Di11s[3], D11s[3], D11a, cosD11a);//debug用
            rcds = new double[3];
            rcds[0] = 1 / gl._rc[0];
            rcds[1] = 1 / gl._rc[1];
            rcds[2] = 1 / gl._rc[2];
            rcI = rcds[0] + rcds[1] + rcds[2];
            rcH = gl._rc[0] + gl._rc[1] + gl._rc[2];
            OvIm = new double[gl._bfn, gl._bfn];
            for (cnt = 0; cnt < gl._bfn; cnt++)
            {
                for (int itemp = 0; itemp < gl._bfn; itemp++)
                {
                    if (gl._mpam[cnt, itemp] == 0) OvIm[cnt, itemp] = 0;
                    else if (gl._dnsm[cnt, itemp] == 0) OvIm[cnt, itemp] = 1;
                    else OvIm[cnt, itemp] = gl._mpam[cnt, itemp] / gl._dnsm[cnt, itemp];
                    if (OvIm[cnt, itemp] > 1) OvIm[cnt, itemp] = 1;
                    if (OvIm[cnt, itemp] < -1) OvIm[cnt, itemp] = -1;
                }
            }
            CPhhmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CPhlmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CPhshmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CPhslmLAB = new double[3] { 0.0, 0.0, 0.0 };
            int[] CoPhta = new int[12] { CoC1[0], CoC1[1], CoC2[0], CoC2[1], CoC3[0], CoC3[1], CoC4[0], CoC4[1], CoC5[0], CoC5[1], CoC6[0], CoC6[1] };
            Parallel.ForEach(CoPhta, po, (ind) =>
            {
                double sum = 0, sum2 = 0, sum3 = 0, sum4 = 0;//局在/同相
                int cnt2, cnt3;
                for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)//局在電子を加算する
                {
                    for (cnt3 = cnt2; cnt3 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt3++)
                    {
                        sum += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                        sum2 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                        sum3 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                        sum4 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                    }
                }
                lock (CPhhmLAB.SyncRoot) CPhhmLAB[0] += sum;
                lock (CPhlmLAB.SyncRoot) CPhlmLAB[0] += sum2;
                lock (CPhshmLAB.SyncRoot) CPhshmLAB[0] += sum3;
                lock (CPhslmLAB.SyncRoot) CPhslmLAB[0] += sum4;
                sum = 0;
                sum2 = 0;
                sum3 = 0;
                sum4 = 0;
                double sum5 = 0, sum6 = 0, sum7 = 0, sum8 = 0;//異相
                foreach (int ind2 in CoPhta)//同相/異相電子を加算する
                {
                    if (ind == ind2) continue;
                    for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)
                    {
                        for (cnt3 = gl._aobl[ind2]; cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]); cnt3++)
                        {
                            if (Math.Sign(gl._mocm[cnt2, gl._hmei]) == Math.Sign(gl._mocm[cnt3, gl._hmei])) sum += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            else sum5 += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._lmei]) == Math.Sign(gl._mocm[cnt3, gl._lmei])) sum2 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            else sum6 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._shmei]) == Math.Sign(gl._mocm[cnt3, gl._shmei])) sum3 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            else sum7 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._slmei]) == Math.Sign(gl._mocm[cnt3, gl._slmei])) sum4 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                            else sum8 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                        }
                    }
                }
                lock (CPhhmLAB.SyncRoot)
                {
                    CPhhmLAB[1] += sum;
                    CPhhmLAB[2] += sum5;
                }
                lock (CPhlmLAB.SyncRoot)
                {
                    CPhlmLAB[1] += sum2;
                    CPhlmLAB[2] += sum6;
                }
                lock (CPhshmLAB.SyncRoot)
                {
                    CPhshmLAB[1] += sum3;
                    CPhshmLAB[2] += sum7;
                }
                lock (CPhslmLAB.SyncRoot)
                {
                    CPhslmLAB[1] += sum4;
                    CPhslmLAB[2] += sum8;
                }
            });
            List<int> CFRtl = new List<int>(CoFuRiH);
            bool flg;
            foreach (int ind in CoFuRiL)
            {
                flg = false;
                foreach (int ind2 in CFRtl)
                {
                    if (ind == ind2) flg = true;
                }
                if (!flg) CFRtl.Add(ind);
            }
            int[] CFRta = CFRtl.ToArray();
            CFRn = CFRta.Length;
            CFRtl = null;
            CFRhmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CFRlmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CFRshmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CFRslmLAB = new double[3] { 0.0, 0.0, 0.0 };
            Parallel.ForEach(CFRta, po, (ind) =>
            {
                double sum = 0, sum2 = 0, sum3 = 0, sum4 = 0;//局在/同相
                int cnt2, cnt3;
                for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)//局在電子を加算する
                {
                    for (cnt3 = cnt2; cnt3 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt3++)
                    {
                        sum += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                        sum2 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                        sum3 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                        sum4 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                    }
                }
                lock (CFRhmLAB.SyncRoot) CFRhmLAB[0] += sum;
                lock (CFRlmLAB.SyncRoot) CFRlmLAB[0] += sum2;
                lock (CFRshmLAB.SyncRoot) CFRshmLAB[0] += sum3;
                lock (CFRslmLAB.SyncRoot) CFRslmLAB[0] += sum4;
                sum = 0;
                sum2 = 0;
                sum3 = 0;
                sum4 = 0;
                double sum5 = 0, sum6 = 0, sum7 = 0, sum8 = 0;//異相
                foreach (int ind2 in CFRta)//同相/異相電子を加算する
                {
                    if (ind == ind2) continue;
                    for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)
                    {
                        for (cnt3 = gl._aobl[ind2]; cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]); cnt3++)
                        {
                            if (Math.Sign(gl._mocm[cnt2, gl._hmei]) == Math.Sign(gl._mocm[cnt3, gl._hmei])) sum += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            else sum5 += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._lmei]) == Math.Sign(gl._mocm[cnt3, gl._lmei])) sum2 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            else sum6 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._shmei]) == Math.Sign(gl._mocm[cnt3, gl._shmei])) sum3 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            else sum7 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._slmei]) == Math.Sign(gl._mocm[cnt3, gl._slmei])) sum4 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                            else sum8 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                        }
                    }
                }
                lock (CFRhmLAB.SyncRoot)
                {
                    CFRhmLAB[1] += sum;
                    CFRhmLAB[2] += sum5;
                }
                lock (CFRlmLAB.SyncRoot)
                {
                    CFRlmLAB[1] += sum2;
                    CFRlmLAB[2] += sum6;
                }
                lock (CFRshmLAB.SyncRoot)
                {
                    CFRshmLAB[1] += sum3;
                    CFRshmLAB[2] += sum7;
                }
                lock (CFRslmLAB.SyncRoot)
                {
                    CFRslmLAB[1] += sum4;
                    CFRslmLAB[2] += sum8;
                }
            });
            CFROhmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CFROlmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CFROshmLAB = new double[3] { 0.0, 0.0, 0.0 };
            CFROslmLAB = new double[3] { 0.0, 0.0, 0.0 };
            foreach (int ind in CoO)
            {
                int cnt2, cnt3;
                for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)//局在電子を加算する
                {
                    for (cnt3 = cnt2; cnt3 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt3++)
                    {
                        CFROhmLAB[0] += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                        CFROlmLAB[0] += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                        CFROshmLAB[0] += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                        CFROslmLAB[0] += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                    }
                }
                Parallel.ForEach(CFRta, po, (ind2) =>
                {
                    double sum = 0, sum2 = 0, sum3 = 0, sum4 = 0, sum5 = 0, sum6 = 0, sum7 = 0, sum8 = 0;
                    for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)//同相/異相電子を加算する
                    {
                        for (cnt3 = gl._aobl[ind2]; cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]); cnt3++)
                        {
                            if (Math.Sign(gl._mocm[cnt2, gl._hmei]) == Math.Sign(gl._mocm[cnt3, gl._hmei])) sum += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            else sum5 += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._lmei]) == Math.Sign(gl._mocm[cnt3, gl._lmei])) sum2 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            else sum6 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._shmei]) == Math.Sign(gl._mocm[cnt3, gl._shmei])) sum3 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            else sum7 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._slmei]) == Math.Sign(gl._mocm[cnt3, gl._slmei])) sum4 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                            else sum8 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                        }
                    }
                    lock (CFROhmLAB.SyncRoot)
                    {
                        CFROhmLAB[1] += sum;
                        CFROhmLAB[2] += sum5;
                    }
                    lock (CFROlmLAB.SyncRoot)
                    {
                        CFROlmLAB[1] += sum2;
                        CFROlmLAB[2] += sum6;
                    }
                    lock (CFROshmLAB.SyncRoot)
                    {
                        CFROshmLAB[1] += sum3;
                        CFROshmLAB[2] += sum7;
                    }
                    lock (CFROslmLAB.SyncRoot)
                    {
                        CFROslmLAB[1] += sum4;
                        CFROslmLAB[2] += sum8;
                    }
                });
            }
            sub3hmLAB = new double[3] { 0.0, 0.0, 0.0 };
            sub3lmLAB = new double[3] { 0.0, 0.0, 0.0 };
            sub3shmLAB = new double[3] { 0.0, 0.0, 0.0 };
            sub3slmLAB = new double[3] { 0.0, 0.0, 0.0 };
            List<int> sub3tl = new List<int>(sub3H);
            foreach (int ind in sub3L)
            {
                flg = false;
                foreach (int ind2 in sub3tl)
                {
                    if (ind == ind2) flg = true;
                }
                if (!flg) sub3tl.Add(ind);
            }
            int[] sub3ta = sub3tl.ToArray();
            sub3n = sub3ta.Length;
            Parallel.ForEach(sub3ta, po, (ind) =>
            {
                int cnt2, cnt3;
                double sum = 0, sum2 = 0, sum3 = 0, sum4 = 0;//局在/同相
                for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)//局在電子を加算する
                {
                    for (cnt3 = cnt2; cnt3 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt3++)
                    {
                        sum += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                        sum2 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                        sum3 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                        sum4 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                    }
                }
                lock (sub3hmLAB.SyncRoot) sub3hmLAB[0] += sum;
                lock (sub3lmLAB.SyncRoot) sub3lmLAB[0] += sum2;
                lock (sub3shmLAB.SyncRoot) sub3shmLAB[0] += sum3;
                lock (sub3slmLAB.SyncRoot) sub3slmLAB[0] += sum4;
                sum = 0;
                sum2 = 0;
                sum3 = 0;
                sum4 = 0;
                double sum5 = 0, sum6 = 0, sum7 = 0, sum8 = 0;//異相
                foreach (int ind2 in sub3ta)//同相/異相電子を加算する
                {
                    if (ind == ind2) continue;
                    for (cnt2 = gl._aobl[ind]; cnt2 < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt2++)
                    {
                        for (cnt3 = gl._aobl[ind2]; cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]); cnt3++)
                        {
                            if (Math.Sign(gl._mocm[cnt2, gl._hmei]) == Math.Sign(gl._mocm[cnt3, gl._hmei])) sum += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            else sum5 += gl._mocm[cnt2, gl._hmei] * gl._mocm[cnt3, gl._hmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._lmei]) == Math.Sign(gl._mocm[cnt3, gl._lmei])) sum2 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            else sum6 += gl._mocm[cnt2, gl._lmei] * gl._mocm[cnt3, gl._lmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._shmei]) == Math.Sign(gl._mocm[cnt3, gl._shmei])) sum3 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            else sum7 += gl._mocm[cnt2, gl._shmei] * gl._mocm[cnt3, gl._shmei] * OvIm[cnt2, cnt3];
                            if (Math.Sign(gl._mocm[cnt2, gl._slmei]) == Math.Sign(gl._mocm[cnt3, gl._slmei])) sum4 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                            else sum8 += gl._mocm[cnt2, gl._slmei] * gl._mocm[cnt3, gl._slmei] * OvIm[cnt2, cnt3];
                        }
                    }
                }
                lock (sub3hmLAB.SyncRoot)
                {
                    sub3hmLAB[1] += sum;
                    sub3hmLAB[2] += sum5;
                }
                lock (sub3lmLAB.SyncRoot)
                {
                    sub3lmLAB[1] += sum2;
                    sub3lmLAB[2] += sum6;
                }
                lock (sub3shmLAB.SyncRoot)
                {
                    sub3shmLAB[1] += sum3;
                    sub3shmLAB[2] += sum7;
                }
                lock (sub3slmLAB.SyncRoot)
                {
                    sub3slmLAB[1] += sum4;
                    sub3slmLAB[2] += sum8;
                }
            });
            //Console.WriteLine("A : CPhhmLAB[0]={0}\tCPhlmLAB[1]={1}\tCPhshmLAB[2]={2}\tCPhslmLAB[0]={3}\r\nCFRhmLAB[0]={4}\tCFRlmLAB[1]={5}\tCFRshmLAB[2]={6}\tCFRslmLAB[0]={7}\r\nCFROhmLAB[0]={8}\tCFROlmLAB[1]={9}\tCFROshmLAB[2]={10}\tCFROslmLAB[0]={11}\r\nsub3hmLAB[0]={12}\tsub3lmLAB[1]={13}\tsub3shmLAB[2]={14}\tsub3slmLAB[0]={15}", CPhhmLAB[0], CPhlmLAB[1], CPhshmLAB[2], CPhslmLAB[0], CFRhmLAB[0], CFRlmLAB[1], CFRshmLAB[2], CFRslmLAB[0], CFROhmLAB[0], CFROlmLAB[1], CFROshmLAB[2], CFROslmLAB[0], sub3hmLAB[0], sub3lmLAB[1], sub3shmLAB[2], sub3slmLAB[0]);//debug用
            BINOLdDF = new double[2] { 0.0, 0.0 };
            for (int cnt2 = 0; cnt2 < gl._bfn; cnt2++)
            {
                for (int cnt3 = 0; cnt3 <= cnt2; cnt3++)
                {
                    if (cnt3 == cnt2)
                    {
                        BINOLdDF[1] += Math.Pow(gl._dnsm[cnt2, cnt3], 2);
                        BINOLdDF[0] += gl._dnsm[cnt2, cnt3];
                    }
                    else
                    {
                        BINOLdDF[1] += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                    }
                }
            }
            BINOLdDF[1] = Math.Sqrt(BINOLdDF[1]);
            CPhdxDFzF = new double[3] { 0.0, 0.0, 0.0 };
            Parallel.ForEach(CoPhta, po, (ind) =>
            {
                int cnt2, cnt3;
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0, sumsuf = 0, dstemp;
                bool flg2;
                for (cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                            foreach (int ind2 in CoPhta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    sumsuf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                                    break;
                                }
                            }
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                dstemp = Math.Pow(gl._dnsm[cnt2, cnt3], 2);
                                sumd += gl._dnsm[cnt2, cnt3];
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                            else
                            {
                                dstemp = Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in CoPhta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (CPhdxDFzF.SyncRoot)
                {
                    CPhdxDFzF[0] += sumd;
                    CPhdxDFzF[1] += sumspf;
                    CPhdxDFzF[2] += sumsuf;
                }
            });
            CPhdxDFzF[1] = Math.Sqrt(CPhdxDFzF[1]);
            CPhdxDFzF[2] = Math.Sqrt(CPhdxDFzF[2]);
            CFRdxDFzF = new double[3] { 0.0, 0.0, 0.0 };
            Parallel.ForEach(CFRta, po, (ind) =>
            {
                int cnt2, cnt3;
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0, sumsuf = 0, dstemp;
                bool flg2;
                for (cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                            foreach (int ind2 in CFRta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    sumsuf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                                    break;
                                }
                            }
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                dstemp = Math.Pow(gl._dnsm[cnt2, cnt3], 2);
                                sumd += gl._dnsm[cnt2, cnt3];
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                            else
                            {
                                dstemp = Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in CFRta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (CFRdxDFzF.SyncRoot)
                {
                    CFRdxDFzF[0] += sumd;
                    CFRdxDFzF[1] += sumspf;
                    CFRdxDFzF[2] += sumsuf;
                }
            });
            CFRdxDFzF[1] = Math.Sqrt(CFRdxDFzF[1]);
            CFRdxDFzF[2] = Math.Sqrt(CFRdxDFzF[2]);
            CoOdxDF = new double[2];
            Parallel.ForEach(CoO, po, (ind) =>
            {
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0;
                bool flg2;
                for (int cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (int cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                sumd += gl._dnsm[cnt2, cnt3];
                                sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2);
                            }
                            else sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in CoO)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (CoOdxDF.SyncRoot)
                {
                    CoOdxDF[0] += sumd;
                    CoOdxDF[1] += sumspf;
                }
            });
            CoOdxDF[1] = Math.Sqrt(CoOdxDF[1]);
            sub3dxDFzF = new double[3] { 0.0, 0.0, 0.0 };
            Parallel.ForEach(sub3ta, po, (ind) =>
            {
                int cnt2, cnt3;
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0, sumsuf = 0, dstemp;
                bool flg2;
                for (cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                            foreach (int ind2 in sub3ta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    sumsuf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                                    break;
                                }
                            }
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                dstemp = Math.Pow(gl._dnsm[cnt2, cnt3], 2);
                                sumd += gl._dnsm[cnt2, cnt3];
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                            else
                            {
                                dstemp = Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in sub3ta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._dnsm[cnt2, cnt3], 2) + Math.Pow(gl._dnsm[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (sub3dxDFzF.SyncRoot)
                {
                    sub3dxDFzF[0] += sumd;
                    sub3dxDFzF[1] += sumspf;
                    sub3dxDFzF[2] += sumsuf;
                }
            });
            sub3dxDFzF[1] = Math.Sqrt(sub3dxDFzF[1]);
            sub3dxDFzF[2] = Math.Sqrt(sub3dxDFzF[2]);
            //Console.WriteLine("I : CPhdxDFzF[0]={0}\tCPhdxDFzF[1]={1}\tCPhdxDFzF[2]={2}\r\nCFRdxDFzF[0]={3}\tCFRdxDFzF[1]={4}\tCFRdxDFzF[2]={5}\r\nCoOdxDF[0]={6}\tCoOdxDF[1]={7}\r\nsub3dxDFzF[0]={8}\tsub3dxDFzF[1]={9}\tsub3dxDFzF[2]={10}", CPhdxDFzF[0], CPhdxDFzF[1], CPhdxDFzF[2], CFRdxDFzF[0], CFRdxDFzF[1], CFRdxDFzF[2], CoOdxDF[0], CoOdxDF[1], sub3dxDFzF[0], sub3dxDFzF[1], sub3dxDFzF[2]);//debug用
            BINOLpDF = new double[2] { 0.0, 0.0 };
            for (int cnt2 = 0; cnt2 < gl._bfn; cnt2++)
            {
                for (int cnt3 = 0; cnt3 <= cnt2; cnt3++)
                {
                    if (cnt3 == cnt2)
                    {
                        BINOLpDF[1] += Math.Pow(gl._mpam[cnt2, cnt3], 2);
                        BINOLpDF[0] += gl._mpam[cnt2, cnt3];
                    }
                    else
                    {
                        BINOLpDF[1] += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                    }
                }
            }
            BINOLpDF[1] = Math.Sqrt(BINOLpDF[1]);
            CPhpxDFzF = new double[3];
            Parallel.ForEach(CoPhta, po, (ind) =>
            {
                int cnt2, cnt3;
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0, sumsuf = 0, dstemp;
                bool flg2;
                for (cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                            foreach (int ind2 in CoPhta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    sumsuf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                                    break;
                                }
                            }
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                dstemp = Math.Pow(gl._mpam[cnt2, cnt3], 2);
                                sumd += gl._mpam[cnt2, cnt3];
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                            else
                            {
                                dstemp = Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in CoPhta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (CPhpxDFzF.SyncRoot)
                {
                    CPhpxDFzF[0] += sumd;
                    CPhpxDFzF[1] += sumspf;
                    CPhpxDFzF[2] += sumsuf;
                }
            });
            CPhpxDFzF[1] = Math.Sqrt(CPhpxDFzF[1]);
            CPhpxDFzF[2] = Math.Sqrt(CPhpxDFzF[2]);
            CFRpxDFzF = new double[3] { 0.0, 0.0, 0.0 };
            Parallel.ForEach(CFRta, po, (ind) =>
            {
                int cnt2, cnt3;
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0, sumsuf = 0, dstemp;
                bool flg2;
                for (cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                            foreach (int ind2 in CFRta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    sumsuf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                                    break;
                                }
                            }
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                dstemp = Math.Pow(gl._mpam[cnt2, cnt3], 2);
                                sumd += gl._mpam[cnt2, cnt3];
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                            else
                            {
                                dstemp = Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in CFRta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (CFRpxDFzF.SyncRoot)
                {
                    CFRpxDFzF[0] += sumd;
                    CFRpxDFzF[1] += sumspf;
                    CFRpxDFzF[2] += sumsuf;
                }
            });
            CFRpxDFzF[1] = Math.Sqrt(CFRpxDFzF[1]);
            CFRpxDFzF[2] = Math.Sqrt(CFRpxDFzF[2]);
            CoOpxDF = new double[2] { 0.0, 0.0 };
            Parallel.ForEach(CoO, po, (ind) =>
            {
                int cnt2, cnt3;
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0;
                bool flg2;
                for (cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                sumd += gl._dnsm[cnt2, cnt3];
                                sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2);
                            }
                            else sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in CoO)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (CoOpxDF.SyncRoot)
                {
                    CoOpxDF[0] += sumd;
                    CoOpxDF[1] += sumspf;
                }
            });
            CoOpxDF[1] = Math.Sqrt(CoOpxDF[1]);
            sub3pxDFzF = new double[3] { 0.0, 0.0, 0.0 };
            Parallel.ForEach(sub3ta, po, (ind) =>
            {
                int cnt2, cnt3;
                int itemp = gl._aobl[ind];
                int itemp2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                double sumd = 0, sumspf = 0, sumsuf = 0, dstemp;
                bool flg2;
                for (cnt2 = itemp; cnt2 < itemp2; cnt2++)
                {
                    for (cnt3 = 0; cnt3 < gl._bfn; cnt3++)
                    {
                        if (cnt3 < itemp)
                        {
                            sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                            foreach (int ind2 in sub3ta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    sumsuf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                                    break;
                                }
                            }
                        }
                        else if (cnt3 <= cnt2)
                        {
                            if (cnt3 == cnt2)
                            {
                                dstemp = Math.Pow(gl._mpam[cnt2, cnt3], 2);
                                sumd += gl._mpam[cnt2, cnt3];
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                            else
                            {
                                dstemp = Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                                sumspf += dstemp;
                                sumsuf += dstemp;
                            }
                        }
                        else if (cnt3 >= itemp2)
                        {
                            flg2 = false;
                            foreach (int ind2 in sub3ta)
                            {
                                if (cnt3 >= gl._aobl[ind2] && cnt3 < ((ind2 == gl._an - 1) ? gl._bfn : gl._aobl[ind2 + 1]))
                                {
                                    flg2 = true;
                                    break;
                                }
                            }
                            if (!flg2) sumspf += Math.Pow(gl._mpam[cnt2, cnt3], 2) + Math.Pow(gl._mpam[cnt3, cnt2], 2);
                        }
                    }
                }
                lock (sub3pxDFzF.SyncRoot)
                {
                    sub3pxDFzF[0] += sumd;
                    sub3pxDFzF[1] += sumspf;
                    sub3pxDFzF[2] += sumsuf;
                }
            });
            sub3pxDFzF[1] = Math.Sqrt(sub3pxDFzF[1]);
            sub3pxDFzF[2] = Math.Sqrt(sub3pxDFzF[2]);
            //Console.WriteLine("A : CPhpxDFzF[0]={0}\tCPhpxDFzF[1]={1}\tCPhpxDFzF[2]={2}\r\nCFRpxDFzF[0]={3}\tCFRpxDFzF[1]={4}\tCFRpxDFzF[2]={5}\r\nCoOpxDF[0]={6}\tCoOpxDF[1]={7}\r\nsub3pxDFzF[0]={8}\tsub3pxDFzF[1]={9}\tsub3pxDFzF[2]={10}", CPhpxDFzF[0], CPhpxDFzF[1], CPhpxDFzF[2], CFRpxDFzF[0], CFRpxDFzF[1], CFRpxDFzF[2], CoOpxDF[0], CoOpxDF[1], sub3pxDFzF[0], sub3pxDFzF[1], sub3pxDFzF[2]);//debug用
            int[] BINOLta = new int[gl._an];
            for (cnt = 0; cnt < gl._an; cnt++)
            {
                BINOLta[cnt] = cnt;
            }
            int[] CoOH = new int[1] { CoO[0] };
            int[] CoOL = new int[1] { CoO[1] };
            try
            {
                BINOLgpCVR = gopjh(in BINOLta, ref po);
                CPhgpCVR = gopjh(in CoPhta, ref po);
                CFRgpCVR = gopjh(in CFRta, ref po);
                CoOgpCVR = gopjh(in CoO, ref po);
                sub3gpCVR = gopjh(in sub3ta, ref po);
                CPhHgpCVR = gopjh(in CoPhH, ref po);
                CPhLgpCVR = gopjh(in CoPhL, ref po);
                CFRHgpCVR = gopjh(in CoFuRiH, ref po);
                CFRLgpCVR = gopjh(in CoFuRiL, ref po);
                CoOHgpCVR = gopjh(in CoOH, ref po);
                CoOLgpCVR = gopjh(in CoOL, ref po);
                sub3HgpCVR = gopjh(in sub3H, ref po);
                sub3LgpCVR = gopjh(in sub3L, ref po);
                //Console.WriteLine("KI : BINOLgpCVR[0]={0}\tCPhgpCVR[1]={1}\tCFRgpCVR[2]={2}\r\nCoOgpCVR[0]={3}\tsub3gpCVR[1]={4}\tCPhHgpCVR[2]={5}\r\nCphLgpCVR[0]={6}\tCFRHgpCVR[1]={7}\tCFRLgpCVR[2]={8}\r\nCoOHgpCVR[0]={9}\tCoOLgpCVR[1]={10}\tsub3HgpCVR[2]={11}\r\nsub3LgpCVR[0]={12}", BINOLgpCVR[0], CPhgpCVR[1], CFRgpCVR[2], CoOgpCVR[0], sub3gpCVR[1], CPhHgpCVR[2], CPhLgpCVR[0], CFRHgpCVR[1], CFRLgpCVR[2], CoOHgpCVR[0], CoOLgpCVR[1], sub3HgpCVR[2], sub3LgpCVR[0]);//debug用
            }
            catch (ArgumentOutOfRangeException aore)
            {
                Console.WriteLine("{0} => {1}", aore.ParamName, aore.Message);
                throw new InvalidDataException("DescC ; Can not obtain common descriptors.");
            }
            int[] C1H = new int[1] { CoC1[0] };
            int[] C1L = new int[1] { CoC1[1] };
            int[] C2H = new int[1] { CoC2[0] };
            int[] C2L = new int[1] { CoC2[1] };
            int[] C3H = new int[1] { CoC3[0] };
            int[] C3L = new int[1] { CoC3[1] };
            CPhMcGDQ = new double[3];
            CPhMcGDQ[0] = Mcjh(in CoPhH, false);
            CPhMcGDQ[1] = Mcjh(in CoPhL, false);
            CPhMcGDQ[2] = Mcjh(in CoPhta, false);
            CFRMcGDQ = new double[3];
            CFRMcGDQ[0] = Mcjh(in CoFuRiH, false);
            CFRMcGDQ[1] = Mcjh(in CoFuRiL, false);
            CFRMcGDQ[2] = Mcjh(in CFRta, false);
            CoOMcGDQ = new double[3];
            CoOMcGDQ[0] = Mcjh(in CoOH, false);
            CoOMcGDQ[1] = Mcjh(in CoOL, false);
            CoOMcGDQ[2] = Mcjh(in CoO, false);
            sub3McGDQ = new double[3];
            sub3McGDQ[0] = Mcjh(in sub3H, false);
            sub3McGDQ[1] = Mcjh(in sub3L, false);
            sub3McGDQ[2] = Mcjh(in sub3ta, false);
            C1McGDQ = new double[3];
            C1McGDQ[0] = Mcjh(in C1H, false);
            C1McGDQ[1] = Mcjh(in C1L, false);
            C1McGDQ[2] = Mcjh(in CoC1, false);
            C2McGDQ = new double[3];
            C2McGDQ[0] = Mcjh(in C2H, false);
            C2McGDQ[1] = Mcjh(in C2L, false);
            C2McGDQ[2] = Mcjh(in CoC2, false);
            C3McGDQ = new double[3];
            C3McGDQ[0] = Mcjh(in C3H, false);
            C3McGDQ[1] = Mcjh(in C3L, false);
            C3McGDQ[2] = Mcjh(in CoC3, false);
            CFRMhcGDQ = new double[3];
            CFRMhcGDQ[0] = Mcjh(in CoFuRiH, true);
            CFRMhcGDQ[1] = Mcjh(in CoFuRiL, true);
            CFRMhcGDQ[2] = Mcjh(in CFRta, true);
            //Console.WriteLine("E : CphMcGDQ[2]={0}\tCFRMcGDQ[2]={1}\tCoOMcGDQ[2]={2}\r\nC1McGDQ[2]={3}\tC2McGDQ[2]={4}\tC3McGDQ[2]={5}\r\nCFRMhcGDQ[2]={6}", CPhMcGDQ[2], CFRMcGDQ[2], CoOMcGDQ[2], C1McGDQ[2], C2McGDQ[2], C3McGDQ[2], CFRMhcGDQ[2]);//debug用
            DpMMh = SGKC.Tensor.MahNs(gl._dipmm);
            QdMSkMhFb = new double[3];
            QdMSkMhFb[0] = SGKC.Tensor.TSekis(new SGKC.Tensor(gl._qdpmt));
            QdMSkMhFb[1] = SGKC.Tensor.MhNs(new SGKC.Tensor(gl._qdpmt));
            QdMSkMhFb[2] = SGKC.Tensor.FbNs(new SGKC.Tensor(gl._qdpmt));
            TQdMMhFb = new double[2];
            TQdMMhFb[0] = SGKC.Tensor.MhNs(new SGKC.Tensor(gl._tlqmt));
            TQdMMhFb[1] = SGKC.Tensor.FbNs(new SGKC.Tensor(gl._tlqmt));
            OcMSkMhFb = new double[3];
            OcMSkMhFb[0] = SGKC.Tensor.TSekis(new SGKC.Tensor(gl._ocpmt));
            OcMSkMhFb[1] = SGKC.Tensor.MhNs(new SGKC.Tensor(gl._ocpmt));
            OcMSkMhFb[2] = SGKC.Tensor.FbNs(new SGKC.Tensor(gl._ocpmt));
            HxMSkMhFb = new double[3];
            HxMSkMhFb[0] = SGKC.Tensor.TSekis(new SGKC.Tensor(gl._hdpmt));
            HxMSkMhFb[1] = SGKC.Tensor.MhNs(new SGKC.Tensor(gl._hdpmt));
            HxMSkMhFb[2] = SGKC.Tensor.FbNs(new SGKC.Tensor(gl._hdpmt));
            //Console.WriteLine("SU : QdMSkMhFb[0]={0}\tQdMSkMhFb[2]={1}\tTQdMMhFb[1]={2}\r\nOcMSkMhFb[0]={3}\tOcMSkMhFb[2]={4}\r\nHxMSkMhFb[0]={5}\tHxMSkMhFb[2]={6}", QdMSkMhFb[0], QdMSkMhFb[2], TQdMMhFb[1], OcMSkMhFb[0], OcMSkMhFb[2], HxMSkMhFb[0], HxMSkMhFb[2]);//debug用
            CPhHfP = HfPw(in CoPhta, ref po);
            CPhHHfP = HfPw(in CoPhH, ref po);
            CPhLHfP = HfPw(in CoPhL, ref po);
            CoOHfp = HfPw(in CoO, ref po);
            CoOHHfp = HfPw(in CoOH, ref po);
            CoOLHfp = HfPw(in CoOL, ref po);
            sub3HfP = HfPw(in sub3ta, ref po);
            CFRHfP = HfPw(in CFRta, ref po);
            C1HfP = HfPw(in CoC1, ref po);
            C2HfP = HfPw(in CoC2, ref po);
            C3HfP = HfPw(in CoC3, ref po);
            //Console.WriteLine("SU : CPhHfP[0]={0}\tCphHfp[1]={1}\tCphHHfp[0]={2}\tCphLHfp[0]={3}\r\nCoOHfp[0]={4}\tCoOHfp[1]={5}\tCoOHHfp[0]={6}\tCoOLHfp[0]={7}\r\nsub3Hfp[0]={8}\tCFRHfp[0]={9}\r\nC1HfP[0]={10}\tC2HfP[0]={11}\tC3HfP[0]={12}", CPhHfP[0], CPhHfP[1], CPhHHfP[0], CPhLHfP[0], CoOHfp[0], CoOHfp[1], CoOHHfp[0], CoOLHfp[0], sub3HfP[0], CFRHfP[0], C1HfP[0], C2HfP[0], C3HfP[0]);//debug用
            HDipN = new double[2];
            HDipN[0] = SGKC.Tensor.EucNs(gl._HDipc);
            HDipN[1] = SGKC.Tensor.EucNs(gl._HDipt);
            //Console.WriteLine("KO : HDipN[0]={0}\tHDipN[1]={1}", HDipN[0], HDipN[1]);//debug用
            CPhHfC = HfQw(in CoPhta, false);
            CPhHHfC = HfQw(in CoPhH, false);
            CPhLHfC = HfQw(in CoPhL, false);
            CoOHfC = HfQw(in CoO, false);
            CoOHHfC = HfQw(in CoOH, false);
            CoOLHfC = HfQw(in CoOL, false);
            sub3HfC = HfQw(in sub3ta, false);
            sub3HHfC = HfQw(in sub3H, false);
            sub3LHfC = HfQw(in sub3L, false);
            CFRHfC = HfQw(in CFRta, false);
            CFRHHfC = HfQw(in CoFuRiH, false);
            CFRLHfC = HfQw(in CoFuRiL, false);
            C1HfC = HfQw(in CoC1, false);
            C2HfC = HfQw(in CoC2, false);
            C3HfC = HfQw(in CoC3, false);
            CFRHfhC = HfQw(in CFRta, true);
            CFRHHfhC = HfQw(in CoFuRiH, true);
            CFRLHfhC = HfQw(in CoFuRiL, true);
            //Console.WriteLine("E : CPhHfC[0]={0}\tCPhHHfC[1]={1}\tCPhLHfC[0]={2}\r\nCoOHfC[1]={3}\tCoOHHfC[0]={4}\tCoOLHfC[1]={5}\r\nsub3Hfc[0]={6}\tsub3HHfc[1]={7}\tsub3LHfc[0]={8}\r\nCFRHfC[1]={9}\tCFRHHfC[0]={10}\tCFRLHfC[1]={11}\r\nC1HfC[0]={12}\tC2HfC[1]={13}\tC3HfC[0]={14}\r\nCFRHfhC[1]={15}\tCFRHHfhC[0]={16}\tCFRLHfhC[1]={17}", CPhHfC[0], CPhHHfC[1], CPhLHfC[0], CoOHfC[1], CoOHHfC[0], CoOLHfC[1], sub3HfC[0], sub3HHfC[1], sub3LHfC[0], CFRHfC[1], CFRHHfC[0], CFRLHfC[1], C1HfC[0], C2HfC[1], C3HfC[0], CFRHfhC[1], CFRHHfhC[0], CFRLHfhC[1]);//debug用
            moevov = new double[2];
            tokeov = new double[2];
            Parallel.For(0, gl._bfn, po, (cnt2) =>
            {
                if (gl._moevo)
                {
                    if (cnt2 < gl._occmo)
                    {
                        lock (moevov.SyncRoot) moevov[0] += gl._moev[cnt2];
                        lock (tokeov.SyncRoot) tokeov[0] += gl._oke[cnt2];
                    }
                    else
                    {
                        lock (moevov.SyncRoot) moevov[1] += gl._moev[cnt2];
                        lock (tokeov.SyncRoot) tokeov[1] += gl._oke[cnt2];
                    }
                }
                else
                {
                    if (cnt2 < gl._vrtmo)
                    {
                        lock (moevov.SyncRoot) moevov[1] += gl._moev[cnt2];
                        lock (tokeov.SyncRoot) tokeov[1] += gl._oke[cnt2];
                    }
                    else
                    {
                        lock (moevov.SyncRoot) moevov[0] += gl._moev[cnt2];
                        lock (tokeov.SyncRoot) tokeov[0] += gl._oke[cnt2];
                    }
                }
            });
            //Console.WriteLine("KI : moevov[0]={0}\tmoevov[1]={1}\r\ntokeov[0]={2}\ttokeov[1]={3}", moevov[0], moevov[1], tokeov[0], tokeov[1]);//debug用
            CPhEcKTZ = new double[3];
            CPhEcKTZ[0] = Ecw(in CoPhH, false);
            CPhEcKTZ[1] = Ecw(in CoPhL, false);
            CPhEcKTZ[2] = Ecw(in CoPhta, false);
            CoOEcKTZ = new double[3];
            CoOEcKTZ[0] = Ecw(in CoOH, false);
            CoOEcKTZ[1] = Ecw(in CoOL, false);
            CoOEcKTZ[2] = Ecw(in CoO, false);
            sub3EcKTZ = new double[3];
            sub3EcKTZ[0] = Ecw(in sub3H, false);
            sub3EcKTZ[1] = Ecw(in sub3L, false);
            sub3EcKTZ[2] = Ecw(in sub3ta, false);
            CFREcKTZ = new double[3];
            CFREcKTZ[0] = Ecw(in CoFuRiH, false);
            CFREcKTZ[1] = Ecw(in CoFuRiL, false);
            CFREcKTZ[2] = Ecw(in CFRta, false);
            C123Ec = new double[3];
            C123Ec[0] = Ecw(in CoC1, false);
            C123Ec[1] = Ecw(in CoC2, false);
            C123Ec[2] = Ecw(in CoC3, false);
            CFREhcKTZ = new double[3];
            CFREhcKTZ[0] = Ecw(in CoFuRiH, true);
            CFREhcKTZ[1] = Ecw(in CoFuRiL, true);
            CFREhcKTZ[2] = Ecw(in CFRta, true);
            //Console.WriteLine("A : CPhEcKTZ[0]={0}\tCoOEcKTZ[1]={1}\tsub3EcKTZ[2]={2}\r\nCFREcKTZ[0]={3}\tC123Ec[1]={4}\tCFREhcKTZ[2]={5}", CPhEcKTZ[0], CoOEcKTZ[1], sub3EcKTZ[2], CFREcKTZ[0], C123Ec[1], CFREhcKTZ[2]);//debug用
            CPhEp = Epw(in CoPhta);
            CoOEp = Epw(in CoO);
            CFREp = Epw(in CFRta);
            C123Ep = new double[3];
            C123Ep[0] = Epw(in CoC1);
            C123Ep[1] = Epw(in CoC2);
            C123Ep[2] = Epw(in CoC3);
            //Console.WriteLine("I : CPhEp={0}\tCoOEp={1}\tCFREp={2}\r\nC123Ep[0]={3}\tC123Ep[1]={4}\tC123Ep[2]={5}", CPhEp, CoOEp, CFREp, C123Ep[0], C123Ep[1], C123Ep[2]);//debug用
            CPhNAOOvrEvr = NAOOE(in CoPhta, ref po, true);
            CPhHNAOOvrEvr = NAOOE(in CoPhH, ref po, true);
            CPhLNAOOvrEvr = NAOOE(in CoPhL, ref po, true);
            CoONAOOvrEvr = NAOOE(in CoO, ref po, true);
            sub3NAOOvrEvr = NAOOE(in sub3ta, ref po, true);
            sub3HNAOOvrEvr = NAOOE(in sub3H, ref po, true);
            sub3LNAOOvrEvr = NAOOE(in sub3L, ref po, true);
            CFRNAOOvrEvr = NAOOE(in CFRta, ref po, true);
            CFRHNAOOvrEvr = NAOOE(in CoFuRiH, ref po, true);
            CFRLNAOOvrEvr = NAOOE(in CoFuRiL, ref po, true);
            C1NAOOvrEvr = NAOOE(in CoC1, ref po, true);
            C2NAOOvrEvr = NAOOE(in CoC2, ref po, true);
            C3NAOOvrEvr = NAOOE(in CoC3, ref po, true);
            CoOHNAOEvr = NAOOE(in CoOH, ref po, false);
            CoOLNAOEvr = NAOOE(in CoOL, ref po, false);
            C1HNAOEvr = NAOOE(in C1H, ref po, false);
            C1LNAOEvr = NAOOE(in C1L, ref po, false);
            C2HNAOEvr = NAOOE(in C2H, ref po, false);
            C2LNAOEvr = NAOOE(in C2L, ref po, false);
            C3HNAOEvr = NAOOE(in C3H, ref po, false);
            C3LNAOEvr = NAOOE(in C3L, ref po, false);
            //Console.WriteLine("SU : CPhNAOOvrEvr[0]={0}\tCPhHNAOOvrEvr[1]={1}\tCPhLNAOOvrEvr[2]={2}\r\nCoONAOOvrEvr[3]={3}\tsub3NAOOvrEvr[0]={4}\tsub3HNAOOvrEvr[1]={5}\r\nsub3LNAOOvrEvr[2]={6}\tCFRNAOOvrEvr[3]={7}\tCFRHNAOOvrEvr[0]={8}\r\nCFRLNAOOvrEvr[1]={9}\tC1NAOOvrEvr[2]={10}\tC2NAOOvrEvr[3]={11}\r\nC3NAOOvrEvr[0]={12}\tCoOHNAOEvr[1]={13}\tCoOLNAOEvr[0]={14}\r\nC1HNAOEvr[1]={15}\tC1LNAOEvr[0]={16}\tC2HNAOEvr[1]={17}\r\nC2LNAOEvr[0]={18}\tC3HNAOEvr[1]={19}\tC3LNAOEvr[0]={20}", CPhNAOOvrEvr[0], CPhHNAOOvrEvr[1], CPhLNAOOvrEvr[2], CoONAOOvrEvr[3], sub3NAOOvrEvr[0], sub3HNAOOvrEvr[1], sub3LNAOOvrEvr[2], CFRNAOOvrEvr[3], CFRHNAOOvrEvr[0], CFRLNAOOvrEvr[1], C1NAOOvrEvr[2], C2NAOOvrEvr[3], C3NAOOvrEvr[0], CoOHNAOEvr[1], CoOLNAOEvr[0], C1HNAOEvr[1], C1LNAOEvr[0], C2HNAOEvr[1], C2LNAOEvr[0], C3HNAOEvr[1], C3LNAOEvr[0]);//debug用
            CPhNAOcGDQ = new double[3];
            CPhNAOcGDQ[0] = NAOcw(in CoPhH);
            CPhNAOcGDQ[1] = NAOcw(in CoPhL);
            CPhNAOcGDQ[2] = NAOcw(in CoPhta);
            CoONAOc = NAOcw(in CoO);
            sub3NAOcGDQ = new double[3];
            sub3NAOcGDQ[0] = NAOcw(in sub3H);
            sub3NAOcGDQ[1] = NAOcw(in sub3L);
            sub3NAOcGDQ[2] = NAOcw(in sub3ta);
            CFRNAOcGDQ = new double[3];
            CFRNAOcGDQ[0] = NAOcw(in CoFuRiH);
            CFRNAOcGDQ[1] = NAOcw(in CoFuRiL);
            CFRNAOcGDQ[2] = NAOcw(in CFRta);
            C123NAOc = new double[3];
            C123NAOc[0] = NAOcw(in CoC1);
            C123NAOc[1] = NAOcw(in CoC2);
            C123NAOc[2] = NAOcw(in CoC3);
            sub3NAOtGDQ = new double[3];
            sub3NAOtGDQ[0] = NAOtw(in CoFuRiH);
            sub3NAOtGDQ[1] = NAOtw(in CoFuRiL);
            sub3NAOtGDQ[2] = NAOtw(in CFRta);
            //Console.WriteLine("KO : CPhNAOcGDQ[0]={0}\tCoONAOc={1}\tsub3NAOcGDQ[1]={2}\r\nCFRNAOcGDQ[2]={3}\tc123NAOc[0]={4}\tsub3NAOtGDQ[1]={5}", CPhNAOcGDQ[0], CoONAOc, sub3NAOcGDQ[1], CFRNAOcGDQ[2], C123NAOc[0], sub3NAOtGDQ[1]);//debug用
            CPhN2s2p = NVsp(in CoPhta, false);
            sub3N2s2p = NVsp(in sub3ta, false);
            sub3Nnsnp = NVsp(in sub3ta, true);
            CFRN2s2p = NVsp(in CFRta, false);
            C1N2s2p = NVsp(in CoC1, false);
            C2N2s2p = NVsp(in CoC2, false);
            C3N2s2p = NVsp(in CoC3, false);
            //Console.WriteLine("A : CPhN2s2p[0]={0}\tsub3N2s2p[1]={1}\tsub3Nnsnp[0]={2}\r\nCFRN2s2p[1]={3}\tC1N2s2p[0]={4}\tC2N2s2p[1]={5}\r\nC3N2s2p[0]={6}", CPhN2s2p[0], sub3N2s2p[1], sub3Nnsnp[0], CFRN2s2p[1], C1N2s2p[0], C2N2s2p[1], C3N2s2p[0]);//debug用
            CPhBD1THL = new int[3][];
            CPhBD1THL[1] = BdIS(CoPhH, CoPhH, ref po, true, false);
            CPhBD1THL[2] = BdIS(CoPhL, CoPhL, ref po, true, false);
            CPhBD1THL[0] = BdIG(in CPhBD1THL[1], in CPhBD1THL[2], ref po);
            CPhBD1espd = BDEw(in CPhBD1THL[0], ref po, true, true, true, true);
            CPhHBD1espd = BDEw(in CPhBD1THL[1], ref po, true, true, true, true);
            CPhLBD1espd = BDEw(in CPhBD1THL[2], ref po, true, true, true, true);
            CPhBD2THL = new int[3][];
            CPhBD2THL[1] = BdIS(CoPhH, CoPhH, ref po, false, false);
            CPhBD2THL[2] = BdIS(CoPhL, CoPhL, ref po, false, false);
            CPhBD2THL[0] = BdIG(in CPhBD2THL[1], in CPhBD2THL[2], ref po);
            CPhBD2pd = BDEw(in CPhBD2THL[0], ref po, false, false, true, true);
            CPhHBD2pd = BDEw(in CPhBD2THL[1], ref po, false, false, true, true);
            CPhLBD2pd = BDEw(in CPhBD2THL[2], ref po, false, false, true, true);
            CPhBDs1THL = new int[3][];
            CPhBDs1THL[1] = BdIS(CoPhH, CoPhH, ref po, true, true);
            CPhBDs1THL[2] = BdIS(CoPhL, CoPhL, ref po, true, true);
            CPhBDs1THL[0] = BdIG(in CPhBDs1THL[1], in CPhBDs1THL[2], ref po);
            CPhBDs1espd = BDEw(in CPhBDs1THL[0], ref po, true, true, true, true);
            CPhHBDs1espd = BDEw(in CPhBDs1THL[1], ref po, true, true, true, true);
            CPhLBDs1espd = BDEw(in CPhBDs1THL[2], ref po, true, true, true, true);
            CPhBDs2THL = new int[3][];
            CPhBDs2THL[1] = BdIS(CoPhH, CoPhH, ref po, false, true);
            CPhBDs2THL[2] = BdIS(CoPhL, CoPhL, ref po, false, true);
            CPhBDs2THL[0] = BdIG(in CPhBDs2THL[1], in CPhBDs2THL[2], ref po);
            CPhBDs2pd = BDEw(in CPhBDs2THL[0], ref po, false, false, true, true);
            CPhHBDs2pd = BDEw(in CPhBDs2THL[1], ref po, false, false, true, true);
            CPhLBDs2pd = BDEw(in CPhBDs2THL[2], ref po, false, false, true, true);
            //Console.WriteLine("A : CPhBD1THL[0]={0}\tCPhBD1espd[0]={1}\tCphHBD1espd[1]={2}\r\nCPhBD2THL[1]={3}\tCPhLBD2pd[0]={4}\tCPhBD2pd[1]={5}\r\nCPhBDs1THL[2]={6}\tCPhHBDs1espd[2]={7}\tCPhLBDs1espd[3]={8}\r\nCPhBDs2THL[0]={9}\tCPhBDs2pd[0]={10}\tCPhHBDs2pd[1]={11}", CPhBD1THL[0].Length, CPhBD1espd[0], CPhHBD1espd[1], CPhBD2THL[1].Length, CPhLBD2pd[0], CPhBD2pd[1], CPhBDs1THL[2].Length, CPhHBDs1espd[2], CPhLBDs1espd[3], CPhBDs2THL[0].Length, CPhBDs2pd[0], CPhHBDs2pd[1]);//debug用
            CFRBD1THL = new int[3][];
            CFRBD1THL[1] = BdIS(CoFuRiH, CoFuRiH, ref po, true, false);
            CFRBD1THL[2] = BdIS(CoFuRiL, CoFuRiL, ref po, true, false);
            CFRBD1THL[0] = BdIG(in CFRBD1THL[1], in CFRBD1THL[2], ref po);
            CFRBD1espd = BDEw(in CFRBD1THL[0], ref po, true, true, true, true);
            CFRHBD1espd = BDEw(in CFRBD1THL[1], ref po, true, true, true, true);
            CFRLBD1espd = BDEw(in CFRBD1THL[2], ref po, true, true, true, true);
            CFRBD2THL = new int[3][];
            CFRBD2THL[1] = BdIS(CoFuRiH, CoFuRiH, ref po, false, false);
            CFRBD2THL[2] = BdIS(CoFuRiL, CoFuRiL, ref po, false, false);
            CFRBD2THL[0] = BdIG(in CFRBD2THL[1], in CFRBD2THL[2], ref po);
            CFRBD2pd = BDEw(in CFRBD2THL[0], ref po, false, false, true, true);
            CFRHBD2pd = BDEw(in CFRBD2THL[1], ref po, false, false, true, true);
            CFRLBD2pd = BDEw(in CFRBD2THL[2], ref po, false, false, true, true);
            CFRBDs1THL = new int[3][];
            CFRBDs1THL[1] = BdIS(CoFuRiH, CoFuRiH, ref po, true, true);
            CFRBDs1THL[2] = BdIS(CoFuRiL, CoFuRiL, ref po, true, true);
            CFRBDs1THL[0] = BdIG(in CFRBDs1THL[1], in CFRBDs1THL[2], ref po);
            CFRBDs1espd = BDEw(in CFRBDs1THL[0], ref po, true, true, true, true);
            CFRHBDs1espd = BDEw(in CFRBDs1THL[1], ref po, true, true, true, true);
            CFRLBDs1espd = BDEw(in CFRBDs1THL[2], ref po, true, true, true, true);
            CFRBDs2THL = new int[3][];
            CFRBDs2THL[1] = BdIS(CoFuRiH, CoFuRiH, ref po, false, true);
            CFRBDs2THL[2] = BdIS(CoFuRiL, CoFuRiL, ref po, false, true);
            CFRBDs2THL[0] = BdIG(in CFRBDs2THL[1], in CFRBDs2THL[2], ref po);
            CFRBDs2pd = BDEw(in CFRBDs2THL[0], ref po, false, false, true, true);
            CFRHBDs2pd = BDEw(in CFRBDs2THL[1], ref po, false, false, true, true);
            CFRLBDs2pd = BDEw(in CFRBDs2THL[2], ref po, false, false, true, true);
            //Console.WriteLine("KI : CFRBD1THL[0]={0}\tCFRBD1espd[0]={1}\tCFRHBD1espd[1]={2}\r\nCFRBD2THL[1]={3}\tCFRLBD2pd[0]={4}\tCFRBD2pd[1]={5}\r\nCFRBDs1THL[2]={6}\tCFRHBDs1espd[2]={7}\tCFRLBDs1espd[3]={8}\r\nCFRBDs2THL[0]={9}\tCFRBDs2pd[0]={10}\tCFRHBDs2pd[1]={11}", CFRBD1THL[0].Length, CFRBD1espd[0], CFRHBD1espd[1], CFRBD2THL[1].Length, CFRLBD2pd[0], CFRBD2pd[1], CFRBDs1THL[2].Length, CFRHBDs1espd[2], CFRLBDs1espd[3], CFRBDs2THL[0].Length, CFRBDs2pd[0], CFRHBDs2pd[1]);//debug用
            sub3BD2THL = new int[3][];
            sub3BD2THL[1] = BdIS(sub3H, sub3H, ref po, false, false);
            sub3BD2THL[2] = BdIS(sub3L, sub3L, ref po, false, false);
            sub3BD2THL[0] = BdIG(in sub3BD2THL[1], in sub3BD2THL[2], ref po);
            sub3BD2pd = BDEw(in sub3BD2THL[0], ref po, false, false, true, true);
            sub3HBD2pd = BDEw(in sub3BD2THL[1], ref po, false, false, true, true);
            sub3LBD2pd = BDEw(in sub3BD2THL[2], ref po, false, false, true, true);
            sub3BDs2THL = new int[3][];
            sub3BDs2THL[1] = BdIS(sub3H, sub3H, ref po, false, true);
            sub3BDs2THL[2] = BdIS(sub3L, sub3L, ref po, false, true);
            sub3BDs2THL[0] = BdIG(in sub3BDs2THL[1], in sub3BDs2THL[2], ref po);
            sub3BDs2pd = BDEw(in sub3BDs2THL[0], ref po, false, false, true, true);
            sub3HBDs2pd = BDEw(in sub3BDs2THL[1], ref po, false, false, true, true);
            sub3LBDs2pd = BDEw(in sub3BDs2THL[2], ref po, false, false, true, true);
            sub3L2THL = new int[3][];
            sub3L2THL[1] = LRIS(in sub3H, ref po, true, false, true);
            sub3L2THL[2] = LRIS(in sub3L, ref po, true, false, true);
            sub3L2THL[0] = BdIG(in sub3L2THL[1], in sub3L2THL[2], ref po);
            sub3L2espd = LREw(in sub3L2THL[0], ref po, true, true, true, true);
            sub3HL2espd = LREw(in sub3L2THL[1], ref po, true, true, true, true);
            sub3LL2espd = LREw(in sub3L2THL[2], ref po, true, true, true, true);
            sub3LnTHL = new int[3][];
            sub3LnTHL[1] = LRIS(in sub3H, ref po, true, false, false);
            sub3LnTHL[2] = LRIS(in sub3L, ref po, true, false, false);
            sub3LnTHL[0] = BdIG(in sub3LnTHL[1], in sub3LnTHL[2], ref po);
            sub3Lnespd = LREw(in sub3LnTHL[0], ref po, true, true, true, true);
            sub3HLnespd = LREw(in sub3LnTHL[1], ref po, true, true, true, true);
            sub3LLnespd = LREw(in sub3LnTHL[2], ref po, true, true, true, true);
            //Console.WriteLine("KO : sub3BD2THL[0]={0}\tsub3BD2pd[0]={1}\tsub3HBD2pd[1]={2}\r\nsub3BDs2THL[1]={3}\tsub3LBDs2pd[0]={4}\tsub3BDs2pd[1]={5}\r\nsub3L2THL[2]={6}\tsub3HL2espd[2]={7}\tsub3LL2espd[3]={8}\r\nsub3LnTHL[0]={9}\tsub3Lnespd[0]={10}\tsub3HLnespd[1]={11}", sub3BD2THL[0].Length, sub3BD2pd[0], sub3HBD2pd[1], sub3BDs2THL[1].Length, sub3LBDs2pd[0], sub3BDs2pd[1], sub3L2THL[2].Length, sub3HL2espd[2], sub3LL2espd[3], sub3LnTHL[0].Length, sub3Lnespd[0], sub3HLnespd[1]);//debug用
            C11BDBDs = new int[2][];
            C11BDBDs[0] = BdIS(CoC1, CoC1, ref po, true, false);
            C11BDBDs[1] = BdIS(CoC1, CoC1, ref po, true, true);
            C11BDespd = BDEw(in C11BDBDs[0], ref po, true, true, true, true);
            C11BDsespd = BDEw(in C11BDBDs[1], ref po, true, true, true, true);
            C2OBDTHL = new int[3][];
            C2OBDTHL[1] = BdIS(C2H, CoOH, ref po, true, false);
            C2OBDTHL[2] = BdIS(C2L, CoOL, ref po, true, false);
            C2OBDTHL[0] = BdIG(in C2OBDTHL[1], in C2OBDTHL[2], ref po);
            C2OBDespd = BDEw(in C2OBDTHL[0], ref po, true, true, true, true);
            C2OHBDespd = BDEw(in C2OBDTHL[1], ref po, true, true, true, true);
            C2OLBDespd = BDEw(in C2OBDTHL[2], ref po, true, true, true, true);
            C2OBDsTHL = new int[3][];
            C2OBDsTHL[1] = BdIS(C2H, CoOH, ref po, true, true);
            C2OBDsTHL[2] = BdIS(C2L, CoOL, ref po, true, true);
            C2OBDsTHL[0] = BdIG(in C2OBDsTHL[1], in C2OBDsTHL[2], ref po);
            C2OBDsespd = BDEw(in C2OBDsTHL[0], ref po, true, true, true, true);
            C2OHBDsespd = BDEw(in C2OBDsTHL[1], ref po, true, true, true, true);
            C2OLBDsespd = BDEw(in C2OBDsTHL[2], ref po, true, true, true, true);
            //Console.WriteLine("E : C11BDBDs[0]={0}\tC11BDespd[0]={1}\tC11BDsespd[1]={2}\r\nC2OBDTHL[1]={3}\tC2OBDespd[2]={4}\tC2OHBDespd[3]={5}\r\nC2OBDsTHL[2]={6}\tC2OLBDsespd[0]={7}\tC2OBDsespd[1]={8}", C11BDBDs[0].Length, C11BDespd[0], C11BDsespd[1], C2OBDTHL[1].Length, C2OBDespd[2], C2OHBDespd[3], C2OBDsTHL[2].Length, C2OLBDsespd[0], C2OBDsespd[1]);//debug用
            C3sBDTHL = new int[3][];
            C3sBDTHL[1] = BdIS(C3H, sub3H, ref po, true, false);
            C3sBDTHL[2] = BdIS(C3L, sub3L, ref po, true, false);
            C3sBDTHL[0] = BdIG(in C3sBDTHL[1], C3sBDTHL[2], ref po);
            C3sBDespd = BDEw(in C3sBDTHL[0], ref po, true, true, true, true);
            C3sHBDespd = BDEw(in C3sBDTHL[1], ref po, true, true, true, true);
            C3sLBDespd = BDEw(in C3sBDTHL[2], ref po, true, true, true, true);
            C3sBDsTHL = new int[3][];
            C3sBDsTHL[1] = BdIS(C3H, sub3H, ref po, true, true);
            C3sBDsTHL[2] = BdIS(C3L, sub3L, ref po, true, true);
            C3sBDsTHL[0] = BdIG(in C3sBDsTHL[1], C3sBDsTHL[2], ref po);
            C3sBDsespd = BDEw(in C3sBDsTHL[0], ref po, true, true, true, true);
            C3sHBDsespd = BDEw(in C3sBDsTHL[1], ref po, true, true, true, true);
            C3sLBDsespd = BDEw(in C3sBDsTHL[2], ref po, true, true, true, true);
            CoOLTHL = new int[3][];
            CoOLTHL[1] = LRIS(in CoOH, ref po, true, false, true);
            CoOLTHL[2] = LRIS(in CoOL, ref po, true, false, true);
            CoOLTHL[0] = BdIG(in CoOLTHL[1], in CoOLTHL[2], ref po);
            CoOLespd = LREw(in CoOLTHL[0], ref po, true, true, true, true);
            CoOHLespd = LREw(in CoOLTHL[1], ref po, true, true, true, true);
            CoOLLespd = LREw(in CoOLTHL[2], ref po, true, true, true, true);
            //Console.WriteLine("SU : C3sBDTHL[0]={0}\tC3sBDespd[0]={1}\tC3sHBDespd[1]={2}\r\nC3sBDsTHL[1]={3}\tC3sLBDsespd[2]={4}\tC3sBDsespd[3]={5}\r\nCoOLTHL[2]={6}\tCoOHLespd[0]={7}\tCoOLLespd[1]={8}", C3sBDTHL[0].Length, C3sBDespd[0], C3sHBDespd[1], C3sBDsTHL[1].Length, C3sLBDsespd[2], C3sBDsespd[3], CoOLTHL[2].Length, CoOHLespd[0], CoOLLespd[1]);//debug用
            int[] sub3BD1H = BdIS(sub3H, sub3H, ref po, true, false);
            int[] sub3BD1L = BdIS(sub3L, sub3L, ref po, true, false);
            int[] sub3BD1 = BdIG(in sub3BD1H, in sub3BD1L, ref po);
            sub3BD1H = null;
            sub3BD1L = null;
            NHOSk1sin2TCS = new double[3];
            NHOSk1sin2TCS[0] = NHOSkS(ref po, true, false, "sin2");
            NHOSk1sin2TCS[1] = NHOSkS(in CFRBD1THL[0], ref po, true, false, "sin2");
            NHOSk1sin2TCS[2] = NHOSkS(in sub3BD1, ref po, true, false, "sin2");
            NHOSk1cosTCS = new double[3];
            NHOSk1cosTCS[0] = NHOSkS(ref po, true, false, "cos");
            NHOSk1cosTCS[1] = NHOSkS(in CFRBD1THL[0], ref po, true, false, "cos");
            NHOSk1cosTCS[2] = NHOSkS(in sub3BD1, ref po, true, false, "cos");
            sub3BD1 = null;
            NHOSk2cos2TCS = new double[3];
            NHOSk2cos2TCS[0] = NHOSkS(ref po, false, false, "cos2");
            NHOSk2cos2TCS[1] = NHOSkS(in CFRBD2THL[0], ref po, false, false, "cos2");
            NHOSk2cos2TCS[2] = NHOSkS(in sub3BD2THL[0], ref po, false, false, "cos2");
            NHOSk2sinTCS = new double[3];
            NHOSk2sinTCS[0] = NHOSkS(ref po, false, false, "sin");
            NHOSk2sinTCS[1] = NHOSkS(in CFRBD2THL[0], ref po, false, false, "sin");
            NHOSk2sinTCS[2] = NHOSkS(in sub3BD2THL[0], ref po, false, false, "sin");
            //Console.WriteLine("SU : NHOSk1sin2TCS[0]={0}\tNHOSk1sin2TCS[1]={1}\r\nNHOSk1cosTCS[2]={2}\tNHOSk1cosTCS[0]={3}\r\nNHOSk2cos2TCS[1]={4}\tNHOSk2cos2TCS[2]={5}\r\nNHOSk2sinTCS[0]={6}\tNHOSk2sinTCS[1]={7}", NHOSk1sin2TCS[0], NHOSk1sin2TCS[1], NHOSk1cosTCS[2], NHOSk1cosTCS[0], NHOSk2cos2TCS[1], NHOSk2cos2TCS[2], NHOSk2sinTCS[0], NHOSk2sinTCS[1]);//debug用
            CoPh1DonZGD = new double[3];
            CoPh1DonZGD[0] = SopeS(in CPhBD1THL[0], null, ref po, true, false, false);
            CoPh1DonZGD[1] = SopeS(in CPhBD1THL[1], null, ref po, true, false, false);
            CoPh1DonZGD[2] = SopeS(in CPhBD1THL[2], null, ref po, true, false, false);
            CoPh2DonZGD = new double[3];
            CoPh2DonZGD[0] = SopeS(in CPhBD2THL[0], null, ref po, true, false, false);
            CoPh2DonZGD[1] = SopeS(in CPhBD2THL[1], null, ref po, true, false, false);
            CoPh2DonZGD[2] = SopeS(in CPhBD2THL[2], null, ref po, true, false, false);
            int[][] CoPhRyTHL = new int[3][];
            CoPhRyTHL[1] = LRIS(in CoPhH, ref po, false, true, null);
            CoPhRyTHL[2] = LRIS(in CoPhL, ref po, false, true, null);
            CoPhRyTHL[0] = BdIG(in CoPhRyTHL[1], in CoPhRyTHL[2], ref po);
            CoPhAccZGD = new double[3];
            CoPhAccZGD[0] = SopeS(in CPhBDs1THL[0], null, ref po, false, false, false) + SopeS(in CPhBDs2THL[0], null, ref po, false, false, false) + SopeS(in CoPhRyTHL[0], null, ref po, false, true, false);
            CoPhAccZGD[1] = SopeS(in CPhBDs1THL[1], null, ref po, false, false, false) + SopeS(in CPhBDs2THL[1], null, ref po, false, false, false) + SopeS(in CoPhRyTHL[1], null, ref po, false, true, false);
            CoPhAccZGD[2] = SopeS(in CPhBDs1THL[2], null, ref po, false, false, false) + SopeS(in CPhBDs2THL[2], null, ref po, false, false, false) + SopeS(in CoPhRyTHL[2], null, ref po, false, true, false);
            CFR1DonZGD = new double[3];
            CFR1DonZGD[0] = SopeS(in CFRBD1THL[0], null, ref po, true, false, false);
            CFR1DonZGD[1] = SopeS(in CFRBD1THL[1], null, ref po, true, false, false);
            CFR1DonZGD[2] = SopeS(in CFRBD1THL[2], null, ref po, true, false, false);
            CFR2DonZGD = new double[3];
            CFR2DonZGD[0] = SopeS(in CFRBD2THL[0], null, ref po, true, false, false);
            CFR2DonZGD[1] = SopeS(in CFRBD2THL[1], null, ref po, true, false, false);
            CFR2DonZGD[2] = SopeS(in CFRBD2THL[2], null, ref po, true, false, false);
            int[][] CFRRyTHL = new int[3][];
            CFRRyTHL[1] = LRIS(in CoFuRiH, ref po, false, true, null);
            CFRRyTHL[2] = LRIS(in CoFuRiL, ref po, false, true, null);
            CFRRyTHL[0] = BdIG(in CFRRyTHL[1], in CFRRyTHL[2], ref po);
            CFRAccZGD = new double[3];
            CFRAccZGD[0] = SopeS(in CFRBDs1THL[0], null, ref po, false, false, false) + SopeS(in CFRBDs2THL[0], null, ref po, false, false, false) + SopeS(in CFRRyTHL[0], null, ref po, false, true, false);
            CFRAccZGD[1] = SopeS(in CFRBDs1THL[1], null, ref po, false, false, false) + SopeS(in CFRBDs2THL[1], null, ref po, false, false, false) + SopeS(in CFRRyTHL[1], null, ref po, false, true, false);
            CFRAccZGD[2] = SopeS(in CFRBDs1THL[2], null, ref po, false, false, false) + SopeS(in CFRBDs2THL[2], null, ref po, false, false, false) + SopeS(in CFRRyTHL[2], null, ref po, false, true, false);
            sub32DonZGD = new double[3];
            sub32DonZGD[0] = SopeS(in sub3BD2THL[0], null, ref po, true, false, false);
            sub32DonZGD[1] = SopeS(in sub3BD2THL[1], null, ref po, true, false, false);
            sub32DonZGD[2] = SopeS(in sub3BD2THL[2], null, ref po, true, false, false);
            sub3L2DonZGD = new double[3];
            sub3L2DonZGD[0] = SopeS(in sub3L2THL[0], null, ref po, true, true, false);
            sub3L2DonZGD[1] = SopeS(in sub3L2THL[1], null, ref po, true, true, false);
            sub3L2DonZGD[2] = SopeS(in sub3L2THL[2], null, ref po, true, true, false);
            sub3LnDonZGD = new double[3];
            sub3LnDonZGD[0] = SopeS(in sub3LnTHL[0], null, ref po, true, true, false);
            sub3LnDonZGD[1] = SopeS(in sub3LnTHL[1], null, ref po, true, true, false);
            sub3LnDonZGD[2] = SopeS(in sub3LnTHL[2], null, ref po, true, true, false);
            int[][] sub3RyTHL = new int[3][];
            sub3RyTHL[1] = LRIS(in sub3H, ref po, false, true, null);
            sub3RyTHL[2] = LRIS(in sub3L, ref po, false, true, null);
            sub3RyTHL[0] = BdIG(in sub3H, in sub3L, ref po);
            int[][] sub3BDs1THL = new int[3][];
            sub3BDs1THL[1] = BdIS(sub3H, sub3H, ref po, true, true);
            sub3BDs1THL[2] = BdIS(sub3L, sub3L, ref po, true, true);
            sub3BDs1THL[0] = BdIG(in sub3BDs1THL[1], sub3BDs1THL[2], ref po);
            sub3AccZGD = new double[3];
            sub3AccZGD[0] = SopeS(in sub3BDs1THL[0], null, ref po, false, false, false) + SopeS(in sub3BDs2THL[0], null, ref po, false, false, false) + SopeS(in sub3RyTHL[0], null, ref po, false, true, false);
            sub3AccZGD[1] = SopeS(in sub3BDs1THL[1], null, ref po, false, false, false) + SopeS(in sub3BDs2THL[1], null, ref po, false, false, false) + SopeS(in sub3RyTHL[1], null, ref po, false, true, false);
            sub3AccZGD[2] = SopeS(in sub3BDs1THL[2], null, ref po, false, false, false) + SopeS(in sub3BDs2THL[2], null, ref po, false, false, false) + SopeS(in sub3RyTHL[2], null, ref po, false, true, false);
            sub3BDs1THL[0] = null;
            sub3BDs1THL[1] = null;
            sub3BDs1THL[2] = null;
            sub3BDs1THL = null;
            C11DonAcc = new double[2];
            C11DonAcc[0] = SopeS(in C11BDBDs[0], null, ref po, true, false, false);
            C11DonAcc[1] = SopeS(in C11BDBDs[1], null, ref po, false, false, false);
            C2ODonZGD = new double[3];
            C2ODonZGD[0] = SopeS(in C2OBDTHL[0], null, ref po, true, false, false);
            C2ODonZGD[1] = SopeS(in C2OBDTHL[1], null, ref po, true, false, false);
            C2ODonZGD[2] = SopeS(in C2OBDTHL[2], null, ref po, true, false, false);
            C2OAccZGD = new double[3];
            C2OAccZGD[0] = SopeS(in C2OBDsTHL[0], null, ref po, false, false, false);
            C2OAccZGD[1] = SopeS(in C2OBDsTHL[1], null, ref po, false, false, false);
            C2OAccZGD[2] = SopeS(in C2OBDsTHL[2], null, ref po, false, false, false);
            C3sDonZGD = new double[3];
            C3sDonZGD[0] = SopeS(in C3sBDTHL[0], null, ref po, true, false, false);
            C3sDonZGD[1] = SopeS(in C3sBDTHL[1], null, ref po, true, false, false);
            C3sDonZGD[2] = SopeS(in C3sBDTHL[2], null, ref po, true, false, false);
            C3sAccZGD = new double[3];
            C3sAccZGD[0] = SopeS(in C3sBDsTHL[0], null, ref po, false, false, false);
            C3sAccZGD[1] = SopeS(in C3sBDsTHL[1], null, ref po, false, false, false);
            C3sAccZGD[2] = SopeS(in C3sBDsTHL[2], null, ref po, false, false, false);
            //Console.WriteLine("KI : CoPh1DonZGD[0]={0}\tCoPh2DonZGD[1]={1}\tCoPhAccZGD[2]={2}\r\nCFR1DonZGD[0]={3}\tCFR2DonZGD[1]={4}\tCFRAccZGD[2]={5}\r\nsub32DonZGD[0]={6}\tsub3L2DonZGD[1]={7}\tsub3LnDonZGD[2]={8}\r\nsub3AccZGD[0]={9}\tC11DonAcc[1]={10}\tC2ODonZGD[2]={11}\r\nC2OAccZGD[0]={12}\tC3sDonZGD[1]={13}\tC3sAccZGD[2]={14}", CoPh1DonZGD[0], CoPh2DonZGD[1], CoPhAccZGD[2], CFR1DonZGD[0], CFR2DonZGD[1], CFRAccZGD[2], sub32DonZGD[0], sub3L2DonZGD[1], sub3LnDonZGD[2], sub3AccZGD[0], C11DonAcc[1], C2ODonZGD[2], C2OAccZGD[0], C3sDonZGD[1], C3sAccZGD[2]);//debug用
            CoPh1BESKT = new double[3];
            CoPh1BESKT[0] = NBOES(in CPhBD1THL[0], ref po, true) + NBOES(in CPhBDs1THL[0], ref po, true);
            CoPh1BESKT[1] = NBOES(in CPhBD1THL[1], ref po, true) + NBOES(in CPhBDs1THL[1], ref po, true);
            CoPh1BESKT[2] = NBOES(in CPhBD1THL[2], ref po, true) + NBOES(in CPhBDs1THL[2], ref po, true);
            CoPh2BESKT = new double[3];
            CoPh2BESKT[0] = NBOES(in CPhBD2THL[0], ref po, true) + NBOES(in CPhBDs2THL[0], ref po, true);
            CoPh2BESKT[1] = NBOES(in CPhBD2THL[1], ref po, true) + NBOES(in CPhBDs2THL[1], ref po, true);
            CoPh2BESKT[2] = NBOES(in CPhBD2THL[2], ref po, true) + NBOES(in CPhBDs2THL[2], ref po, true);
            CFR1BESKT = new double[3];
            CFR1BESKT[0] = NBOES(in CFRBD1THL[0], ref po, true) + NBOES(in CFRBDs1THL[0], ref po, true);
            CFR1BESKT[1] = NBOES(in CFRBD1THL[1], ref po, true) + NBOES(in CFRBDs1THL[1], ref po, true);
            CFR1BESKT[2] = NBOES(in CFRBD1THL[2], ref po, true) + NBOES(in CFRBDs1THL[2], ref po, true);
            CFR2BESKT = new double[3];
            CFR2BESKT[0] = NBOES(in CFRBD2THL[0], ref po, true) + NBOES(in CFRBDs2THL[0], ref po, true);
            CFR2BESKT[1] = NBOES(in CFRBD2THL[1], ref po, true) + NBOES(in CFRBDs2THL[1], ref po, true);
            CFR2BESKT[2] = NBOES(in CFRBD2THL[2], ref po, true) + NBOES(in CFRBDs2THL[2], ref po, true);
            sub32BESKT = new double[3];
            sub32BESKT[0] = NBOES(in sub3BD2THL[0], ref po, true) + NBOES(in sub3BDs2THL[0], ref po, true);
            sub32BESKT[1] = NBOES(in sub3BD2THL[1], ref po, true) + NBOES(in sub3BDs2THL[1], ref po, true);
            sub32BESKT[2] = NBOES(in sub3BD2THL[2], ref po, true) + NBOES(in sub3BDs2THL[2], ref po, true);
            sub3L2ESKT = new double[3];
            sub3L2ESKT[0] = NBOES(in sub3L2THL[0], ref po, false);
            sub3L2ESKT[1] = NBOES(in sub3L2THL[1], ref po, false);
            sub3L2ESKT[2] = NBOES(in sub3L2THL[2], ref po, false);
            sub3LnESKT = new double[3];
            sub3LnESKT[0] = NBOES(in sub3LnTHL[0], ref po, false);
            sub3LnESKT[1] = NBOES(in sub3LnTHL[1], ref po, false);
            sub3LnESKT[2] = NBOES(in sub3LnTHL[2], ref po, false);
            C11BE = NBOES(in C11BDBDs[0], ref po, true) + NBOES(in C11BDBDs[1], ref po, true);
            C2OBESKT = new double[3];
            C2OBESKT[0] = NBOES(in C2OBDTHL[0], ref po, true) + NBOES(in C2OBDsTHL[0], ref po, true);
            C2OBESKT[1] = NBOES(in C2OBDTHL[1], ref po, true) + NBOES(in C2OBDsTHL[1], ref po, true);
            C2OBESKT[2] = NBOES(in C2OBDTHL[2], ref po, true) + NBOES(in C2OBDsTHL[2], ref po, true);
            C3sBESKT = new double[3];
            C3sBESKT[0] = NBOES(in C3sBDTHL[0], ref po, true) + NBOES(in C3sBDsTHL[0], ref po, true);
            C3sBESKT[1] = NBOES(in C3sBDTHL[1], ref po, true) + NBOES(in C3sBDsTHL[1], ref po, true);
            C3sBESKT[2] = NBOES(in C3sBDTHL[2], ref po, true) + NBOES(in C3sBDsTHL[2], ref po, true);
            CoOLESKT = new double[3];
            CoOLESKT[0] = NBOES(in CoOLTHL[0], ref po, false);
            CoOLESKT[1] = NBOES(in CoOLTHL[1], ref po, false);
            CoOLESKT[2] = NBOES(in CoOLTHL[2], ref po, false);
            //Console.WriteLine("E : CoPh1BESKT[0]={0}\tCoPh2BESKT[1]={1}\tCFR1BESKT[2]={2}\r\nCFR2BESKT[0]={3}\tsub32BESKT[1]={4}\tsub3L2ESKT[2]={5}\r\nsub3LnESKT[0]={6}\tC11BE={7}\tC2OBESKT[1]={8}\r\nC3sBESKT[2]={9}\tCoOLESKT[0]={10}", CoPh1BESKT[0], CoPh2BESKT[1], CFR1BESKT[2], CFR2BESKT[0], sub32BESKT[1], sub3L2ESKT[2], sub3LnESKT[0], C11BE, C2OBESKT[1], C3sBESKT[2], CoOLESKT[0]);//debug用
            CoPhRYE = NBOES(in CoPhRyTHL[0], ref po, false);
            CoPhRyTHL[0] = null;
            CoPhRyTHL[1] = null;
            CoPhRyTHL[2] = null;
            CoPhRyTHL = null;
            CFRRYE = NBOES(in CFRRyTHL[0], ref po, false);
            CFRRyTHL[0] = null;
            CFRRyTHL[1] = null;
            CFRRyTHL[2] = null;
            CFRRyTHL = null;
            sub3RYE = NBOES(in sub3RyTHL[0], ref po, false);
            sub3RyTHL[0] = null;
            sub3RyTHL[1] = null;
            sub3RyTHL[2] = null;
            sub3RyTHL = null;
            int[] CoORY = LRIS(in CoO, ref po, false, true, true);
            CoORYE = NBOES(in CoORY, ref po, false);
            CoORY = null;
            //Console.WriteLine("KO : CoPhRYE={0}\tCFRRYE={1}\r\nsub3RYE={2}\tCoORYE={3}", CoPhRYE, CFRRYE, sub3RYE, CoORYE);//debug用
            C1GiHGD = new double[3];
            C1GiHGD[1] = Gsks(in CoC1[0], 0);
            C1GiHGD[2] = Gsks(in CoC1[1], 0);
            C1GiHGD[0] = C1GiHGD[1] + C1GiHGD[2];
            C1GaHGD = new double[3];
            C1GaHGD[1] = Gsks(in CoC1[0], 1);
            C1GaHGD[2] = Gsks(in CoC1[1], 1);
            C1GaHGD[0] = C1GaHGD[1] + C1GaHGD[2];
            C1GtFHGD = new double[3];
            C1GtFHGD[1] = Gsks(in CoC1[0], 2);
            C1GtFHGD[2] = Gsks(in CoC1[1], 2);
            C1GtFHGD[0] = C1GtFHGD[1] + C1GtFHGD[2];
            C1GenHGD = new double[3];
            C1GenHGD[1] = Gsks(in CoC1[0], 3);
            C1GenHGD[2] = Gsks(in CoC1[1], 3);
            C1GenHGD[0] = C1GenHGD[1] + C1GenHGD[2];
            C2GiHGD = new double[3];
            C2GiHGD[1] = Gsks(in CoC2[0], 0);
            C2GiHGD[2] = Gsks(in CoC2[1], 0);
            C2GiHGD[0] = C2GiHGD[1] + C2GiHGD[2];
            C2GaHGD = new double[3];
            C2GaHGD[1] = Gsks(in CoC2[0], 1);
            C2GaHGD[2] = Gsks(in CoC2[1], 1);
            C2GaHGD[0] = C2GaHGD[1] + C2GaHGD[2];
            C2GtFHGD = new double[3];
            C2GtFHGD[1] = Gsks(in CoC2[0], 2);
            C2GtFHGD[2] = Gsks(in CoC2[1], 2);
            C2GtFHGD[0] = C2GtFHGD[1] + C2GtFHGD[2];
            C2GenHGD = new double[3];
            C2GenHGD[1] = Gsks(in CoC2[0], 3);
            C2GenHGD[2] = Gsks(in CoC2[1], 3);
            C2GenHGD[0] = C2GenHGD[1] + C2GenHGD[2];
            C3GiHGD = new double[3];
            C3GiHGD[1] = Gsks(in CoC3[0], 0);
            C3GiHGD[2] = Gsks(in CoC3[1], 0);
            C3GiHGD[0] = C3GiHGD[1] + C3GiHGD[2];
            C3GaHGD = new double[3];
            C3GaHGD[1] = Gsks(in CoC3[0], 1);
            C3GaHGD[2] = Gsks(in CoC3[1], 1);
            C3GaHGD[0] = C3GaHGD[1] + C3GaHGD[2];
            C3GtFHGD = new double[3];
            C3GtFHGD[1] = Gsks(in CoC3[0], 2);
            C3GtFHGD[2] = Gsks(in CoC3[1], 2);
            C3GtFHGD[0] = C3GtFHGD[1] + C3GtFHGD[2];
            C3GenHGD = new double[3];
            C3GenHGD[1] = Gsks(in CoC4[0], 3);
            C3GenHGD[2] = Gsks(in CoC4[1], 3);
            C3GenHGD[0] = C3GenHGD[1] + C3GenHGD[2];
            C4GiHGD = new double[3];
            C4GiHGD[1] = Gsks(in CoC4[0], 0);
            C4GiHGD[2] = Gsks(in CoC4[1], 0);
            C4GiHGD[0] = C4GiHGD[1] + C4GiHGD[2];
            C4GaHGD = new double[3];
            C4GaHGD[1] = Gsks(in CoC4[0], 1);
            C4GaHGD[2] = Gsks(in CoC4[1], 1);
            C4GaHGD[0] = C4GaHGD[1] + C4GaHGD[2];
            C4GtFHGD = new double[3];
            C4GtFHGD[1] = Gsks(in CoC4[0], 2);
            C4GtFHGD[2] = Gsks(in CoC4[1], 2);
            C4GtFHGD[0] = C4GtFHGD[1] + C4GtFHGD[2];
            C4GenHGD = new double[3];
            C4GenHGD[1] = Gsks(in CoC4[0], 3);
            C4GenHGD[2] = Gsks(in CoC4[1], 3);
            C4GenHGD[0] = C4GenHGD[1] + C4GenHGD[2];
            C5GiHGD = new double[3];
            C5GiHGD[1] = Gsks(in CoC5[0], 0);
            C5GiHGD[2] = Gsks(in CoC5[1], 0);
            C5GiHGD[0] = C5GiHGD[1] + C5GiHGD[2];
            C5GaHGD = new double[3];
            C5GaHGD[1] = Gsks(in CoC5[0], 1);
            C5GaHGD[2] = Gsks(in CoC5[1], 1);
            C5GaHGD[0] = C5GaHGD[1] + C5GaHGD[2];
            C5GtFHGD = new double[3];
            C5GtFHGD[1] = Gsks(in CoC5[0], 2);
            C5GtFHGD[2] = Gsks(in CoC5[1], 2);
            C5GtFHGD[0] = C5GtFHGD[1] + C5GtFHGD[2];
            C5GenHGD = new double[3];
            C5GenHGD[1] = Gsks(in CoC5[0], 3);
            C5GenHGD[2] = Gsks(in CoC5[1], 3);
            C5GenHGD[0] = C5GenHGD[1] + C5GenHGD[2];
            C6GiHGD = new double[3];
            C6GiHGD[1] = Gsks(in CoC6[0], 0);
            C6GiHGD[2] = Gsks(in CoC6[1], 0);
            C6GiHGD[0] = C6GiHGD[1] + C6GiHGD[2];
            C6GaHGD = new double[3];
            C6GaHGD[1] = Gsks(in CoC6[0], 1);
            C6GaHGD[2] = Gsks(in CoC6[1], 1);
            C6GaHGD[0] = C6GaHGD[1] + C6GaHGD[2];
            C6GtFHGD = new double[3];
            C6GtFHGD[1] = Gsks(in CoC6[0], 2);
            C6GtFHGD[2] = Gsks(in CoC6[1], 2);
            C6GtFHGD[0] = C6GtFHGD[1] + C6GtFHGD[2];
            C6GenHGD = new double[3];
            C6GenHGD[1] = Gsks(in CoC6[0], 3);
            C6GenHGD[2] = Gsks(in CoC6[1], 3);
            C6GenHGD[0] = C6GenHGD[1] + C6GenHGD[2];
            CoOGiHGD = new double[3];
            CoOGiHGD[1] = Gsks(in CoO[0], 0);
            CoOGiHGD[2] = Gsks(in CoO[1], 0);
            CoOGiHGD[0] = CoOGiHGD[1] + CoOGiHGD[2];
            CoOGaHGD = new double[3];
            CoOGaHGD[1] = Gsks(in CoO[0], 1);
            CoOGaHGD[2] = Gsks(in CoO[1], 1);
            CoOGaHGD[0] = CoOGaHGD[1] + CoOGaHGD[2];
            CoOGtFHGD = new double[3];
            CoOGtFHGD[1] = Gsks(in CoO[0], 2);
            CoOGtFHGD[2] = Gsks(in CoO[1], 2);
            CoOGtFHGD[0] = CoOGtFHGD[1] + CoOGtFHGD[2];
            CoOGenHGD = new double[3];
            CoOGenHGD[1] = Gsks(in CoO[0], 3);
            CoOGenHGD[2] = Gsks(in CoO[1], 3);
            CoOGenHGD[0] = CoOGenHGD[1] + CoOGenHGD[2];
            //Console.WriteLine("I : C1GiHGD[0]={0}\tC1GaHGD[1]={1}\tC1GtFHGD[2]={2}\r\nC1GenHGD[0]={3}\tC2GiHGD[1]={4}\tC2GaHGD[2]={5}\r\nC2GtFHGD[0]={6}\tC2GenHGD[1]={7}\tC3GiHGD[2]={8}\r\nC3GaHGD[0]={9}\tC3GtFHGD[1]={10}\tC3GenHGD[2]={11}\r\nC4GiHGD[0]={12}\tC4GaHGD[1]={13}\tC4GtFHGD[2]={14}\r\nC4GenHGD[0]={15}\tC5GiHGD[1]={16}\tC5GaHGD[2]={17}\r\nC5GtFHGD[0]={18}\tC5GenHGD[1]={19}\tC6GiHGD[2]={20}\r\nC6GaHGD[0]={21}\tC6GtFHGD[1]={22}\tC6GenHGD[2]={23}", C1GiHGD[0], C1GaHGD[1], C1GtFHGD[2], C1GenHGD[0], C2GiHGD[1], C2GaHGD[2], C2GtFHGD[0], C2GenHGD[1], C3GiHGD[2], C3GaHGD[0], C3GtFHGD[1], C3GenHGD[2], C4GiHGD[0], C4GaHGD[1], C4GtFHGD[2], C4GenHGD[0], C5GiHGD[1], C5GaHGD[2], C5GtFHGD[0], C5GenHGD[1], C6GiHGD[2], C6GaHGD[0], C6GtFHGD[1], C6GenHGD[2]);//debug用
            CoPhGiHGD = new double[3];
            CoPhGiHGD[1] = GsksS(in CoPhH, ref po, 0);
            CoPhGiHGD[2] = GsksS(in CoPhL, ref po, 0);
            CoPhGiHGD[0] = CoPhGiHGD[1] + CoPhGiHGD[2];
            CoPhGaHGD = new double[3];
            CoPhGaHGD[1] = GsksS(in CoPhH, ref po, 1);
            CoPhGaHGD[2] = GsksS(in CoPhL, ref po, 1);
            CoPhGaHGD[0] = CoPhGaHGD[1] + CoPhGaHGD[2];
            CoPhGtFHGD = new double[3];
            CoPhGtFHGD[1] = GsksS(in CoPhH, ref po, 2);
            CoPhGtFHGD[2] = GsksS(in CoPhL, ref po, 2);
            CoPhGtFHGD[0] = CoPhGtFHGD[1] + CoPhGtFHGD[2];
            CoPhGenHGD = new double[3];
            CoPhGenHGD[1] = GsksS(in CoPhH, ref po, 3);
            CoPhGenHGD[2] = GsksS(in CoPhL, ref po, 3);
            CoPhGenHGD[0] = CoPhGenHGD[1] + CoPhGenHGD[2];
            CFRGiHGD = new double[3];
            CFRGiHGD[1] = GsksS(in CoFuRiH, ref po, 0);
            CFRGiHGD[2] = GsksS(in CoFuRiL, ref po, 0);
            CFRGiHGD[0] = CFRGiHGD[1] + CFRGiHGD[2];
            CFRGaHGD = new double[3];
            CFRGaHGD[1] = GsksS(in CoFuRiH, ref po, 1);
            CFRGaHGD[2] = GsksS(in CoFuRiL, ref po, 1);
            CFRGaHGD[0] = CFRGaHGD[1] + CFRGaHGD[2];
            CFRGtFHGD = new double[3];
            CFRGtFHGD[1] = GsksS(in CoFuRiH, ref po, 2);
            CFRGtFHGD[2] = GsksS(in CoFuRiL, ref po, 2);
            CFRGtFHGD[0] = CFRGtFHGD[1] + CFRGtFHGD[2];
            CFRGenHGD = new double[3];
            CFRGenHGD[1] = GsksS(in CoFuRiH, ref po, 3);
            CFRGenHGD[2] = GsksS(in CoFuRiL, ref po, 3);
            CFRGenHGD[0] = CFRGenHGD[1] + CFRGenHGD[2];
            //Console.WriteLine("SU : CoPhGiHGD[0]={0}\rCoPhGaHGD[1]={1}\tCoPhGtFHGD[2]={2}\r\nCoPhGenHGD[0]={3}\tCFRGiHGD[1]={4}\rCFRGaHGD[2]={5}\tCFRGtFHGD[0]={6}\r\nCFRGenHGD[0]={7}", CoPhGiHGD[0], CoPhGaHGD[1], CoPhGtFHGD[2], CoPhGenHGD[0], CFRGiHGD[1], CFRGaHGD[2], CFRGtFHGD[0], CFRGenHGD[0]);//debug用
            dmdpDFT = new double[3];
            SGKC.Tensor tns = new SGKC.Tensor(gl._dmdp);
            dmdpDFT[0] = tns.HLSLU(true);
            dmdpDFT[1] = tns.FbN();
            dmdpDFT[2] = tns.TSeki();
            dqctDFT = new double[3];
            tns = new SGKC.Tensor(gl._dqct);
            dqctDFT[0] = tns.HLSLU(true);
            dqctDFT[1] = tns.FbN();
            dqctDFT[2] = tns.TSeki();
            orgtDFT = new double[3];
            tns = new SGKC.Tensor(gl._orgt);
            orgtDFT[0] = tns.HLSLU(true);
            orgtDFT[1] = tns.FbN();
            orgtDFT[2] = tns.TSeki();
            tns = null;
            orgeEW = new double[2];
            orgeEW[0] = SGKC.Tensor.EucNs(gl._orge);
            orgeEW[1] = gl._orge[0] + gl._orge[1] + gl._orge[2];
            //Console.WriteLine("KI : dmdpDFT[0]={0}\tdqctDFT[1]={1}\r\norgtDFT[2]={2}\torgeEW[0]={3}", dmdpDFT[0], dqctDFT[1], orgtDFT[2], orgeEW[0]);//debug用
            C123OAc = new double[4];
            C123OAc[0] = APTcS(in CoC1, ref po, false);
            C123OAc[1] = APTcS(in CoC2, ref po, false);
            C123OAc[2] = APTcS(in CoC3, ref po, false);
            C123OAc[3] = APTcS(in CoO, ref po, false);
            CoPhAcGDZ = new double[3];
            CoPhAcGDZ[0] = APTcS(in CoPhH, ref po, false);
            CoPhAcGDZ[1] = APTcS(in CoPhL, ref po, false);
            CoPhAcGDZ[2] = APTcS(in CoPhta, ref po, false);
            CFRAcGDZ = new double[3];
            CFRAcGDZ[0] = APTcS(in CoFuRiH, ref po, false);
            CFRAcGDZ[1] = APTcS(in CoFuRiL, ref po, false);
            CFRAcGDZ[2] = APTcS(in CFRta, ref po, false);
            sub3AcGDZ = new double[3];
            sub3AcGDZ[0] = APTcS(in sub3H, ref po, false);
            sub3AcGDZ[1] = APTcS(in sub3L, ref po, false);
            sub3AcGDZ[2] = APTcS(in sub3ta, ref po, false);
            CFRhAcGDZ = new double[3];
            CFRhAcGDZ[0] = APTcS(in CoFuRiH, ref po, true);
            CFRhAcGDZ[1] = APTcS(in CoFuRiL, ref po, true);
            CFRhAcGDZ[2] = APTcS(in CFRta, ref po, true);
            // Console.WriteLine("I : C123OAc[0]={0}\tCoPhAcGDZ[1]={1}\tCFRAcGDZ[2]={2}\r\nsub3AcGDZ[0]={3}\tCFRhAcGDZ[1]={4}", C123OAc[0], CoPhAcGDZ[1], CFRAcGDZ[2], sub3AcGDZ[0], CFRhAcGDZ[1]);//debug用
            EPDFT = new double[3];
            tns = new SGKC.Tensor(gl._Epol);
            EPDFT[0] = tns.HLSLU(true);
            EPDFT[1] = tns.FbN();
            EPDFT[2] = tns.TSeki();
            APDFT = new double[3];
            tns = new SGKC.Tensor(gl._Apol);
            APDFT[0] = tns.HLSLU(true);
            APDFT[1] = tns.FbN();
            APDFT[2] = tns.TSeki();
            tns = null;
            //Console.WriteLine("KO : EPDFT[0]={0}\tEPDFT[1]={1}\r\nAPDFT[1]={2}\tAPDFT[2]={3}", EPDFT[0], EPDFT[1], APDFT[1], APDFT[2]);//debug用
            mwfcS = gl._mwfc[0] + gl._mwfc[1] + gl._mwfc[2] + gl._mwfc[3] + gl._mwfc[4] + gl._mwfc[5] + gl._mwfc[6] + gl._mwfc[7] + gl._mwfc[8];
            dvpE = SGKC.Tensor.EucNs(gl._dvp);
            //Console.WriteLine("KO : mwfcS={0}\tdvpE={1}", mwfcS, dvpE);//debug用
            TIRke = new double[7];
            TIRke[0] = IRkeS(in CoPhta, ref po);
            TIRke[1] = IRkeS(in CFRta, ref po);
            TIRke[2] = IRkeS(in sub3ta, ref po);
            TIRke[3] = IRkeS(in CoO, ref po);
            TIRke[4] = IRkeS(in CoC1, ref po);
            TIRke[5] = IRkeS(in CoC2, ref po);
            TIRke[6] = IRkeS(in CoC3, ref po);
            h2IRke = new double[7];
            h2IRke[0] = IRkeS(in CoPhta, ref po, 0, 200);
            h2IRke[1] = IRkeS(in CFRta, ref po, 0, 200);
            h2IRke[2] = IRkeS(in sub3ta, ref po, 0, 200);
            h2IRke[3] = IRkeS(in CoO, ref po, 0, 200);
            h2IRke[4] = IRkeS(in CoC1, ref po, 0, 200);
            h2IRke[5] = IRkeS(in CoC2, ref po, 0, 200);
            h2IRke[6] = IRkeS(in CoC3, ref po, 0, 200);
            h5IRke = new double[7];
            h5IRke[0] = IRkeS(in CoPhta, ref po, 200, 500);
            h5IRke[1] = IRkeS(in CFRta, ref po, 200, 500);
            h5IRke[2] = IRkeS(in sub3ta, ref po, 200, 500);
            h5IRke[3] = IRkeS(in CoO, ref po, 200, 500);
            h5IRke[4] = IRkeS(in CoC1, ref po, 200, 500);
            h5IRke[5] = IRkeS(in CoC2, ref po, 200, 500);
            h5IRke[6] = IRkeS(in CoC3, ref po, 200, 500);
            kIRke = new double[7];
            kIRke[0] = IRkeS(in CoPhta, ref po, 500, 1000);
            kIRke[1] = IRkeS(in CFRta, ref po, 500, 1000);
            kIRke[2] = IRkeS(in sub3ta, ref po, 500, 1000);
            kIRke[3] = IRkeS(in CoO, ref po, 500, 1000);
            kIRke[4] = IRkeS(in CoC1, ref po, 500, 1000);
            kIRke[5] = IRkeS(in CoC2, ref po, 500, 1000);
            kIRke[6] = IRkeS(in CoC3, ref po, 500, 1000);
            khIRke = new double[7];
            khIRke[0] = IRkeS(in CoPhta, ref po, 1000, 1500);
            khIRke[1] = IRkeS(in CFRta, ref po, 1000, 1500);
            khIRke[2] = IRkeS(in sub3ta, ref po, 1000, 1500);
            khIRke[3] = IRkeS(in CoO, ref po, 1000, 1500);
            khIRke[4] = IRkeS(in CoC1, ref po, 1000, 1500);
            khIRke[5] = IRkeS(in CoC2, ref po, 1000, 1500);
            khIRke[6] = IRkeS(in CoC3, ref po, 1000, 1500);
            k2IRke = new double[7];
            k2IRke[0] = IRkeS(in CoPhta, ref po, 1500, 2000);
            k2IRke[1] = IRkeS(in CFRta, ref po, 1500, 2000);
            k2IRke[2] = IRkeS(in sub3ta, ref po, 1500, 2000);
            k2IRke[3] = IRkeS(in CoO, ref po, 1500, 2000);
            k2IRke[4] = IRkeS(in CoC1, ref po, 1500, 2000);
            k2IRke[5] = IRkeS(in CoC2, ref po, 1500, 2000);
            k2IRke[6] = IRkeS(in CoC3, ref po, 1500, 2000);
            iIRke = new double[7];
            iIRke[0] = IRkeS(in CoPhta, ref po, 2000, null);
            iIRke[1] = IRkeS(in CFRta, ref po, 2000, null);
            iIRke[2] = IRkeS(in sub3ta, ref po, 2000, null);
            iIRke[3] = IRkeS(in CoO, ref po, 2000, null);
            iIRke[4] = IRkeS(in CoC1, ref po, 2000, null);
            iIRke[5] = IRkeS(in CoC2, ref po, 2000, null);
            iIRke[6] = IRkeS(in CoC3, ref po, 2000, null);
            //Console.WriteLine("E : TIRke[0]={0}\th2IRke[1]={1}\th5IRke[2]={2}\r\nkIRke[3]={3}\tkhIRke[4]={4}\tk2IRke[5]={5}\r\niIRke[6]={6}", TIRke[0], h2IRke[1], h5IRke[2], kIRke[3], khIRke[4], k2IRke[5], iIRke[6]);//debug用
            IRAF = new double[6];
            dtemp2 = 0.0;
            dtemp3 = 0.0;
            double[] IRAFL = new double[6] { 200.0, 500.0, 1000.0, 1500.0, 2000.0, double.MaxValue };
            int cnt4 = 0;
            for (cnt = 0; cnt < gl._dof; cnt++)
            {
                if (gl._ncfrq[cnt] < IRAFL[cnt4])
                {
                    dtemp2 += gl._ncfrq[cnt] * gl._ncii[cnt];
                    dtemp3 += gl._ncii[cnt];
                }
                else
                {
                    if (dtemp3 == 0.0) IRAF[cnt4] = 0;
                    else IRAF[cnt4] = dtemp2 / dtemp3;
                    dtemp2 = 0.0;
                    dtemp3 = 0.0;
                    cnt4++;
                }
            }
            if (dtemp3 == 0.0) IRAF[5] = 0;
            else IRAF[5] = dtemp2 / dtemp3;
            //Console.WriteLine("KI : IRAF[0]={0}\tIRAF[1]={1}\tIRAF[2]={2}\r\nIRAF[3]={3}\tIRAF[4]={4}\tIRAF[5]={5}", IRAF[0], IRAF[1], IRAF[2], IRAF[3], IRAF[4], IRAF[5]);//debug用
            paxDFT = new double[3];
            tns = new SGKC.Tensor(gl._pax);
            paxDFT[0] = tns.HLSLU(true);
            paxDFT[1] = tns.FbN();
            paxDFT[2] = tns.TSeki();
            tns = null;
            rotts = gl._rott[0] + gl._rott[1] + gl._rott[2];
            //Console.WriteLine("A : paxDFT[0]={0}\tpaxDFT[1]={1}\tpaxDFT[2]={2}\r\nrotts={3}", paxDFT[0], paxDFT[1], paxDFT[2], rotts);//debug用
            lfvS = new double[5] { 0.0, 0.0, 0.0, 0.0, 0.0 };
            for (cnt = 0; cnt < gl._ifvn; cnt++)
            {
                lfvS[0] += gl._lfve[cnt];
                lfvS[1] += gl._lfvcv[cnt];
                lfvS[2] += gl._lfvs[cnt];
                lfvS[3] += gl._lnqvbs[cnt];
                lfvS[4] += gl._lnqvvs[cnt];
            }
            //Console.WriteLine("A : lfvS[0]={0}\tlfvS[1]={1}\tlfvS[2]={2}\r\nlfvS[3]={3}\tlfvS[4]={4}", lfvS[0], lfvS[1], lfvS[2], lfvS[3], lfvS[4]);//debug用
            double SR2 = 140.0 * Math.Sqrt(3.0);
            double SR4 = SR2 * 2;
            double SR6 = SR2 * 3;
            double SR8 = SR2 * 4;
            double[] C3Hsoco = new double[3] { gl._soco[CoC3[0], 0] * 100.0, gl._soco[CoC3[0], 1] * 100.0, gl._soco[CoC3[0], 2] * 100.0 };
            //double[] C3Hdico = new double[3] { gl._dico[CoC3[0], 0] * 100.0, gl._dico[CoC3[0], 1] * 100.0, gl._dico[CoC3[0], 2] * 100.0 };
            double[] C3Lsoco = new double[3] { gl._soco[CoC3[1], 0] * 100.0, gl._soco[CoC3[1], 1] * 100.0, gl._soco[CoC3[1], 2] * 100.0 };
            //double[] C3Ldico = new double[3] { gl._dico[CoC3[1], 0] * 100.0, gl._dico[CoC3[1], 1] * 100.0, gl._dico[CoC3[1], 2] * 100.0 };
            Vsub3vdWC32RKTS = new double[3];
            Vsub3vdWC32RKTS[0] = VolBS(in sub3H, C3Hsoco, SR2, ref po, 0);
            Vsub3vdWC32RKTS[1] = VolBS(in sub3L, C3Lsoco, SR2, ref po, 0);
            Vsub3vdWC32RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR2, ref po, 0) + VolBS(in sub3ta, C3Lsoco, SR2, ref po, 0);
            Vsub3vdWC34RKTS = new double[3];
            Vsub3vdWC34RKTS[0] = VolBS(in sub3H, C3Hsoco, SR4, ref po, 0);
            Vsub3vdWC34RKTS[1] = VolBS(in sub3L, C3Lsoco, SR4, ref po, 0);
            Vsub3vdWC34RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR4, ref po, 0) + VolBS(in sub3ta, C3Lsoco, SR4, ref po, 0);
            Vsub3vdWC36RKTS = new double[3];
            Vsub3vdWC36RKTS[0] = VolBS(in sub3H, C3Hsoco, SR6, ref po, 0);
            Vsub3vdWC36RKTS[1] = VolBS(in sub3L, C3Lsoco, SR6, ref po, 0);
            Vsub3vdWC36RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR6, ref po, 0) + VolBS(in sub3ta, C3Lsoco, SR6, ref po, 0);
            Vsub3vdWC38RKTS = new double[3];
            Vsub3vdWC38RKTS[0] = VolBS(in sub3H, C3Hsoco, SR8, ref po, 0);
            Vsub3vdWC38RKTS[1] = VolBS(in sub3L, C3Lsoco, SR8, ref po, 0);
            Vsub3vdWC38RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR8, ref po, 0) + VolBS(in sub3ta, C3Lsoco, SR8, ref po, 0);
            Vsub3ACC32RKTS = new double[3];
            Vsub3ACC32RKTS[0] = VolBS(in sub3H, C3Hsoco, SR2, ref po, 1);
            Vsub3ACC32RKTS[1] = VolBS(in sub3L, C3Lsoco, SR2, ref po, 1);
            Vsub3ACC32RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR2, ref po, 1) + VolBS(in sub3ta, C3Lsoco, SR2, ref po, 1);
            Vsub3ACC34RKTS = new double[3];
            Vsub3ACC34RKTS[0] = VolBS(in sub3H, C3Hsoco, SR4, ref po, 1);
            Vsub3ACC34RKTS[1] = VolBS(in sub3L, C3Lsoco, SR4, ref po, 1);
            Vsub3ACC34RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR4, ref po, 1) + VolBS(in sub3ta, C3Lsoco, SR4, ref po, 1);
            Vsub3ACC36RKTS = new double[3];
            Vsub3ACC36RKTS[0] = VolBS(in sub3H, C3Hsoco, SR6, ref po, 1);
            Vsub3ACC36RKTS[1] = VolBS(in sub3L, C3Lsoco, SR6, ref po, 1);
            Vsub3ACC36RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR6, ref po, 1) + VolBS(in sub3ta, C3Lsoco, SR6, ref po, 1);
            Vsub3ACC38RKTS = new double[3];
            Vsub3ACC38RKTS[0] = VolBS(in sub3H, C3Hsoco, SR8, ref po, 1);
            Vsub3ACC38RKTS[1] = VolBS(in sub3L, C3Lsoco, SR8, ref po, 1);
            Vsub3ACC38RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR8, ref po, 1) + VolBS(in sub3ta, C3Lsoco, SR8, ref po, 1);
            Vsub3AEC32RKTS = new double[3];
            Vsub3AEC32RKTS[0] = VolBS(in sub3H, C3Hsoco, SR2, ref po, 2);
            Vsub3AEC32RKTS[1] = VolBS(in sub3L, C3Lsoco, SR2, ref po, 2);
            Vsub3AEC32RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR2, ref po, 2) + VolBS(in sub3ta, C3Lsoco, SR2, ref po, 2);
            Vsub3AEC34RKTS = new double[3];
            Vsub3AEC34RKTS[0] = VolBS(in sub3H, C3Hsoco, SR4, ref po, 2);
            Vsub3AEC34RKTS[1] = VolBS(in sub3L, C3Lsoco, SR4, ref po, 2);
            Vsub3AEC34RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR4, ref po, 2) + VolBS(in sub3ta, C3Lsoco, SR4, ref po, 2);
            Vsub3AEC36RKTS = new double[3];
            Vsub3AEC36RKTS[0] = VolBS(in sub3H, C3Hsoco, SR6, ref po, 2);
            Vsub3AEC36RKTS[1] = VolBS(in sub3L, C3Lsoco, SR6, ref po, 2);
            Vsub3AEC36RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR6, ref po, 2) + VolBS(in sub3ta, C3Lsoco, SR6, ref po, 2);
            Vsub3AEC38RKTS = new double[3];
            Vsub3AEC38RKTS[0] = VolBS(in sub3H, C3Hsoco, SR8, ref po, 2);
            Vsub3AEC38RKTS[1] = VolBS(in sub3L, C3Lsoco, SR8, ref po, 2);
            Vsub3AEC38RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR8, ref po, 2) + VolBS(in sub3ta, C3Lsoco, SR8, ref po, 2);
            Vsub3IEC32RKTS = new double[3];
            Vsub3IEC32RKTS[0] = VolBS(in sub3H, C3Hsoco, SR2, ref po, 3);
            Vsub3IEC32RKTS[1] = VolBS(in sub3L, C3Lsoco, SR2, ref po, 3);
            Vsub3IEC32RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR2, ref po, 3) + VolBS(in sub3ta, C3Lsoco, SR2, ref po, 3);
            Vsub3IEC34RKTS = new double[3];
            Vsub3IEC34RKTS[0] = VolBS(in sub3H, C3Hsoco, SR4, ref po, 3);
            Vsub3IEC34RKTS[1] = VolBS(in sub3L, C3Lsoco, SR4, ref po, 3);
            Vsub3IEC34RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR4, ref po, 3) + VolBS(in sub3ta, C3Lsoco, SR4, ref po, 3);
            Vsub3IEC36RKTS = new double[3];
            Vsub3IEC36RKTS[0] = VolBS(in sub3H, C3Hsoco, SR6, ref po, 3);
            Vsub3IEC36RKTS[1] = VolBS(in sub3L, C3Lsoco, SR6, ref po, 3);
            Vsub3IEC36RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR6, ref po, 3) + VolBS(in sub3ta, C3Lsoco, SR6, ref po, 3);
            Vsub3IEC38RKTS = new double[3];
            Vsub3IEC38RKTS[0] = VolBS(in sub3H, C3Hsoco, SR8, ref po, 3);
            Vsub3IEC38RKTS[1] = VolBS(in sub3L, C3Lsoco, SR8, ref po, 3);
            Vsub3IEC38RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR8, ref po, 3) + VolBS(in sub3ta, C3Lsoco, SR8, ref po, 3);
            Vsub3IAC32RKTS = new double[3];
            Vsub3IAC32RKTS[0] = VolBS(in sub3H, C3Hsoco, SR2, ref po, 4);
            Vsub3IAC32RKTS[1] = VolBS(in sub3L, C3Lsoco, SR2, ref po, 4);
            Vsub3IAC32RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR2, ref po, 4) + VolBS(in sub3ta, C3Lsoco, SR2, ref po, 4);
            Vsub3IAC34RKTS = new double[3];
            Vsub3IAC34RKTS[0] = VolBS(in sub3H, C3Hsoco, SR4, ref po, 4);
            Vsub3IAC34RKTS[1] = VolBS(in sub3L, C3Lsoco, SR4, ref po, 4);
            Vsub3IAC34RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR4, ref po, 4) + VolBS(in sub3ta, C3Lsoco, SR4, ref po, 4);
            Vsub3IAC36RKTS = new double[3];
            Vsub3IAC36RKTS[0] = VolBS(in sub3H, C3Hsoco, SR6, ref po, 4);
            Vsub3IAC36RKTS[1] = VolBS(in sub3L, C3Lsoco, SR6, ref po, 4);
            Vsub3IAC36RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR6, ref po, 4) + VolBS(in sub3ta, C3Lsoco, SR6, ref po, 4);
            Vsub3IAC38RKTS = new double[3];
            Vsub3IAC38RKTS[0] = VolBS(in sub3H, C3Hsoco, SR8, ref po, 4);
            Vsub3IAC38RKTS[1] = VolBS(in sub3L, C3Lsoco, SR8, ref po, 4);
            Vsub3IAC38RKTS[2] = VolBS(in sub3ta, C3Hsoco, SR8, ref po, 4) + VolBS(in sub3ta, C3Lsoco, SR8, ref po, 4);
            //Console.WriteLine("E : Vsub3vdWC32RKTS[0]={0}\tVsub3vdWC34RKTS[1]={1}\tVsub3vdWC36RKTS[2]={2}\r\nVsub3vdWC38RKTS[0]={3}\tVsub3ACC32RKTS[1]={4}\tVsub3ACC34RKTS[2]={5}\r\nVsub3ACC36RKTS[0]={6}\tVsub3ACC38RKTS[1]={7}\tVsub3AEC32RKTS[2]={8}\r\nVsub3AEC34RKTS[0]={9}\tVsub3AEC36RKTS[1]={10}\tVsub3AEC38RKTS[2]={11}\r\nVsub3IEC32RKTS[0]={12}\tVsub3IEC34RKTS[1]={13}\tVsub3IEC36RKTS[2]={14}\r\nVsub3IEC38RKTS[0]={15}\tVsub3IAC32RKTS[1]={16}\tVsub3IAC34RKTS[2]={17}\r\nVsub3IAC36RKTS[0]={18}\tVsub3IAC38RKTS[1]={19}", Vsub3vdWC32RKTS[0], Vsub3vdWC34RKTS[1], Vsub3vdWC36RKTS[2], Vsub3vdWC38RKTS[0], Vsub3ACC32RKTS[1], Vsub3ACC34RKTS[2], Vsub3ACC36RKTS[0], Vsub3ACC38RKTS[1], Vsub3AEC32RKTS[2], Vsub3AEC34RKTS[0], Vsub3AEC36RKTS[1], Vsub3AEC38RKTS[2], Vsub3IEC32RKTS[0], Vsub3IEC34RKTS[1], Vsub3IEC36RKTS[2], Vsub3IEC38RKTS[0], Vsub3IAC32RKTS[1], Vsub3IAC34RKTS[2], Vsub3IAC36RKTS[0], Vsub3IAC38RKTS[1]);//debug用
            double[] CoOcsoco = new double[3] { (gl._soco[CoO[0], 0] + gl._soco[CoO[1], 0]) / 50.0, (gl._soco[CoO[0], 1] + gl._soco[CoO[1], 1]) / 50.0, (gl._soco[CoO[0], 2] + gl._soco[CoO[1], 2]) / 50.0 };
            //double[] CoOcdico = new double[3] { (gl._dico[CoO[0], 0] + gl._dico[CoO[1], 0]) / 50.0, (gl._dico[CoO[0], 1] + gl._dico[CoO[1], 1]) / 50.0, (gl._dico[CoO[0], 2] + gl._dico[CoO[1], 2]) / 50.0 };
            Vsub3vdWOc = new double[4];
            Vsub3vdWOc[0] = VolBS(in sub3ta, CoOcsoco, SR2, ref po, 0);
            Vsub3vdWOc[1] = VolBS(in sub3ta, CoOcsoco, SR4, ref po, 0);
            Vsub3vdWOc[2] = VolBS(in sub3ta, CoOcsoco, SR6, ref po, 0);
            Vsub3vdWOc[3] = VolBS(in sub3ta, CoOcsoco, SR8, ref po, 0);
            Vsub3ACOc = new double[4];
            Vsub3ACOc[0] = VolBS(in sub3ta, CoOcsoco, SR2, ref po, 1);
            Vsub3ACOc[1] = VolBS(in sub3ta, CoOcsoco, SR4, ref po, 1);
            Vsub3ACOc[2] = VolBS(in sub3ta, CoOcsoco, SR6, ref po, 1);
            Vsub3ACOc[3] = VolBS(in sub3ta, CoOcsoco, SR8, ref po, 1);
            Vsub3AEOc = new double[4];
            Vsub3AEOc[0] = VolBS(in sub3ta, CoOcsoco, SR2, ref po, 2);
            Vsub3AEOc[1] = VolBS(in sub3ta, CoOcsoco, SR4, ref po, 2);
            Vsub3AEOc[2] = VolBS(in sub3ta, CoOcsoco, SR6, ref po, 2);
            Vsub3AEOc[3] = VolBS(in sub3ta, CoOcsoco, SR8, ref po, 2);
            Vsub3IEOc = new double[4];
            Vsub3IEOc[0] = VolBS(in sub3ta, CoOcsoco, SR2, ref po, 3);
            Vsub3IEOc[1] = VolBS(in sub3ta, CoOcsoco, SR4, ref po, 3);
            Vsub3IEOc[2] = VolBS(in sub3ta, CoOcsoco, SR6, ref po, 3);
            Vsub3IEOc[3] = VolBS(in sub3ta, CoOcsoco, SR8, ref po, 3);
            Vsub3IAOc = new double[4];
            Vsub3IAOc[0] = VolBS(in sub3ta, CoOcsoco, SR2, ref po, 4);
            Vsub3IAOc[1] = VolBS(in sub3ta, CoOcsoco, SR4, ref po, 4);
            Vsub3IAOc[2] = VolBS(in sub3ta, CoOcsoco, SR6, ref po, 4);
            Vsub3IAOc[3] = VolBS(in sub3ta, CoOcsoco, SR8, ref po, 4);
            //Console.WriteLine("A : Vsub3vdWOc[0]={0}\tVsub3ACOc[1]={1}\tVsub3AEOc[2]={2}\r\nVsub3IEOc[3]={3}\tVsub3IAOc[0]={4}", Vsub3vdWOc[0], Vsub3ACOc[1], Vsub3AEOc[2], Vsub3IEOc[3], Vsub3IAOc[0]);//debug用
            EnPsub3Oc = new double[6];
            EnPsub3Oc[0] = EnPoI(in sub3ta, CoOcsoco, ref po, 0);
            EnPsub3Oc[1] = EnPoI(in sub3ta, CoOcsoco, ref po, 1);
            EnPsub3Oc[2] = EnPoI(in sub3ta, CoOcsoco, ref po, 2);
            EnPsub3Oc[3] = EnPoI(in sub3ta, CoOcsoco, ref po, 3);
            EnPsub3Oc[4] = EnPoI(in sub3ta, CoOcsoco, ref po, 4);
            EnPsub3Oc[5] = EnPoI(in sub3ta, CoOcsoco, ref po, 5);
            EnPsub3Oc2 = new double[6];
            EnPsub3Oc2[0] = EnPoI2(in sub3ta, CoOcsoco, ref po, 0);
            EnPsub3Oc2[1] = EnPoI2(in sub3ta, CoOcsoco, ref po, 1);
            EnPsub3Oc2[2] = EnPoI2(in sub3ta, CoOcsoco, ref po, 2);
            EnPsub3Oc2[3] = EnPoI2(in sub3ta, CoOcsoco, ref po, 3);
            EnPsub3Oc2[4] = EnPoI2(in sub3ta, CoOcsoco, ref po, 4);
            EnPsub3Oc2[5] = EnPoI2(in sub3ta, CoOcsoco, ref po, 5);
            //Console.WriteLine("KO : EnPsub3Oc[0]={0}\tEnPsub3Oc[2]={1}\tEnPsub3Oc[4]={2}\r\nEnPsub3Oc2[1]={3}\tEnPsub3Oc2[3]={4}\tEnPsub3Oc2[5]={5}", EnPsub3Oc[0], EnPsub3Oc[2], EnPsub3Oc[4], EnPsub3Oc2[1], EnPsub3Oc2[3], EnPsub3Oc2[5]);//debug用
            ElPsub3Oc = new double[6];
            ElPsub3Oc[0] = EnPoC(in sub3ta, CoOcsoco, ref po, 0);
            ElPsub3Oc[1] = EnPoC(in sub3ta, CoOcsoco, ref po, 1);
            ElPsub3Oc[2] = EnPoC(in sub3ta, CoOcsoco, ref po, 2);
            ElPsub3Oc[3] = EnPoC(in sub3ta, CoOcsoco, ref po, 3);
            ElPsub3Oc[4] = EnPoC(in sub3ta, CoOcsoco, ref po, 4);
            ElPsub3Oc[5] = EnPoC(in sub3ta, CoOcsoco, ref po, 5);
            ElPsub3Oc2 = new double[6];
            ElPsub3Oc2[0] = EnPoC2(in sub3ta, CoOcsoco, ref po, 0);
            ElPsub3Oc2[1] = EnPoC2(in sub3ta, CoOcsoco, ref po, 1);
            ElPsub3Oc2[2] = EnPoC2(in sub3ta, CoOcsoco, ref po, 2);
            ElPsub3Oc2[3] = EnPoC2(in sub3ta, CoOcsoco, ref po, 3);
            ElPsub3Oc2[4] = EnPoC2(in sub3ta, CoOcsoco, ref po, 4);
            ElPsub3Oc2[5] = EnPoC2(in sub3ta, CoOcsoco, ref po, 5);
            //Console.WriteLine("ElPsub3Oc[0]={0}\tElPsub3Oc[2]={1}\tElPsub3Oc[4]={2}\r\nElPsub3Oc2[1]={3}\tElPsub3Oc2[3]={4}\tElPsub3Oc2[5]={5}", ElPsub3Oc[0], ElPsub3Oc[2], ElPsub3Oc[4], ElPsub3Oc2[1], ElPsub3Oc2[3], ElPsub3Oc2[5]);//debug用
            EgoPsub3Oc = new double[6];
            EgoPsub3Oc[0] = EnPoGo(in sub3ta, CoOcsoco, ref po, true, true, 1.0);
            EgoPsub3Oc[1] = EnPoGo(in sub3ta, CoOcsoco, ref po, false, true, 1.0);
            EgoPsub3Oc[2] = EnPoGo(in sub3ta, CoOcsoco, ref po, true, false, 1.0);
            EgoPsub3Oc[3] = EnPoGo(in sub3ta, CoOcsoco, ref po, false, false, 1.0);
            EgoPsub3Oc[4] = EnPoGo(in sub3ta, CoOcsoco, ref po, true, null, 1.0);
            EgoPsub3Oc[5] = EnPoGo(in sub3ta, CoOcsoco, ref po, false, null, 1.0);
            EgoPsub3Oc2 = new double[6];
            EgoPsub3Oc2[0] = EnPoGo(in sub3ta, CoOcsoco, ref po, true, true, 2.0);
            EgoPsub3Oc2[1] = EnPoGo(in sub3ta, CoOcsoco, ref po, false, true, 2.0);
            EgoPsub3Oc2[2] = EnPoGo(in sub3ta, CoOcsoco, ref po, true, false, 2.0);
            EgoPsub3Oc2[3] = EnPoGo(in sub3ta, CoOcsoco, ref po, false, false, 2.0);
            EgoPsub3Oc2[4] = EnPoGo(in sub3ta, CoOcsoco, ref po, true, null, 2.0);
            EgoPsub3Oc2[5] = EnPoGo(in sub3ta, CoOcsoco, ref po, false, null, 2.0);
            //Console.WriteLine("I : EgoPsub3Oc[0]={0}\tEgoPsub3Oc[2]={1}\tEgoPsub3Oc[4]={2}\r\nEgoPsub3Oc2[1]={3}\tEgoPsub3Oc2[3]={4}\tEgoPsub3Oc2[5]={5}", EgoPsub3Oc[0], EgoPsub3Oc[2], EgoPsub3Oc[4], EgoPsub3Oc2[1], EgoPsub3Oc2[3], EgoPsub3Oc2[5]);//debug用
            EnoPsub3Oc = new double[4];
            EnoPsub3Oc[0] = EnPoNo(in sub3L2THL[0], CoOcsoco, ref po, true, 1.0);
            EnoPsub3Oc[1] = EnPoNo(in sub3LnTHL[0], CoOcsoco, ref po, true, 1.0);
            EnoPsub3Oc[2] = EnPoNo(in sub3BD2THL[0], CoOcsoco, ref po, false, 1.0);
            EnoPsub3Oc[3] = EnPoNo(in sub3BDs2THL[0], CoOcsoco, ref po, false, 1.0);
            EnoPsub3Oc2 = new double[4];
            EnoPsub3Oc2[0] = EnPoNo(in sub3L2THL[0], CoOcsoco, ref po, true, 2.0);
            EnoPsub3Oc2[1] = EnPoNo(in sub3LnTHL[0], CoOcsoco, ref po, true, 2.0);
            EnoPsub3Oc2[2] = EnPoNo(in sub3BD2THL[0], CoOcsoco, ref po, false, 2.0);
            EnoPsub3Oc2[3] = EnPoNo(in sub3BDs2THL[0], CoOcsoco, ref po, false, 2.0);
            //Console.WriteLine("I : EnoPsub3Oc[0]={0}\tEnoPsub3Oc[1]={1}\tEnoPsub3Oc[2]={2}\r\nEnoPsub3Oc[3]={3}\tEnoPsub3Oc2[0]={4}\tEnoPsub3Oc2[1]={5}\r\nEnoPsub3Oc2[2]={6}\tEnoPsub3Oc2[3]={7}", EnoPsub3Oc[0], EnoPsub3Oc[1], EnoPsub3Oc[2], EnoPsub3Oc[3], EnoPsub3Oc2[0], EnoPsub3Oc2[1], EnoPsub3Oc2[2], EnoPsub3Oc[3]);//debug用
            int[] sub3LPT = BdIG(in sub3L2THL[0], in sub3LnTHL[0], ref po);
            EnoPwLsub3Oc = new double[8];
            EnoPwLsub3Oc[0] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 0);
            EnoPwLsub3Oc[1] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 1);
            EnoPwLsub3Oc[2] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 2);
            EnoPwLsub3Oc[3] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 3);
            EnoPwLsub3Oc[4] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 4);
            EnoPwLsub3Oc[5] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 5);
            EnoPwLsub3Oc[6] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 6);
            EnoPwLsub3Oc[7] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 1.0, 7);
            EnoPwLsub3Oc2 = new double[8];
            EnoPwLsub3Oc2[0] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 0);
            EnoPwLsub3Oc2[1] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 1);
            EnoPwLsub3Oc2[2] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 2);
            EnoPwLsub3Oc2[3] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 3);
            EnoPwLsub3Oc2[4] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 4);
            EnoPwLsub3Oc2[5] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 5);
            EnoPwLsub3Oc2[6] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 6);
            EnoPwLsub3Oc2[7] = EnPoNow(in sub3LPT, CoOcsoco, ref po, 2.0, 7);
            //Console.WriteLine("SU : EnoPwLsub3Oc[0]={0}\tEnoPwLsub3Oc[2]={1}\tEnoPwLsub3Oc[4]={2}\r\nEnoPwLsub3Oc[6]={3}\tEnoPwLsub3Oc2[1]={4}\tEnoPwLsub3Oc2[3]={5}\r\nEnoPwLsub3Oc2[5]={6}\tEnoPwLsub3Oc2[7]={7}", EnoPwLsub3Oc[0], EnoPwLsub3Oc[2], EnoPwLsub3Oc[4], EnoPwLsub3Oc[6], EnoPwLsub3Oc2[1], EnoPwLsub3Oc2[3], EnoPwLsub3Oc2[5], EnoPwLsub3Oc[7]);//debug用
            DipAcos = new double[3];
            DipAcos[0] = DipAC(CoC1[0], CoC1[1], true);
            DipAcos[1] = DipAC(CoC2[0], CoO[0], true);
            DipAcos[2] = DipAC(CoC2[1], CoO[1], true);
            DipAsin = new double[3];
            DipAsin[0] = DipAC(CoC1[0], CoC1[1], false);
            DipAsin[1] = DipAC(CoC2[0], CoO[0], false);
            DipAsin[2] = DipAC(CoC2[1], CoO[1], false);
            dpamDFT = new double[3];
            tns = new SGKC.Tensor(gl._dpam);
            dpamDFT[0] = tns.HLSLU(true);
            dpamDFT[1] = tns.FbN();
            dpamDFT[2] = tns.TSeki();
            tns = null;
            //Console.WriteLine("E : DipAcos[0]={0}\tDipAsin[1]={1}\tdpamDFT[2]={2}", DipAcos[0], DipAsin[1], dpamDFT[2]);//debug用
        }
        private double[] gopjh(in int[] GsA, ref ParallelOptions po)//総軌道電子情報から総核電子/総価電子/総リュードベリ電子を計算する
        {
            object lo = new object();
            double[] CVRA = new double[3] { 0.0, 0.0, 0.0 };
            Parallel.ForEach(GsA, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "gopjh : Atom index is invalid.");
                double dc = 0, dv = 0, dr = 0;
                int cnt = gl._aobl[ind];
                int cnt2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                int itemp = cnt;
                switch (gl._als[ind])
                {
                    case 1://H
                        {
                            if (cnt2 - cnt != 5) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("gopjh ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                            if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("3PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("3PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("3PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            break;
                        }
                    case 3://Li
                    case 5://B
                    case 6://C
                    case 7://N
                    case 8://O
                    case 9://F
                        {
                            if (cnt2 - cnt != 14) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("gopjh ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                            if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("4PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("4PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("4PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            break;
                        }
                    case 14://Si
                    case 15://P
                    case 16://S
                    case 17://Cl
                        {
                            if (cnt2 - cnt != 18) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("gopjh ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                            if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("4S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            break;
                        }
                    case 32://Ge
                    case 33://As
                    case 34://Se
                    case 35://Br
                        {
                            if (cnt2 - cnt != 32) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("gopjh ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                            if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("4S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("11D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("11D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("11D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("11D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("11D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("12D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("12D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("12D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("12D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("12D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            break;
                        }
                    case 50://Sn
                    case 51://Sb
                    case 52://Te
                    case 53://I
                        {
                            if (cnt2 - cnt != 26) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("gopjh ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                            if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("4S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dc += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("6PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("7PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("8PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("9D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dv += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            if (!gl._aol[++itemp].Equals("10D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                            dr += gl._gop[itemp];
                            break;
                        }
                    default:
                        throw new ArgumentOutOfRangeException("ind", String.Format("gopjh ([{0}]={1}): Atom not supported.", ind, gl._als[ind]));
                }
                lock (lo)
                {
                    CVRA[0] += dc;
                    CVRA[1] += dv;
                    CVRA[2] += dr;
                }
            });
            return CVRA;
        }
        private double Mcjh(in int[] GsA, bool h)//総マリケン電荷を求める
        {
            double ds = 0;
            foreach (int ind in GsA)
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "Mcjh : Atom index is invalid.");
                if (!h) ds += gl._mlkc[ind];
                else
                {
                    if (ind >= gl._han) continue;
                    ds += gl._mhsc[ind];
                }
            }
            return ds;
        }
        private double[] HfPw(in int[] GsA, ref ParallelOptions po)//総Hirshfeld電子CAB/Hirshfeld双極子モーメントを求める
        {
            double[] dres = new double[2] { 0.0, 0.0 };
            Parallel.ForEach(GsA, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "HfPw : Atom index is invalid.");
                double dtemp = Math.Sqrt(Math.Pow(gl._HDXYZ[ind, 0], 2) + Math.Pow(gl._HDXYZ[ind, 1], 2) + Math.Pow(gl._HDXYZ[ind, 2], 2));
                lock (dres.SyncRoot)
                {
                    dres[0] += gl._HCAB[ind];
                    dres[1] += dtemp;
                }
            });
            return dres;
        }
        private double[] HfQw(in int[] GsA, bool h)//総Hirshfeld原子電荷/CM5電荷を求める
        {
            double[] dres = new double[2] { 0.0, 0.0 };
            foreach (int ind in GsA)
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "HfQw : Atom index is invalid.");
                if (!h)
                {
                    dres[0] += gl._Hachg[ind];
                    dres[1] += gl._Hacm5chg[ind];
                }
                else
                {
                    if (ind >= gl._han) continue;
                    dres[0] += gl._Hhachg[ind];
                    dres[1] += gl._Hhacm5chg[ind];
                }
            }
            return dres;
        }
        private double Ecw(in int[] GsA, bool h)//総ESP電荷を求める
        {
            double dres = 0;
            foreach (int ind in GsA)
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "Ecw : Atom index is invalid.");
                if (!h) dres += gl._ESPc[ind];
                else
                {
                    if (ind >= gl._han) continue;
                    dres += gl._ESPch[ind];
                }
            }
            return dres;
        }
        private double Epw(in int[] GsA)//総原子電位
        {
            double dres = 0;
            foreach (int ind in GsA)
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "Epw : Atom index is invalid.");
                dres += gl._aep[ind];
            }
            return dres;
        }
        private double[] NAOOE(in int[] GsA, ref ParallelOptions po, bool oe)//総NAO価電子/リュードベリ電子/価電子エネルギー/リュードベリ電子エネルギー
        {
            double[] dres;
            if (oe) dres = new double[4] { 0.0, 0.0, 0.0, 0.0 };
            else dres = new double[2] { 0.0, 0.0 };
            Parallel.ForEach(GsA, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "NAOOE : Atom index is invalid.");
                double dovt = 0;
                double dort = 0;
                double devt = 0;
                double dert = 0;
                for (int cnt = gl._aobl[ind]; cnt < ((ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1]); cnt++)
                {
                    if (gl._naot[cnt] == false)//価電子
                    {
                        if (oe) dovt += gl._naooc[cnt];
                        devt += gl._naooc[cnt] * gl._naoen[cnt];
                    }
                    else if (gl._naot[cnt] == null)//リュードベリ電子
                    {
                        if (oe) dort += gl._naooc[cnt];
                        dert += gl._naooc[cnt] * gl._naoen[cnt];
                    }
                }
                lock (dres.SyncRoot)
                {
                    if (oe)
                    {
                        dres[0] += dovt;
                        dres[1] += dort;
                        dres[2] += devt;
                        dres[3] += dert;
                    }
                    else
                    {
                        dres[0] += devt;
                        dres[1] += dert;
                    }
                }
            });
            return dres;
        }
        private double NAOcw(in int[] GsA)//総NAO電荷を求める
        {
            double dres = 0;
            foreach (int ind in GsA)
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "NAOcw : Atom index is invalid.");
                dres += gl._nch[ind];
            }
            return dres;
        }
        private double NAOtw(in int[] GsA)//総NAO全電子を求める
        {
            double dres = 0;
            foreach (int ind in GsA)
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "NAOtw : Atom index is invalid.");
                dres += gl._npt[ind];
            }
            return dres;
        }
        private double[] NVsp(in int[] GsA, bool L)//総価層s/p電子、trueL、falseM+
        {
            double ds = 0;
            double dp = 0;
            foreach (int ind in GsA)
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "NVsp : Atom index is invalid.");
                if (L)
                {
                    if (ind >= gl._nec2s.Length || ind >= gl._nec2p.Length) continue;
                    if (gl._nec2s[ind] != 0) ds += gl._nec2s[ind];
                    if (gl._nec2p[ind] != 0) dp += gl._nec2p[ind];
                }
                else
                {
                    if (ind >= gl._necns.Length || ind >= gl._necnp.Length) continue;
                    if (gl._necns[ind] != 0) ds += gl._necns[ind];
                    if (gl._necnp[ind] != 0) dp += gl._necnp[ind];
                }
            }
            return new double[2] { ds, dp };
        }
        private int[] BdIS(int[] Yz, int[] Yy, ref ParallelOptions po, bool s, bool? x)//NBO結合を探す。s trueはσ。x trueは反結合。
        {
            List<int> il = new List<int>();
            object lo = new object();
            Parallel.For(0, gl._nbo2n, po, (cnt) =>
            {
                if ((x == null) ? true : ((x == true) ? gl._nbot2[cnt].Equals("BD*", StringComparison.InvariantCultureIgnoreCase) : gl._nbot2[cnt].Equals("BD", StringComparison.InvariantCultureIgnoreCase)))
                {
                    if (s ? (gl._nbok2[cnt] == 1) : (gl._nbok2[cnt] != 1))
                    {
                        foreach (int ind in Yz)
                        {
                            if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "BdIS : Atom index is invalid.");
                            if (ind == gl._nbon21[cnt])
                            {
                                foreach (int ind2 in Yy)
                                {
                                    if (ind2 >= gl._an) throw new ArgumentOutOfRangeException("ind2", "BdIS : Atom index is invalid.");
                                    if (ind2 == gl._nbon22[cnt])
                                    {
                                        lock (lo) il.Add(cnt);
                                    }
                                }
                            }
                            else if (ind == gl._nbon22[cnt])
                            {
                                foreach (int ind2 in Yy)
                                {
                                    if (ind2 >= gl._an) throw new ArgumentOutOfRangeException("ind2", "BdIS : Atom index is invalid.");
                                    if (ind2 == gl._nbon21[cnt])
                                    {
                                        lock (lo) il.Add(cnt);
                                    }
                                }
                            }
                        }
                    }
                }
            });
            return il.ToArray();
        }
        private int[] BdIG(in int[] Jz, in int[] Jy, ref ParallelOptions po)//NBO配列を合併する
        {
            List<int> il = new List<int>(Jz);
            int ilc = il.Count;
            object lo = new object();
            Parallel.ForEach(Jy, po, (ind) =>
            {
                for (int ind2 = 0; ind2 < ilc; ind2++)
                {
                    if (il[ind2] == ind) return;
                }
                lock (lo) il.Add(ind);
            });
            return il.ToArray();
        }
        private double[] BDEw(in int[] Bds, ref ParallelOptions po, bool e, bool s, bool p, bool d)//二中心NBO電子を加算する
        {
            double de = 0;
            double ds = 0;
            double dp = 0;
            double dd = 0;
            object lo = new object();
            object lo2 = new object();
            object lo3 = new object();
            object lo4 = new object();
            Parallel.ForEach(Bds, po, (ib) =>
            {
                if (ib >= gl._nbo2n) throw new ArgumentOutOfRangeException("ib", "BDEw : NBO index is invalid.");
                if (e)
                {
                    lock (lo) de += gl._nboo2[ib];
                }
                if (s)
                {
                    double dstemp = gl._nboo2[ib] * gl._nbor21[ib] * gl._nbos21[ib] + gl._nboo2[ib] * gl._nbor22[ib] * gl._nbos22[ib];
                    lock (lo) ds += dstemp;
                }
                if (p)
                {
                    double dptemp = gl._nboo2[ib] * gl._nbor21[ib] * gl._nbop21[ib] + gl._nboo2[ib] * gl._nbor22[ib] * gl._nbop22[ib];
                    lock (lo) dp += dptemp;
                }
                if (d)
                {
                    double ddtemp = gl._nboo2[ib] * gl._nbor21[ib] * gl._nbod21[ib] + gl._nboo2[ib] * gl._nbor22[ib] * gl._nbod22[ib];
                    lock (lo) dd += ddtemp;
                }
            });
            if (e && s && p && d)
            {
                return new double[4] { de, ds, dp, dd };
            }
            else if (!e && !s && p && d)
            {
                return new double[2] { dp, dd };
            }
            else throw new NotImplementedException("BDEw : This combination is not implemented.");
        }
        private int[] LRIS(in int[] Yz, ref ParallelOptions po, bool? glh, bool? x, bool? l)//NBO原子を探す。glh trueはロンペア。x trueは反結合,l はL層
        {
            List<int> il = new List<int>();
            object lo = new object();
            Parallel.ForEach(Yz, po, (cnt) =>
            {
                if (cnt >= gl._an) throw new ArgumentOutOfRangeException("cnt", "LRIS : Atom index is invalid.");
                if (l == true)
                {
                    if (gl._als[cnt] < 3 || gl._als[cnt] > 10) return;
                }
                else if (l == false)
                {
                    if (gl._als[cnt] < 11) return;
                }
                for (int cnt2 = 0; cnt2 < gl._nbo1n; cnt2++)
                {
                    if (gl._nbon1[cnt2] == cnt)
                    {
                        if (glh == true)
                        {
                            if ((x == null) ? gl._nbot1[cnt2].StartsWith("LP", StringComparison.InvariantCultureIgnoreCase) : ((x == true) ? gl._nbot1[cnt2].Equals("LP*", StringComparison.InvariantCultureIgnoreCase) : gl._nbot1[cnt2].Equals("LP", StringComparison.InvariantCultureIgnoreCase)))
                            {
                                lock (lo) il.Add(cnt2);
                            }
                        }
                        else if (glh == false)
                        {
                            if ((x == null) ? gl._nbot1[cnt2].StartsWith("RY", StringComparison.InvariantCultureIgnoreCase) : ((x == true) ? gl._nbot1[cnt2].Equals("RY*", StringComparison.InvariantCultureIgnoreCase) : gl._nbot1[cnt2].Equals("RY", StringComparison.InvariantCultureIgnoreCase)))
                            {
                                lock (lo) il.Add(cnt2);
                            }
                        }
                        else
                        {
                            if ((x == null) ? gl._nbot1[cnt2].StartsWith("CR", StringComparison.InvariantCultureIgnoreCase) : ((x == true) ? gl._nbot1[cnt2].Equals("CR*", StringComparison.InvariantCultureIgnoreCase) : gl._nbot1[cnt2].Equals("CR", StringComparison.InvariantCultureIgnoreCase)))
                            {
                                lock (lo) il.Add(cnt2);
                            }
                        }
                    }
                }
            });
            return il.ToArray();
        }
        private double[] LREw(in int[] Gss, ref ParallelOptions po, bool e, bool s, bool p, bool d)//一中心NBO電子を加算する
        {
            double de = 0;
            double ds = 0;
            double dp = 0;
            double dd = 0;
            object lo = new object();
            object lo2 = new object();
            object lo3 = new object();
            object lo4 = new object();
            Parallel.ForEach(Gss, po, (ig) =>
            {
                if (ig >= gl._nbo1n) throw new ArgumentOutOfRangeException("ig", "LREw : NBO index is invalid.");
                if (e)
                {
                    lock (lo) de += gl._nboo1[ig];
                }
                if (s)
                {
                    double dstemp = gl._nboo1[ig] * gl._nbos1[ig];
                    lock (lo2) ds += dstemp;
                }
                if (p)
                {
                    double dptemp = gl._nboo1[ig] * gl._nbop1[ig];
                    lock (lo3) dp += dptemp;
                }
                if (d)
                {
                    double ddtemp = gl._nboo1[ig] * gl._nbod1[ig];
                    lock (lo4) dd += ddtemp;
                }
            });
            if (e && s && p && d)
            {
                return new double[4] { de, ds, dp, dd };
            }
            else throw new NotImplementedException("LREw : This combination is not implemented.");
        }
        private double NHOSkS(in int[] Bds, ref ParallelOptions po, bool sp, bool x, in string t)//NHO加算
        {
            byte btemp;
            switch (t.ToUpperInvariant())
            {
                case "SIN":
                    {
                        btemp = 0;
                        break;
                    }
                case "SIN2":
                    {
                        btemp = 1;
                        break;
                    }
                case "COS":
                    {
                        btemp = 2;
                        break;
                    }
                case "COS2":
                    {
                        btemp = 3;
                        break;
                    }
                default: throw new ArgumentOutOfRangeException("t", "NHOSkS : Unexpected type.");
            }
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Bds, po, (ind) =>
            {
                if (ind >= gl._nbo2n) throw new ArgumentOutOfRangeException("ind", "NHOSks : NBO index is invalid.");
                if (x)
                {
                    if (!gl._nbot2[ind].Equals("BD*", StringComparison.InvariantCultureIgnoreCase)) return;
                }
                else
                {
                    if (!gl._nbot2[ind].Equals("BD", StringComparison.InvariantCultureIgnoreCase)) return;
                }
                if (sp)
                {
                    if (gl._nbok2[ind] != 1) return;
                }
                else
                {
                    if (gl._nbok2[ind] == 1) return;
                }
                int itemp = -1;
                for (int cnt = 0; cnt < gl._nhon.Length; cnt++)
                {
                    if (gl._nhon[cnt] == gl._nboi2[ind]) itemp = cnt;
                }
                if (itemp == -1) return;
                double dtemp;
                switch (btemp)
                {
                    case 0:
                        {
                            dtemp = Math.Sin(gl._nhod1[itemp]) + Math.Sin(gl._nhod2[itemp]);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    case 1:
                        {
                            dtemp = Math.Pow(Math.Sin(gl._nhod1[itemp]), 2) + Math.Pow(Math.Sin(gl._nhod2[itemp]), 2);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    case 2:
                        {
                            dtemp = Math.Cos(gl._nhod1[itemp]) + Math.Cos(gl._nhod2[itemp]);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    case 3:
                        {
                            dtemp = Math.Pow(Math.Cos(gl._nhod1[itemp]), 2) + Math.Pow(Math.Cos(gl._nhod2[itemp]), 2);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("btemp", "NHOSkS : Unexpected type.");
                }
            });
            return dres;
        }
        private double NHOSkS(ref ParallelOptions po, bool sp, bool x, in string t)//NHO加算（分子全体）、sp trueはσ結合、xは反結合
        {
            byte btemp;
            switch (t.ToUpperInvariant())
            {
                case "SIN":
                    {
                        btemp = 0;
                        break;
                    }
                case "SIN2":
                    {
                        btemp = 1;
                        break;
                    }
                case "COS":
                    {
                        btemp = 2;
                        break;
                    }
                case "COS2":
                    {
                        btemp = 3;
                        break;
                    }
                default: throw new ArgumentOutOfRangeException("t", "NHOSkS : Unexpected type.");
            }
            double dres = 0;
            object lo = new object();
            Parallel.For(0, gl._nhon.Length, po, (cnt) =>
            {
                int ind = -1;
                for (int itemp = 0; itemp < gl._nboi2.Length; itemp++)
                {
                    if (gl._nboi2[itemp] == gl._nhon[cnt])
                    {
                        ind = itemp;
                        break;
                    }
                }
                if (ind == -1) return;
                if (x)
                {
                    if (!gl._nbot2[ind].Equals("BD*", StringComparison.InvariantCultureIgnoreCase)) return;
                }
                else
                {
                    if (!gl._nbot2[ind].Equals("BD", StringComparison.InvariantCultureIgnoreCase)) return;
                }
                if (sp)
                {
                    if (gl._nbok2[ind] != 1) return;
                }
                else
                {
                    if (gl._nbok2[ind] == 1) return;
                }
                double dtemp;
                switch (btemp)
                {
                    case 0:
                        {
                            dtemp = Math.Sin(gl._nhod1[cnt]) + Math.Sin(gl._nhod2[cnt]);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    case 1:
                        {
                            dtemp = Math.Pow(Math.Sin(gl._nhod1[cnt]), 2) + Math.Pow(Math.Sin(gl._nhod2[cnt]), 2);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    case 2:
                        {
                            dtemp = Math.Cos(gl._nhod1[cnt]) + Math.Cos(gl._nhod2[cnt]);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    case 3:
                        {
                            dtemp = Math.Pow(Math.Cos(gl._nhod1[cnt]), 2) + Math.Pow(Math.Cos(gl._nhod2[cnt]), 2);
                            lock (lo) dres += dtemp;
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("btemp", "NHOSkS : Unexpected type.");
                }
            });
            return dres;
        }
        private double SopeS(in int[] KGa, int[] KGb, ref ParallelOptions po, bool don, bool s1, bool s2)//二次摂動安定化エネルギー加算、donはKGaドナー、s1/s2は一中心
        {
            double dres = 0;
            object lo = new object();
            if (KGb == null)
            {
                Parallel.ForEach(KGa, po, (ind) =>
                {
                    if ((s1 ? (ind >= gl._nbo1n) : (ind >= gl._nbo2n))) throw new ArgumentOutOfRangeException("ind", "SopeS : NBO index is invalid.");
                    if (don)
                    {
                        for (int cnt = 0; cnt < gl._sopd.Length; cnt++)
                        {
                            if (gl._sopd[cnt] == (s1 ? gl._nboi1[ind] : gl._nboi2[ind])) lock (lo) dres += gl._sope[cnt];
                        }
                    }
                    else
                    {
                        for (int cnt = 0; cnt < gl._sopa.Length; cnt++)
                        {
                            if (gl._sopa[cnt] == (s1 ? gl._nboi1[ind] : gl._nboi2[ind])) lock (lo) dres += gl._sope[cnt];
                        }
                    }
                });
            }
            else
            {
                throw new NotImplementedException("SopeS : Second list unavailable (not implemented).");
            }
            return dres;
        }
        private double NBOES(in int[] KGa, ref ParallelOptions po, bool b)//NBOエネルギーを加算する、bは結合
        {
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(KGa, po, (ind) =>
            {
                double dtemp;
                if (b)
                {
                    if (ind >= gl._nbo2n) throw new ArgumentOutOfRangeException("ind", "NBOES : NBO index is invalid.");
                    dtemp = gl._nboe2[ind] * gl._nboo2[ind];
                    lock (lo) dres += dtemp;
                }
                else
                {
                    if (ind >= gl._nbo1n) throw new ArgumentOutOfRangeException("ind", "NBOES : NBO index is invalid.");
                    dtemp = gl._nboe1[ind] * gl._nboo1[ind];
                    lock (lo) dres += dtemp;
                }
            });
            return dres;
        }
        private double Gsks(in int Ai, byte ct)//GIAO、Aiは原子インデックス、ct0は等方、1は異方、2はテンソルフロベニウス、3は固有値ノルム
        {
            if (Ai >= gl._an) throw new ArgumentOutOfRangeException("Ai", "Gsks : Atom index is invalid.");
            switch (ct)
            {
                case 0:
                    {
                        return gl._gmsi[Ai];
                    }
                case 1:
                    {
                        return gl._gmsa[Ai];
                    }
                case 2:
                    {
                        double dtemp = 0;
                        for (int cnt = 0; cnt < 3; cnt++)
                        {
                            for (int cnt2 = 0; cnt2 < 3; cnt2++)
                            {
                                dtemp += gl._gmst[Ai, cnt, cnt2] * gl._gmst[Ai, cnt, cnt2];
                            }
                        }
                        return Math.Sqrt(dtemp);
                    }
                case 3:
                    {
                        double dtemp = gl._gmse[Ai, 0] * gl._gmse[Ai, 0] + gl._gmse[Ai, 1] * gl._gmse[Ai, 1] + gl._gmse[Ai, 2] * gl._gmse[Ai, 2];
                        return Math.Sqrt(dtemp);
                    }
                default: throw new ArgumentOutOfRangeException("ct", "Gsks : Invalid type");
            }
        }
        private double GsksS(in int[] Ais, ref ParallelOptions po, byte ct)//複数原子GIAO加算
        {
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Ais, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "GsksS : Atom index is invalid.");
                double dtemp = Gsks(ind, ct);
                lock (lo) dres += dtemp;
            });
            return dres;
        }
        private double APTcS(in int[] Al, ref ParallelOptions po, bool h)//APT電荷を加算する
        {
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Al, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "APTcS : Atom index is invalid.");
                if (h)
                {
                    lock (lo) dres += gl._APThc[ind];
                }
                else
                {
                    lock (lo) dres += gl._APTc[ind];
                }
            });
            return dres;
        }
        private double IRkeS(in int[] Gs, ref ParallelOptions po)//IRエネルギー
        {
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gs, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "IRkeS : Atom index is invalid.");
                double dtemp = 0, dtemp2;
                for (int cnt = 0; cnt < gl._dof; cnt++)
                {
                    dtemp2 = gl._noco[cnt, ind, 0] * gl._noco[cnt, ind, 0] + gl._noco[cnt, ind, 1] * gl._noco[cnt, ind, 1] + gl._noco[cnt, ind, 2] * gl._noco[cnt, ind, 2];
                    dtemp2 *= gl._ncfrq[cnt] * gl._ncfrq[cnt] * gl._ncii[cnt];
                    dtemp += dtemp2;
                }
                lock (lo) dres += dtemp;
            });
            return dres;
        }
        private double IRkeS(in int[] Gs, ref ParallelOptions po, double? s, double? z)//IR区間エネルギー、sは低値、zは高値、[s,z)
        {
            if (s == null) s = 0.0;
            if (z == null) z = double.MaxValue;
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gs, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "IRkeS : Atom index is invalid.");
                double dtemp = 0, dtemp2;
                for (int cnt = 0; cnt < gl._dof; cnt++)
                {
                    if (gl._ncfrq[cnt] < s || gl._ncfrq[cnt] >= z) continue;
                    dtemp2 = gl._noco[cnt, ind, 0] * gl._noco[cnt, ind, 0] + gl._noco[cnt, ind, 1] * gl._noco[cnt, ind, 1] + gl._noco[cnt, ind, 2] * gl._noco[cnt, ind, 2];
                    dtemp2 *= gl._ncfrq[cnt] * gl._ncfrq[cnt] * gl._ncii[cnt];
                    dtemp += dtemp2;
                }
                lock (lo) dres += dtemp;
            });
            return dres;
        }
        private double VolB(in double[] C1, in double[] C2, in double r1, in double r2)//球の交わり体積、C1は球1の中心、r1は球1の半径
        {
            if (C1.Length != 3 || C2.Length != 3) throw new NotImplementedException("VolB : Method is only for 3D.");
            if (r1 == 0 || r2 == 0) return 0.0;
            double d2 = Math.Pow(C1[0] - C2[0], 2.0) + Math.Pow(C1[1] - C2[1], 2.0) + Math.Pow(C1[2] - C2[2], 2.0);
            double d = Math.Sqrt(d2);
            if (r1 + r2 <= d)
            {
                return 0;
            }
            double cosr;
            double Rc;
            double sinr;
            double Rs;
            double h;
            double H;
            double VolR;
            double Volr;
            if (r1 >= r2)
            {
                if (r1 >= d + r2)
                {
                    return 4.0 / 3.0 * Math.PI * Math.Pow(r2, 3.0);
                }
                cosr = (Math.Pow(r1, 2.0) + d2 - Math.Pow(r2, 2.0)) / (2.0 * r1 * d);
                Rc = r1 * cosr;
                h = Rc - d + r2;
                if (h <= 0) return 0.0;
                if (h >= d + r2) return 4.0 / 3.0 * Math.PI * Math.Pow(r2, 3.0);
                sinr = Math.Sqrt(1.0 - Math.Pow(cosr, 2.0));
                Rs = r1 * sinr;
                if (Rs > r2) Rs = r2;
                H = r1 - Rc;
                if (H < 0) H = 0;
                else if (H > r2) H = r2;
                VolR = Math.PI * H * (3.0 * Math.Pow(Rs, 2.0) + Math.Pow(H, 2.0)) / 6.0;
                Volr = Math.PI * h * (3.0 * Math.Pow(Rs, 2.0) + Math.Pow(h, 2.0)) / 6.0;
            }
            else
            {
                if (r2 >= d + r1)
                {
                    return 4.0 / 3.0 * Math.PI * Math.Pow(r1, 3.0);
                }
                cosr = (Math.Pow(r2, 2.0) + d2 - Math.Pow(r1, 2.0)) / (2.0 * r2 * d);
                Rc = r2 * cosr;
                h = Rc - d + r1;
                if (h <= 0) return 0.0;
                if (h >= d + r1) return 4.0 / 3.0 * Math.PI * Math.Pow(r1, 3.0);
                sinr = Math.Sqrt(1.0 - Math.Pow(cosr, 2.0));
                Rs = r2 * sinr;
                if (Rs > r1) Rs = r1;
                H = r2 - Rc;
                if (H < 0) H = 0;
                else if (H > r1) H = r1;
                VolR = Math.PI * H * (3.0 * Math.Pow(Rs, 2.0) + Math.Pow(H, 2.0)) / 6.0;
                Volr = Math.PI * h * (3.0 * Math.Pow(Rs, 2.0) + Math.Pow(h, 2.0)) / 6.0;
            }
            return VolR + Volr;
        }
        public double VolBS(in int[] Gr, double[] cs, double rs, ref ParallelOptions po, byte rt)//殻占有体積、`cは殻の中心(s標準d双極子)、rsは殻の半径、rt0はファンデルワールス半径(pm)/rt1は計算原子半径(pm)/rt2は経験原子半径(pm)/rt3はイオン半径(空)(pm)/rt4はイオン半径(満)(pm)
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs", "VolBS : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gr, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "VolBS : Atom index is invalid.");
                double dtemp;
                double[] Gc = new double[3] { gl._soco[ind, 0] * 100.0, gl._soco[ind, 1] * 100.0, gl._soco[ind, 2] * 100.0 };
                //double[] Gc2 = new double[3] { gl._dico[ind, 0] * 100.0, gl._dico[ind, 1] * 100.0, gl._dico[ind, 2] * 100.0 };
                NatAtoms na = new NatAtoms();
                switch (rt)
                {
                    case 0:
                        {
                            dtemp = VolB(cs, Gc, rs, na.fthvdWRfP(gl._als[ind]));
                            //dtemp2 = VolB(cd, Gc2, rs, na.fthvdWRfP(gl._als[ind]));
                            break;
                        }
                    case 1:
                        {
                            dtemp = VolB(cs, Gc, rs, na.fthAtCRfP(gl._als[ind]));
                            //dtemp2 = VolB(cd, Gc2, rs, na.fthAtCRfP(gl._als[ind]));
                            break;
                        }
                    case 2:
                        {
                            dtemp = VolB(cs, Gc, rs, na.fthAtERfP(gl._als[ind]));
                            //dtemp2 = VolB(cd, Gc2, rs, na.fthAtERfP(gl._als[ind]));
                            break;
                        }
                    case 3:
                        {
                            dtemp = VolB(cs, Gc, rs, na.fthIoRfP(gl._als[ind]).Item1);
                            //dtemp2 = VolB(cd, Gc2, rs, na.fthIoRfP(gl._als[ind]).Item1);
                            break;
                        }
                    case 4:
                        {
                            dtemp = VolB(cs, Gc, rs, na.fthIoRfP(gl._als[ind]).Item2);
                            //dtemp2 = VolB(cd, Gc2, rs, na.fthIoRfP(gl._als[ind]).Item2);
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("rt", "VolBS : Unknown radius type.");
                }
                /*
                if (dtemp > 1E-9 || dtemp2 > 1E-9)
                {
                    if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "VolBS : Result can not be verified.");
                }
                dtemp += dtemp2;
                dtemp /= 2.0;*/
                lock (lo) dres += dtemp;
            });
            if (Double.IsNaN(dres) || Double.IsInfinity(dres)) throw new ArgumentOutOfRangeException("dres", "VolBS : Result is invalid.");
            return dres;
        }
        public double EnPoI(in int[] Gr, double[] cs, ref ParallelOptions po, byte et)//原子環境ポテンシャル、cは中心(s標準d双極子)、et0は電子親和力(kJ/mol)/et1はポーリングの電気陰性度/et2はアレンの電気陰性度/et3はマリケンの電気陰性度/et4は有効核電荷/et5は第1イオン化エネルギー(kJ/mol)
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs", "EnPoI : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gr, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "EnPoI : Atom index is invalid.");
                double dtemp = Math.Sqrt(Math.Pow((gl._soco[ind, 0] - cs[0]) * 100.0, 2) + Math.Pow((gl._soco[ind, 1] - cs[1]) * 100.0, 2) + Math.Pow((gl._soco[ind, 2] - cs[2]) * 100.0, 2));
                //double dtemp2 = Math.Sqrt(Math.Pow((gl._dico[ind, 0] - cd[0]) * 100.0, 2) + Math.Pow((gl._dico[ind, 1] - cd[1]) * 100.0, 2) + Math.Pow((gl._dico[ind, 2] - cd[2]) * 100.0, 2));
                if (dtemp == 0) throw new ArgumentOutOfRangeException("dtemp", "EnPoI : Distance is 0.");
                NatAtoms na = new NatAtoms();
                switch (et)
                {
                    case 0:
                        {
                            dtemp = na.fthEAffP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEAffP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 1:
                        {
                            dtemp = na.fthEnPfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEnPfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 2:
                        {
                            dtemp = na.fthEnAfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEnAfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 3:
                        {
                            dtemp = na.fthEnMfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEnMfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 4:
                        {
                            dtemp = na.fthEffNCfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEffNCfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 5:
                        {
                            dtemp = na.fthIE1fP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthIE1fP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("et", "EnPoI : Unknown environment type.");
                }
                /*
                if (dtemp > 1E-9 || dtemp2 > 1E-9)
                {
                    if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoI : Result can not be verified.");
                }
                dtemp += dtemp2;
                dtemp /= 2.0;*/
                lock (lo) dres += dtemp;
            });
            if (Double.IsNaN(dres) || Double.IsInfinity(dres)) throw new ArgumentOutOfRangeException("dres", "EnPoI : Result is invalid.");
            return dres;
        }
        public double EnPoI2(in int[] Gr, double[] cs, ref ParallelOptions po, byte et)//原子環境ポテンシャル(r二乗)、cは中心(s標準d双極子)、et0は電子親和力(kJ/mol)/et1はポーリングの電気陰性度/et2はアレンの電気陰性度/et3はマリケンの電気陰性度/et4は有効核電荷/et5は第1イオン化エネルギー(kJ/mol)
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs", "EnPoI : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gr, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "EnPoI2 : Atom index is invalid.");
                double dtemp = Math.Pow((gl._soco[ind, 0] - cs[0]) * 100.0, 2) + Math.Pow((gl._soco[ind, 1] - cs[1]) * 100.0, 2) + Math.Pow((gl._soco[ind, 2] - cs[2]) * 100.0, 2);
                //double dtemp2 = Math.Pow((gl._dico[ind, 0] - cd[0]) * 100.0, 2) + Math.Pow((gl._dico[ind, 1] - cd[1]) * 100.0, 2) + Math.Pow((gl._dico[ind, 2] - cd[2]) * 100.0, 2);
                if (dtemp == 0) throw new ArgumentOutOfRangeException("dtemp", "EnPoI : Distance is 0.");
                NatAtoms na = new NatAtoms();
                switch (et)
                {
                    case 0:
                        {
                            dtemp = na.fthEAffP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEAffP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 1:
                        {
                            dtemp = na.fthEnPfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEnPfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 2:
                        {
                            dtemp = na.fthEnAfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEnAfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 3:
                        {
                            dtemp = na.fthEnMfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEnMfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 4:
                        {
                            dtemp = na.fthEffNCfP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthEffNCfP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    case 5:
                        {
                            dtemp = na.fthIE1fP(gl._als[ind]) / dtemp;
                            //dtemp2 = na.fthIE1fP(gl._als[ind]) / dtemp2;
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("et", "EnPoI : Unknown environment type.");
                }
                /*
                if (dtemp > 1E-25 || dtemp2 > 1E-25)
                {
                    if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoI : Result can not be verified.");
                }
                dtemp += dtemp2;
                dtemp /= 2.0;*/
                lock (lo) dres += dtemp;
            });
            if (Double.IsNaN(dres) || Double.IsInfinity(dres)) throw new ArgumentOutOfRangeException("dres", "EnPoI : Result is invalid.");
            return dres;
        }
        public double EnPoC(in int[] Gr, double[] cs, ref ParallelOptions po, byte et)//電荷環境ポテンシャル、cは中心(s標準d双極子)、et0マリケン電荷/et1はHirshfeld原子電荷/et2はHirshfeld原子CM5電荷/et3はESP電荷/et4は自然電荷/et5はAPT電荷
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs/cd", "EnPoC : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gr, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "EnPoC : Atom index is invalid.");
                double dtemp = Math.Sqrt(Math.Pow((gl._soco[ind, 0] - cs[0]) * 100.0, 2) + Math.Pow((gl._soco[ind, 1] - cs[1]) * 100.0, 2) + Math.Pow((gl._soco[ind, 2] - cs[2]) * 100.0, 2));
                //double dtemp2 = Math.Sqrt(Math.Pow((gl._dico[ind, 0] - cd[0]) * 100.0, 2) + Math.Pow((gl._dico[ind, 1] - cd[1]) * 100.0, 2) + Math.Pow((gl._dico[ind, 2] - cd[2]) * 100.0, 2));
                if (dtemp == 0) throw new ArgumentOutOfRangeException("dtemp", "EnPoI : Distance is 0.");
                switch (et)
                {
                    case 0:
                        {
                            dtemp = gl._mlkc[ind] / dtemp;
                            //dtemp2 = gl._mlkc[ind] / dtemp2;
                            break;
                        }
                    case 1:
                        {
                            dtemp = gl._Hachg[ind] / dtemp;
                            //dtemp2 = gl._Hachg[ind] / dtemp2;
                            break;
                        }
                    case 2:
                        {
                            dtemp = gl._Hacm5chg[ind] / dtemp;
                            //dtemp2 = gl._Hacm5chg[ind] / dtemp2;
                            break;
                        }
                    case 3:
                        {
                            dtemp = gl._ESPc[ind] / dtemp;
                            //dtemp2 = gl._ESPc[ind] / dtemp2;
                            break;
                        }
                    case 4:
                        {
                            dtemp = gl._nch[ind] / dtemp;
                            //dtemp2 = gl._nch[ind] / dtemp2;
                            break;
                        }
                    case 5:
                        {
                            dtemp = gl._APTc[ind] / dtemp;
                            //dtemp2 = gl._APTc[ind] / dtemp2;
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("et", "EnPoC : Unknown charge type.");
                }
                /*
                if (dtemp > 1E-25 || dtemp2 > 1E-25)
                {
                    if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoC : Result can not be verified.");
                }
                dtemp += dtemp2;
                dtemp /= 2.0;*/
                lock (lo) dres += dtemp;
            });
            if (Double.IsNaN(dres) || Double.IsInfinity(dres)) throw new ArgumentOutOfRangeException("dres", "EnPoC : Result is invalid.");
            return dres;
        }
        public double EnPoC2(in int[] Gr, double[] cs, ref ParallelOptions po, byte et)//電荷環境ポテンシャル(r二乗)、cは中心(s標準d双極子)、et0マリケン電荷/et1はHirshfeld原子電荷/et2はHirshfeld原子CM5電荷/et3はESP電荷/et4は自然電荷/et5はAPT電荷
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs/cd", "EnPoC : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gr, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "EnPoC2 : Atom index is invalid.");
                double dtemp = Math.Pow((gl._soco[ind, 0] - cs[0]) * 100.0, 2) + Math.Pow((gl._soco[ind, 1] - cs[1]) * 100.0, 2) + Math.Pow((gl._soco[ind, 2] - cs[2]) * 100.0, 2);
                //double dtemp2 = Math.Pow((gl._dico[ind, 0] - cd[0]) * 100.0, 2) + Math.Pow((gl._dico[ind, 1] - cd[1]) * 100.0, 2) + Math.Pow((gl._dico[ind, 2] - cd[2]) * 100.0, 2);
                if (dtemp == 0) throw new ArgumentOutOfRangeException("dtemp", "EnPoI : Distance is 0.");
                switch (et)
                {
                    case 0:
                        {
                            dtemp = gl._mlkc[ind] / dtemp;
                            //dtemp2 = gl._mlkc[ind] / dtemp2;
                            break;
                        }
                    case 1:
                        {
                            dtemp = gl._Hachg[ind] / dtemp;
                            //dtemp2 = gl._Hachg[ind] / dtemp2;
                            break;
                        }
                    case 2:
                        {
                            dtemp = gl._Hacm5chg[ind] / dtemp;
                            //dtemp2 = gl._Hacm5chg[ind] / dtemp2;
                            break;
                        }
                    case 3:
                        {
                            dtemp = gl._ESPc[ind] / dtemp;
                            //dtemp2 = gl._ESPc[ind] / dtemp2;
                            break;
                        }
                    case 4:
                        {
                            dtemp = gl._nch[ind] / dtemp;
                            //dtemp2 = gl._nch[ind] / dtemp2;
                            break;
                        }
                    case 5:
                        {
                            dtemp = gl._APTc[ind] / dtemp;
                            //dtemp2 = gl._APTc[ind] / dtemp2;
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("et", "EnPoC : Unknown charge type.");
                }
                /*
                if (dtemp > 1E-25 || dtemp2 > 1E-25)
                {
                    if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoC : Result can not be verified.");
                }
                dtemp += dtemp2;
                dtemp /= 2.0;*/
                lock (lo) dres += dtemp;
            });
            if (Double.IsNaN(dres) || Double.IsInfinity(dres)) throw new ArgumentOutOfRangeException("dres", "EnPoC : Result is invalid.");
            return dres;
        }
        private double EnPoGo(in int[] Gr, double[] cs, ref ParallelOptions po, bool t, bool? l, double exp)//総軌道電子環境ポテンシャル、cは中心(s標準d双極子)、t trueは価電子/false1はリュードベリ電子、l trueはL層/falseはM+層/nullはπ、expは冪
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs/cd", "EnPoGo : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Gr, po, (ind) =>
            {
                if (ind >= gl._an) throw new ArgumentOutOfRangeException("ind", "EnPoGo : Atom index is invalid.");
                double ds = 0.0, L = 0.0, L2 = 0.0;
                if (l == true)
                {
                    if (gl._als[ind] < 7 || gl._als[ind] > 9) return;
                    int cnt = gl._aobl[ind];
                    int cnt2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                    int itemp = cnt;
                    switch (gl._als[ind])
                    {
                        case 7://N
                        case 8://O
                        case 9://F
                            {
                                if (gl._als[ind] == 7)
                                {
                                    L = 2.0;
                                    L2 = 5.0;
                                }
                                else if (gl._als[ind] == 8)
                                {
                                    L = 4.0;
                                    L2 = 6.0;
                                }
                                else if (gl._als[ind] == 9)
                                {
                                    L = 6.0;
                                    L2 = 7.0;
                                }
                                if (cnt2 - cnt != 14) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("EnPoGo: ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                                if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                break;
                            }
                        default: throw new ArgumentOutOfRangeException("ind", "EnPoGo : Unknown error.");
                    }
                }
                if (l == false)
                {
                    if (gl._als[ind] < 15) return;
                    int cnt = gl._aobl[ind];
                    int cnt2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                    int itemp = cnt;
                    switch (gl._als[ind])
                    {
                        case 15://P
                        case 16://S
                        case 17://Cl
                            {
                                if (gl._als[ind] == 15)
                                {
                                    L2 = 5.0;
                                    for (int cnt3 = 0; cnt3 < gl._rn; cnt3++)
                                    {
                                        if (gl._rdl[cnt3, 0] == ind || gl._rdl[cnt3, 1] == ind) L++;
                                    }
                                    if (L <= 2.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected P connection.");
                                    else if (L == 3.0) L = 4.0;
                                    else if (L == 4.0) L = 2.0;
                                    else if (L == 5.0) return;
                                    else throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected C connection.");
                                }
                                else if (gl._als[ind] == 16)
                                {
                                    L2 = 6.0;
                                    for (int cnt3 = 0; cnt3 < gl._rn; cnt3++)
                                    {
                                        if (gl._rdl[cnt3, 0] == ind || gl._rdl[cnt3, 1] == ind) L++;
                                    }
                                    if (L < 1.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected S connection.");
                                    else if (L == 1.0 || L == 2.0) L = 4.0;
                                    else if (L == 3.0) L = 2.0;
                                    else if (L == 4.0) return;
                                    else throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected S connection.");
                                }
                                else if (gl._als[ind] == 17)
                                {
                                    L = 6.0;
                                    L2 = 7.0;
                                }
                                if (cnt2 - cnt != 18) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("EnPoGo ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                                if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("6PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                break;
                            }
                        case 33://As
                        case 34://Se
                        case 35://Br
                            {
                                if (gl._als[ind] == 33)
                                {
                                    L = 2.0;
                                    L2 = 5.0;
                                }
                                else if (gl._als[ind] == 34)
                                {
                                    L = 4.0;
                                    L2 = 6.0;
                                }
                                else if (gl._als[ind] == 35)
                                {
                                    L = 6.0;
                                    L2 = 7.0;
                                }
                                if (cnt2 - cnt != 32) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("EnPoGo ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                                if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("4S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("6PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("6PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("7PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("7PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("7PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("8PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("11D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("11D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("11D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("11D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("11D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("12D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("12D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("12D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("12D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("12D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("gopjh ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                break;
                            }
                        case 51://Sb
                        case 52://Te
                        case 53://I
                            {
                                if (gl._als[ind] == 51)
                                {
                                    L = 2.0;
                                    L2 = 5.0;
                                }
                                else if (gl._als[ind] == 52)
                                {
                                    L = 4.0;
                                    L2 = 6.0;
                                }
                                else if (gl._als[ind] == 53)
                                {
                                    L = 6.0;
                                    L2 = 7.0;
                                }
                                if (cnt2 - cnt != 26) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("EnPoGo ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                                if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("6PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("9D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("10D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                break;
                            }
                        default: return;
                    }
                }
                if (l == null)
                {
                    int cnt = gl._aobl[ind];
                    int cnt2 = (ind == gl._an - 1) ? gl._bfn : gl._aobl[ind + 1];
                    int itemp = cnt;
                    switch (gl._als[ind])
                    {
                        case 6://C
                        case 7://N
                        case 8://O
                            {
                                for (int cnt3 = 0; cnt3 < gl._rn; cnt3++)
                                {
                                    if (gl._rdl[cnt3, 0] == ind || gl._rdl[cnt3, 1] == ind) L++;
                                }
                                if (gl._als[ind] == 6)
                                {
                                    L2 = 4.0;
                                    if (L < 2.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected C connection.");
                                    else if (L == 3.0) L = 1.0;
                                    else if (L == 4.0) return;
                                    else if (L != 2.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected C connection.");
                                }
                                else if (gl._als[ind] == 7)
                                {
                                    L2 = 5.0;
                                    if (L < 1.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected N connection.");
                                    else if (L == 1.0) L = 2.0;
                                    else if (L == 2.0) L = 1.0;
                                    else if (L == 3.0) return;
                                    else throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected N connection.");
                                }
                                else if (gl._als[ind] == 8)
                                {
                                    L2 = 6.0;
                                    if (L < 1.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected O connection.");
                                    else if (L == 1.0) L = 1.0;
                                    else if (L == 2.0) return;
                                    else throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected O connection.");
                                }
                                if (cnt2 - cnt != 14) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("EnPoGo: ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                                if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                break;
                            }
                        case 15://P
                        case 16://S
                            {
                                for (int cnt3 = 0; cnt3 < gl._rn; cnt3++)
                                {
                                    if (gl._rdl[cnt3, 0] == ind || gl._rdl[cnt3, 1] == ind) L++;
                                }
                                if (gl._als[ind] == 15)
                                {
                                    L2 = 5.0;
                                    if (L <= 2.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected P connection.");
                                    else if (L == 3.0 || L == 5.0) return;
                                    else if (L == 4.0) L = 1.0;
                                    else throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected C connection.");
                                }
                                else if (gl._als[ind] == 16)
                                {
                                    L2 = 6.0;
                                    if (L < 1) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected S connection.");
                                    else if (L == 2.0) return;
                                    else if (L == 3.0) L = 1.0;
                                    else if (L == 4.0) L = 2.0;
                                    else if (L != 1.0) throw new ArgumentOutOfRangeException("L", "EnPoGo : Unexpected S connection.");
                                }
                                if (cnt2 - cnt != 18) throw new ArgumentOutOfRangeException("cnt/cnt2", String.Format("EnPoGo ([{0}]={1}): Basis function number is incorrect.", ind, gl._als[ind]));
                                if (!gl._aol[itemp].Equals("1S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("2S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("3S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("4S", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("5PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("5PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("5PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!gl._aol[++itemp].Equals("6PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("6PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PX", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PY", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("7PZ", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D 0", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D+1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D-1", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D+2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                if (!gl._aol[++itemp].Equals("8D-2", StringComparison.InvariantCultureIgnoreCase)) throw new ArgumentOutOfRangeException("aol", String.Format("EnPoGo ([{0}]={1}): Unexpected orbital ({3}).", ind, gl._als[ind], gl._aol[itemp]));
                                if (!t) ds += gl._gop[itemp];
                                break;
                            }
                        default: return;
                    }
                }
                if (ds == 0.0) return;
                L /= L2;
                ds *= L;
                if (ds == 0.0) throw new ArgumentOutOfRangeException("ds", "EnPoGo : Unexpected 0.");
                double dtemp = Math.Pow((gl._soco[ind, 0] - cs[0]) * 100.0, 2.0) + Math.Pow((gl._soco[ind, 1] - cs[1]) * 100.0, 2.0) + Math.Pow((gl._soco[ind, 2] - cs[2]) * 100.0, 2.0);
                //double dtemp2 = Math.Pow((gl._dico[ind, 0] - cd[0]) * 100.0, 2.0) + Math.Pow((gl._dico[ind, 1] - cd[1]) * 100.0, 2.0) + Math.Pow((gl._dico[ind, 2] - cd[2]) * 100.0, 2.0);
                if (dtemp == 0.0) throw new ArgumentOutOfRangeException("dtemp", "EnPoGo : Distance is 0.");
                if (exp == 1.0)
                {
                    dtemp = ds / Math.Sqrt(dtemp);
                    //dtemp2 = ds / Math.Sqrt(dtemp2);
                }
                else if (exp == 2.0)
                {
                    dtemp = ds / dtemp;
                    //dtemp2 = ds / dtemp2;
                }
                else throw new NotImplementedException("EnPoGo : Method not implemented.");
                if (Double.IsNaN(dtemp) || Double.IsInfinity(dtemp)) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoGo : Result is invalid.");
                /*
                if (dtemp > 1E-9 || dtemp2 > 1E-9)
                {
                    if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoGo : Result can not be verified.");
                }
                dtemp += dtemp2;
                dtemp /= 2.0;*/
                lock (lo) dres += dtemp;
            });
            return dres;
        }
        private double EnPoNo(in int[] Nir, double[] cs, ref ParallelOptions po, bool s, double exp)//NBO環境ポテンシャル、cは中心(s標準d双極子)、s trueは一中心 、expは冪
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs", "EnPoNo : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Nir, po, (ind) =>
            {
                if (ind >= (s ? gl._nbo1n : gl._nbo2n)) throw new ArgumentOutOfRangeException("ind", "EnPoNo : NBO index is invalid.");
                double dtemp = 0.0;
                double drs;
                if (s)
                {
                    drs = Math.Pow((gl._soco[gl._nbon1[ind], 0] - cs[0]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon1[ind], 1] - cs[1]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon1[ind], 2] - cs[2]) * 100.0, 2.0);
                    //drd = Math.Pow((gl._dico[gl._nbon1[ind], 0] - cd[0]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon1[ind], 1] - cd[1]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon1[ind], 2] - cd[2]) * 100.0, 2.0);
                    if (drs == 0) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNo : Distance is 0.");
                    if (exp == 1.0)
                    {
                        dtemp = gl._nboo1[ind] / Math.Sqrt(drs);
                        //dtemp2 = gl._nboo1[ind] / Math.Sqrt(drd);
                    }
                    else if (exp == 2.0)
                    {
                        dtemp = gl._nboo1[ind] / drs;
                        //dtemp2 = gl._nboo1[ind] / drd;
                    }
                    else throw new NotImplementedException("EnPoNo : Method not implemented.");
                    if (Double.IsNaN(dtemp) || Double.IsInfinity(dtemp)) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNo : Result is invalid.");
                    /*
                    if (dtemp > 1E-9 || dtemp2 > 1E-9)
                    {
                        if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNo : Result can not be verified.");
                    }
                    dtemp += dtemp2;
                    dtemp /= 2.0;*/
                    lock (lo) dres += dtemp;
                }
                else
                {
                    drs = Math.Pow((gl._soco[gl._nbon21[ind], 0] - cs[0]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon21[ind], 1] - cs[1]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon21[ind], 2] - cs[2]) * 100.0, 2.0);
                    //drd = Math.Pow((gl._dico[gl._nbon21[ind], 0] - cd[0]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon21[ind], 1] - cd[1]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon21[ind], 2] - cd[2]) * 100.0, 2.0);
                    if (drs == 0) throw new ArgumentOutOfRangeException("dtemp", "EnPoNo : Distance is 0.");
                    if (exp == 1.0)
                    {
                        dtemp = gl._nboo2[ind] * gl._nbor21[ind] / Math.Sqrt(drs);
                        //dtemp2 = gl._nboo2[ind] * gl._nbor21[ind] / Math.Sqrt(drd);
                    }
                    else if (exp == 2.0)
                    {
                        dtemp = gl._nboo2[ind] * gl._nbor21[ind] / drs;
                        //dtemp2 = gl._nboo2[ind] * gl._nbor21[ind] / drd;
                    }
                    else throw new NotImplementedException("EnPoNo : Method not implemented.");
                    if (Double.IsNaN(dtemp) || Double.IsInfinity(dtemp)) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNo : Result is invalid.");
                    /*
                    if (dtemp > 1E-9 || dtemp2 > 1E-9)
                    {
                        if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNo : Result can not be verified.");
                    }
                    dtemp += dtemp2;
                    dtemp /= 2.0;*/
                    lock (lo) dres += dtemp;
                    drs = Math.Pow((gl._soco[gl._nbon22[ind], 0] - cs[0]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon22[ind], 1] - cs[1]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon22[ind], 2] - cs[2]) * 100.0, 2.0);
                    //drd = Math.Pow((gl._dico[gl._nbon22[ind], 0] - cd[0]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon22[ind], 1] - cd[1]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon22[ind], 2] - cd[2]) * 100.0, 2.0);
                    if (drs == 0) throw new ArgumentOutOfRangeException("dtem", "EnPoNo : Distance is 0.");
                    if (exp == 1.0)
                    {
                        dtemp = gl._nboo2[ind] * gl._nbor22[ind] / Math.Sqrt(drs);
                        //dtemp2 = gl._nboo2[ind] * gl._nbor22[ind] / Math.Sqrt(drd);
                    }
                    else if (exp == 2.0)
                    {
                        dtemp = gl._nboo2[ind] * gl._nbor22[ind] / drs;
                        //dtemp2 = gl._nboo2[ind] * gl._nbor22[ind] / drd;
                    }
                    else throw new NotImplementedException("EnPoNo : Method not implemented.");
                    if (Double.IsNaN(dtemp) || Double.IsInfinity(dtemp)) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNo : Result is invalid.");
                    /*
                    if (dtemp > 1E-9 || dtemp2 > 1E-9)
                    {
                        if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNo : Result can not be verified.");
                    }
                    dtemp += dtemp2;
                    dtemp /= 2.0;*/
                    lock (lo) dres += dtemp;
                }
            });
            return dres;
        }
        private double EnPoNow(in int[] Nir, double[] cs, ref ParallelOptions po, double exp, byte et)//重み付きNBO環境ポテンシャル(一中心)、cは中心(s標準d双極子)、expは冪、et0はファンデルワールス半径(pm)/et1は計算原子半径(pm)/et2は経験原子半径(pm)/et3はイオン半径(空)(pm)/et4はイオン半径(満)(pm)/et5はポーリングの電気陰性度/et6はアレンの電気陰性度/et7はマリケンの電気陰性度
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs", "EnPoNow : Method is only for 3D.");
            double dres = 0;
            object lo = new object();
            Parallel.ForEach(Nir, po, (ind) =>
            {
                if (ind >= gl._nbo1n) throw new ArgumentOutOfRangeException("ind", "EnPoNow : NBO index is invalid.");
                double dtemp = 0.0;
                double drs = Math.Pow((gl._soco[gl._nbon1[ind], 0] - cs[0]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon1[ind], 1] - cs[1]) * 100.0, 2.0) + Math.Pow((gl._soco[gl._nbon1[ind], 2] - cs[2]) * 100.0, 2.0);
                //double drd = Math.Pow((gl._dico[gl._nbon1[ind], 0] - cd[0]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon1[ind], 1] - cd[1]) * 100.0, 2.0) + Math.Pow((gl._dico[gl._nbon1[ind], 2] - cd[2]) * 100.0, 2.0);
                if (drs == 0) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNow : Distance is 0.");
                if (exp == 1.0)
                {
                    dtemp = gl._nboo1[ind] / Math.Sqrt(drs);
                    //dtemp2 = gl._nboo1[ind] / Math.Sqrt(drd);
                }
                else if (exp == 2.0)
                {
                    dtemp = gl._nboo1[ind] / drs;
                    //dtemp2 = gl._nboo1[ind] / drd;
                }
                else throw new NotImplementedException("EnPoNow : Method not implemented.");
                if (Double.IsNaN(dtemp) || Double.IsInfinity(dtemp)) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNow : Result is invalid.");
                /*
                if (dtemp > 1E-9 || dtemp2 > 1E-9)
                {
                    if (Math.Abs(dtemp - dtemp2) / (dtemp + dtemp2) > 0.01) throw new ArgumentOutOfRangeException("dtemp/dtemp2", "EnPoNow : Result can not be verified.");
                }
                dtemp += dtemp2;
                dtemp /= 2.0;*/
                NatAtoms na = new NatAtoms();
                switch (et)
                {
                    case 0:
                        {
                            dtemp *= na.fthvdWRfP(gl._als[gl._nbon1[ind]]);
                            break;
                        }
                    case 1:
                        {
                            dtemp *= na.fthAtCRfP(gl._als[gl._nbon1[ind]]);
                            break;
                        }
                    case 2:
                        {
                            dtemp *= na.fthAtERfP(gl._als[gl._nbon1[ind]]);
                            break;
                        }
                    case 3:
                        {
                            dtemp *= na.fthIoRfP(gl._als[gl._nbon1[ind]]).Item1;
                            break;
                        }
                    case 4:
                        {
                            dtemp *= na.fthIoRfP(gl._als[gl._nbon1[ind]]).Item2;
                            break;
                        }
                    case 5:
                        {
                            dtemp *= na.fthEnPfP(gl._als[gl._nbon1[ind]]);
                            break;
                        }
                    case 6:
                        {
                            dtemp *= na.fthEnAfP(gl._als[gl._nbon1[ind]]);
                            break;
                        }
                    case 7:
                        {
                            dtemp *= na.fthEnMfP(gl._als[gl._nbon1[ind]]);
                            break;
                        }
                    default: throw new ArgumentOutOfRangeException("et", "EnPoNow : Unknown environment type.");
                }
                lock (lo) dres += dtemp;
            });
            return dres;
        }
        private double DipAC(int Y1, int Y2, bool cos)//双極子モーメント角度
        {
            if (Y1 >= gl._an || Y2 >= gl._an) throw new ArgumentOutOfRangeException("Y1/Y2", "DipAC : Unexpected atom.");
            double dres = gl._dico[Y1, 2] - gl._dico[Y2, 2];
            double dtemp = Math.Sqrt(Math.Pow(gl._dico[Y1, 0] - gl._dico[Y2, 0], 2.0) + Math.Pow(gl._dico[Y1, 1] - gl._dico[Y2, 1], 2.0) + Math.Pow(dres, 2.0));
            if (dtemp == 0.1) throw new ArgumentOutOfRangeException("dtemp", "DipAC : Distance is too small.");
            dres /= dtemp;
            dres = Math.Abs(dres);
            if (cos) return dres;
            else return Math.Sqrt(1 - Math.Pow(dres, 2.0));
        }/*
        private double EnPoVel(in int[] Gr, in int[] Nir, double[] cs, SGKC.Bector bv, ref ParallelOptions po, bool ns, double exp)//ベクトル環境ポテンシャル(一中心)、csは中心(標準座標)、ns trueは内積/falseは外積、expは冪
        {
            if (cs.Length != 3) throw new ArgumentOutOfRangeException("cs/cd", "EnPoC : Method is only for 3D.");
            List<int> ga;
            List<SGKC.Bector> gcv;
            List<SGKC.Bector[]> Lv;
            object lo1 = new object();
            object lo2 = new object();
            object lo3 = new object();
            Parallel.ForEach(Gr, po, (ind) =>
            {
                switch (gl._als[ind])
                {
                    case 7://N
                        {
                            int bn = 0;
                            for (int cnt3 = 0; cnt3 < gl._rn; cnt3++)
                            {
                                if (gl._rdl[cnt3, 0] == ind || gl._rdl[cnt3, 1] == ind) bn++;
                            }
                            break;
                        }
                    case 8://O
                        {
                            int bn = 0;
                            for (int cnt3 = 0; cnt3 < gl._rn; cnt3++)
                            {
                                if (gl._rdl[cnt3, 0] == ind || gl._rdl[cnt3, 1] == ind) bn++;
                            }
                            break;
                        }
                    case 9://F
                    case 17://Cl
                    case 35://Br
                    case 53://I
                        {
                            break;
                        }
                    case 15://P
                    case 16://S
                        {
                            int bn = 0;
                            for (int cnt3 = 0; cnt3 < gl._rn; cnt3++)
                            {
                                if (gl._rdl[cnt3, 0] == ind || gl._rdl[cnt3, 1] == ind) bn++;
                            }
                            break;
                        }
                    case 33://As
                    case 51://Sb
                        {
                            break;
                        }
                    case 34://Se
                    case 52://Te
                        {
                            break;
                        }
                    default: return;
                }
            });
            throw new NotImplementedException("EnPoVel : Method Not implemented yet.");
        }*/
        public void Dispose()
        {
            gl.Dispose();
            HydL = null;
            BorL = null;
            CarL = null;
            NitL = null;
            OxyL = null;
            FluL = null;
            PhoL = null;
            SulL = null;
            ChlL = null;
            BroL = null;
            IodL = null;
            CoC1 = null;
            CoC2 = null;
            CoC3 = null;
            CoC4 = null;
            CoC5 = null;
            CoC6 = null;
            CoO = null;
            CoH = null;
            CoHac = null;
            CoFuRiH = null;
            CoFuRiL = null;
            sub3H = null;
            sub3L = null;
            Ri123456H = null;
            R123456H = null;
            Ri123456L = null;
            R123456L = null;
            RiCFRH = null;
            RCFRH = null;
            RiCFRL = null;
            RCFRL = null;
            RiC2O = null;
            RC2O = null;
            AiCPhH = null;
            ACPhH = null;
            AiCPhL = null;
            ACPhL = null;
            AiCFRH = null;
            ACFRH = null;
            AiCFRL = null;
            ACFRL = null;
            Aico = null;
            Aiko = null;
            AiCOs = null;
            AiCOs2 = null;
            AicOS = null;
            AicOS2 = null;
            DiCPhH = null;
            DCPhH = null;
            DiCPhL = null;
            DCPhL = null;
            DiCFRH = null;
            DCFRH = null;
            DiCFRL = null;
            DCFRL = null;
            Di11s = null;
            D11s = null;
            rcds = null;
            OvIm = null;
            CPhhmLAB = null;
            CPhlmLAB = null;
            CPhshmLAB = null;
            CPhslmLAB = null;
            CFRhmLAB = null;
            CFRlmLAB = null;
            CFRshmLAB = null;
            CFRslmLAB = null;
            CFROhmLAB = null;
            CFROlmLAB = null;
            CFROshmLAB = null;
            CFROslmLAB = null;
            sub3hmLAB = null;
            sub3lmLAB = null;
            sub3shmLAB = null;
            sub3slmLAB = null;
            CPhdxDFzF = null;
            CFRdxDFzF = null;
            CoOdxDF = null;
            sub3dxDFzF = null;
            CPhpxDFzF = null;
            CFRpxDFzF = null;
            CoOpxDF = null;
            sub3pxDFzF = null;
            CPhgpCVR = null;
            CFRgpCVR = null;
            CoOgpCVR = null;
            sub3gpCVR = null;
            BINOLdDF = null;
            BINOLpDF = null;
            BINOLgpCVR = null;
            CPhHgpCVR = null;
            CPhLgpCVR = null;
            CFRHgpCVR = null;
            CFRLgpCVR = null;
            CoOHgpCVR = null;
            CoOLgpCVR = null;
            sub3HgpCVR = null;
            sub3LgpCVR = null;
            CPhMcGDQ = null;
            CFRMcGDQ = null;
            CoOMcGDQ = null;
            sub3McGDQ = null;
            C1McGDQ = null;
            C2McGDQ = null;
            C3McGDQ = null;
            CFRMhcGDQ = null;
            QdMSkMhFb = null;
            TQdMMhFb = null;
            QdMSkMhFb = null;
            HxMSkMhFb = null;
            CPhHfP = null;
            CPhHHfP = null;
            CPhLHfP = null;
            CoOHfp = null;
            CoOHHfp = null;
            CoOLHfp = null;
            sub3HfP = null;
            CFRHfP = null;
            C1HfP = null;
            C2HfP = null;
            C3HfP = null;
            HDipN = null;
            CPhHfC = null;
            CPhHfC = null;
            CPhLHfC = null;
            CoOHfC = null;
            CoOHHfC = null;
            CoOLHfC = null;
            sub3HfC = null;
            sub3HHfC = null;
            sub3LHfC = null;
            CFRHfC = null;
            CFRHHfC = null;
            CFRLHfC = null;
            C1HfC = null;
            C2HfC = null;
            C3HfC = null;
            CFRHfhC = null;
            CFRHHfhC = null;
            CFRLHfhC = null;
            moevov = null;
            tokeov = null;
            CPhEcKTZ = null;
            CoOEcKTZ = null;
            sub3EcKTZ = null;
            CFREcKTZ = null;
            C123Ec = null;
            CFREhcKTZ = null;
            C123Ep = null;
            CPhNAOOvrEvr = null;
            CPhHNAOOvrEvr = null;
            CPhLNAOOvrEvr = null;
            CoONAOOvrEvr = null;
            sub3NAOOvrEvr = null;
            sub3HNAOOvrEvr = null;
            sub3LNAOOvrEvr = null;
            CFRNAOOvrEvr = null;
            CFRHNAOOvrEvr = null;
            CFRLNAOOvrEvr = null;
            C1NAOOvrEvr = null;
            C2NAOOvrEvr = null;
            C3NAOOvrEvr = null;
            CoOHNAOEvr = null;
            CoOLNAOEvr = null;
            C1HNAOEvr = null;
            C1LNAOEvr = null;
            C2HNAOEvr = null;
            C2LNAOEvr = null;
            C3HNAOEvr = null;
            C3LNAOEvr = null;
            CPhNAOcGDQ = null;
            sub3NAOcGDQ = null;
            CFRNAOcGDQ = null;
            C123NAOc = null;
            sub3NAOtGDQ = null;
            CPhN2s2p = null;
            sub3N2s2p = null;
            sub3Nnsnp = null;
            CFRN2s2p = null;
            C1N2s2p = null;
            C2N2s2p = null;
            C3N2s2p = null;
            CPhBD1THL = null;
            CPhBD1espd = null;
            CPhHBD1espd = null;
            CPhLBD1espd = null;
            CPhBD2THL = null;
            CPhBD2pd = null;
            CPhHBD2pd = null;
            CPhLBD2pd = null;
            CPhBDs1THL = null;
            CPhBDs1espd = null;
            CPhHBDs1espd = null;
            CPhLBDs1espd = null;
            CPhBDs2THL = null;
            CPhBDs2pd = null;
            CPhHBDs2pd = null;
            CPhLBDs2pd = null;
            CFRBD1THL = null;
            CFRBD1espd = null;
            CFRHBD1espd = null;
            CFRLBD1espd = null;
            CFRBD2THL = null;
            CFRBD2pd = null;
            CFRHBD2pd = null;
            CFRLBD2pd = null;
            CFRBDs1THL = null;
            CFRBDs1espd = null;
            CFRHBDs1espd = null;
            CFRLBDs1espd = null;
            CFRBDs2THL = null;
            CFRBDs2pd = null;
            CFRHBDs2pd = null;
            CFRLBDs2pd = null;
            sub3BD2THL = null;
            sub3BD2pd = null;
            sub3HBD2pd = null;
            sub3LBD2pd = null;
            sub3BDs2THL = null;
            sub3BDs2pd = null;
            sub3HBDs2pd = null;
            sub3LBDs2pd = null;
            sub3L2THL = null;
            sub3L2espd = null;
            sub3HL2espd = null;
            sub3LL2espd = null;
            sub3LnTHL = null;
            sub3Lnespd = null;
            sub3HLnespd = null;
            sub3LLnespd = null;
            C11BDBDs = null;
            C11BDespd = null;
            C11BDsespd = null;
            C2OBDTHL = null;
            C2OBDespd = null;
            C2OHBDespd = null;
            C2OLBDespd = null;
            C2OBDsTHL = null;
            C2OBDsespd = null;
            C2OHBDsespd = null;
            C2OLBDsespd = null;
            C3sBDTHL = null;
            C3sBDespd = null;
            C3sHBDespd = null;
            C3sLBDespd = null;
            C3sBDsTHL = null;
            C3sBDsespd = null;
            C3sHBDsespd = null;
            C3sLBDsespd = null;
            CoOLTHL = null;
            CoOLespd = null;
            CoOHLespd = null;
            CoOLLespd = null;
            NHOSk1sin2TCS = null;
            NHOSk1cosTCS = null;
            NHOSk2cos2TCS = null;
            NHOSk2sinTCS = null;
            CoPh1DonZGD = null;
            CoPh2DonZGD = null;
            CoPhAccZGD = null;
            CFR1DonZGD = null;
            CFR2DonZGD = null;
            CFRAccZGD = null;
            sub32DonZGD = null;
            sub3L2DonZGD = null;
            sub3LnDonZGD = null;
            sub3AccZGD = null;
            C11DonAcc = null;
            C2ODonZGD = null;
            C2OAccZGD = null;
            C3sDonZGD = null;
            C3sAccZGD = null;
            CoPh1BESKT = null;
            CoPh2BESKT = null;
            CFR1BESKT = null;
            CFR2BESKT = null;
            sub32BESKT = null;
            sub3L2ESKT = null;
            sub3LnESKT = null;
            C2OBESKT = null;
            C3sBESKT = null;
            CoOLESKT = null;
            C1GiHGD = null;
            C1GaHGD = null;
            C1GtFHGD = null;
            C1GenHGD = null;
            C2GiHGD = null;
            C2GaHGD = null;
            C2GtFHGD = null;
            C2GenHGD = null;
            C3GiHGD = null;
            C3GaHGD = null;
            C3GtFHGD = null;
            C3GenHGD = null;
            C4GiHGD = null;
            C4GaHGD = null;
            C4GtFHGD = null;
            C4GenHGD = null;
            C5GiHGD = null;
            C5GaHGD = null;
            C5GtFHGD = null;
            C5GenHGD = null;
            C6GiHGD = null;
            C6GaHGD = null;
            C6GtFHGD = null;
            C6GenHGD = null;
            CoOGiHGD = null;
            CoOGaHGD = null;
            CoOGtFHGD = null;
            CoOGenHGD = null;
            CoPhGiHGD = null;
            CoPhGaHGD = null;
            CoPhGtFHGD = null;
            CoPhGenHGD = null;
            CFRGiHGD = null;
            CFRGaHGD = null;
            CFRGtFHGD = null;
            CFRGenHGD = null;
            dmdpDFT = null;
            dqctDFT = null;
            orgtDFT = null;
            orgeEW = null;
            C123OAc = null;
            CoPhAcGDZ = null;
            CFRAcGDZ = null;
            sub3AcGDZ = null;
            CFRhAcGDZ = null;
            EPDFT = null;
            APDFT = null;
            TIRke = null;
            h2IRke = null;
            h5IRke = null;
            kIRke = null;
            khIRke = null;
            k2IRke = null;
            iIRke = null;
            IRAF = null;
            paxDFT = null;
            lfvS = null;
            Vsub3vdWC32RKTS = null;
            Vsub3vdWC34RKTS = null;
            Vsub3vdWC36RKTS = null;
            Vsub3vdWC38RKTS = null;
            Vsub3ACC32RKTS = null;
            Vsub3ACC34RKTS = null;
            Vsub3ACC36RKTS = null;
            Vsub3ACC38RKTS = null;
            Vsub3AEC32RKTS = null;
            Vsub3AEC34RKTS = null;
            Vsub3AEC36RKTS = null;
            Vsub3AEC38RKTS = null;
            Vsub3IEC32RKTS = null;
            Vsub3IEC34RKTS = null;
            Vsub3IEC36RKTS = null;
            Vsub3IEC38RKTS = null;
            Vsub3IAC32RKTS = null;
            Vsub3IAC34RKTS = null;
            Vsub3IAC36RKTS = null;
            Vsub3IAC38RKTS = null;
            Vsub3vdWOc = null;
            Vsub3ACOc = null;
            Vsub3AEOc = null;
            Vsub3IEOc = null;
            Vsub3IAOc = null;
            EnPsub3Oc = null;
            EnPsub3Oc2 = null;
            ElPsub3Oc = null;
            ElPsub3Oc2 = null;
            EgoPsub3Oc = null;
            EgoPsub3Oc2 = null;
            EnoPsub3Oc = null;
            EnoPsub3Oc2 = null;
            EnoPwLsub3Oc = null;
            EnoPwLsub3Oc2 = null;
            DipAcos = null;
            DipAsin = null;
            dpamDFT = null;
        }
    }
}